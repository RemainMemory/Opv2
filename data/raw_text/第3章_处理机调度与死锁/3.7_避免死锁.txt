

--- Page 119 ---
计算机操作系统
F(disk drive) = 5;
F(printer) =12;
在对系统所有资源类型进行线性排序后，便可采用这样的预防协议：规定每个进程必
须按序号递增的顺序请求资源。一个进程在开始时，可以请求某类资源R；的单元。以后，
当且仅当F(R)>F(R;)时，进程才可以请求资源R的单元。如果需要多个同类资源单元，
则必须一起请求。例如，当某进程需要同时使用打印机和磁带机时，由于磁带机序号低，
而打印机序号高，故必须先请求磁带机，再请求打印机。假如某进程已请求到一些序号较
高的资源，后来它又想请求一个序号低的资源时，它必须先释放所有具有相同和更高序号
的资源后，才能申请序号低的资源。在采用这种策略后所形成的资源分配图中，不可能再
出现环路，因而破坏了“循环等待”条件。事实上，总有一个进程占据了较高序号的资源，
此后它继续申请的资源必然是空闲的，因而进程可以一直向前推进。
在采用这种策略时，应如何来规定每种资源的序号是十分重要的。通常应根据大多数
进程需要资源的先后顺序来确定。一般情况下，进程总是先输入程序和数据，继而进行运
算，最后将计算结果输出。故可以为输入设备规定较低的序号，如前面是将磁带机定为1；
为输出设备规定较高的序号，如把打印机定为12。
善。但也存在下述问题：首先，为系统中各类资源所规定的序号必须相对稳定，这就限制
了新类型设备的增加：其次，尽管在为资源的类型分配序号时，已经考虑到大多数作业在
定的顺序不同，造成对资源的浪费。第三，为方便用户，系统对用户在编程时所施加的限制
条件应尽量少，然而这种按规定次序申请资源的方法必然会限制用户简单、自主地编程，
13.7避免死锁
避免死锁同样是属于事先预防的策略，但并不是事先采取某种限制措施，破坏产生死
锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。
这种方法所施加的限制条件较弱，可能获得较好的系统性能，目前常用此方法来避免发生
死锁。
3.7.1系统安全状态
在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态
时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。
1.安全状态
在该方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次
否则，令进程等待。所谓安全状态，是指系统能按某种进程推进顺序（P，P2，“，P)为每个
进程P;分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完
成。此时称(P1，P2，“，P)为安全序列。如果系统无法找到这样一个安全序列，则称系统处
110

--- Page 120 ---
第三章处理机调度与死锁
于不安全状态。虽然并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状
态后，就有可能进入死锁状态。反之，只要系统处于安全状态，系统便不会进入死锁状态。
因此，避免死锁的实质在于，系统在进行资源分配时，应使系统不进入不安全状态。
2.安全状态之例
假定系统中有三个进程P、P2和P3，共有12台磁带机。进程P总共要求10台磁带
机，P2和P3分别要求4台和9台。假设在T时刻，进程P、P2和P3已分别获得5台、2
台和2台磁带机，尚有3台空闲未分配，如下表所示：
进程-
最大需求
已分配
可用
P
10
5
3
P2
4
2
P3
9
2
经分析发现，在To时刻系统是安全的，因为这时存在一个安全序列（P2，P1，P3)，即
只要系统按此进程序列分配资源，就能使每个进程都顺利完成。例如将剩余的磁带机取2
台分配给P2，使之继续运行，待P2完成便可释放出4台磁带机，于是可用资源增至5台；
以后再将这些全部分配给进程P1，使之运行，待P完成后，将释放出10台磁带机，P3便
能获得足够的资源，从而使P、P2、P3每个进程都能顺利完成。
3.由安全状态向不安全状态的转换
如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如在To
时刻以后P又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入
不安全状态。因为此时也无法再找到一个安全序列。例如把其余的2台分配给P2，这样在
P2完成后，只能释放出4台，既不能满足P尚需5台的要求，也不能满足P3需要6台的
要求，致使它们都无法推进到完成，彼此都在等待对方释放资源，结果导致死锁。类似地，
如果我们将剩余的2台磁带机先分配给P或P3，也同样都无法使它们推进到完成，因此从
给P分配了第3台磁带机开始，系统便又进入了不安全状态。
在建立了系统安全状态的概念后，便可知道避免死锁的基本思想，就是确保系统始终
处于安全状态。一个系统开始是处于安全状态的。当有进程请求一个可用资源时，系统需
对该进程的请求进行计算，若将资源分配给进程后系统仍处于安全状态，才将该资源分配
给进程。在上面的例子中，在P请求1台磁带机时，尽管系统中有可用的磁带机，但却不
能分配给它。必须等待到P和P2完成并释放出资源后再将足够的资源分配给P3。
3.7.2利用银行家算法避免死锁
最有代表性的避免死锁的算法是Dijkstra的银行家算法。起这样的名字是由于该算法
原本是为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需
要的情况。在OS中也可用它来实现避免死锁。
为实现银行家算法，每一个新进程在进入系统时，它必须申明在运行过程中，可能需
要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一
组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将
这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，
111

--- Page 121 ---
计算机操作系统
否则让进程等待。
1.银行家算法中的数据结构
为了实现银行家算法，在系统中必须设置这样四个数据结构，分别用来描述系统中可
利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少
资源的情况。
随该类资源的分配和回收而动态地改变。如果Available[j]=K，则表示系统中现有R;类资
源K个。
(2）最大需求矩阵Max。这是一个n×m的矩阵，它定义了系统中n个进程中的每一个
进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rg类资源的最大数目
为K。
（3）分配矩阵Allocation。这也是一个n×m的矩阵，它定义了系统中每一类资源当前
的数目为K。
（4）需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源
数。如果Need[i,j]=K，则表示进程i还需要Rg类资源K个方能完成其任务。
上述三个矩阵间存在下述关系：
Need[i, j] = Max[i, j] - Allocation[i, j]
2.银行家算法
设Request是进程P的请求向量，如果Request;[j]=K，表示进程P需要K个R类型
的资源。当P发出资源请求后，系统按下述步骤进行检查：
(1）如果Request;[j]≤Need[i，j]，便转向步骤(2)；否则认为出错，因为它所需要的资
源数已超过它所宣布的最大值。
(2）如果Request;[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须
等待。
(3）系统试探着把资源分配给进程P，并修改下面数据结构中的数值：
Available[j] =Available[j] -Request;[j];
Allocation[i, j] = Allocation[i, j] + Request;[j];
Need[i, j] = Need[i, j] - Request;[j];
(4）系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才
正式将资源分配给进程P，以完成本次分配；否则，将本次的试探分配作废，恢复原来的
资源分配状态，让进程P等待。
3.安全性算法
系统所执行的安全性算法可描述如下：
（1）设置两个向量：①工作向量Work，它表示系统可提供给进程继续运行所需的各类
资源数目，它含有m个元素，在执行安全算法开始时，Work：=Available；②Finish：它表
示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]：=false；当有
112

--- Page 122 ---
第三章处理机调度与死锁
足够资源分配给进程时，再令Finish[i]：=true。
(2）从进程集合中找到一个能满足下述条件的进程：
① Finish[i]=false;
② Need[i, j]≤Work[j];
若找到，执行步骤(3)，否则，执行步骤(4)。
(3）当进程P获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应
执行：
Work[j] =Work[j]+Allocation[i,j];
Finish[i] =true;
go to step 2;
(4）如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处
于不安全状态。
4.银行家算法之例
假定系统中有五个进程{Po,P，P2,P3,P4}和三类资源{A，B,C}，各种资源的数量分别为
10、5、7，在T时刻的资源分配情况如图3-15所示。
资源
Max
Allocation
Need
Available
情况
A
B
C
A
B
C
A
B
C
A
B
C
进程
Po
7
5
3
0
1
0
7
4
3
3
3
2
(2
3
0)
P
3
2
2
2
0
0
1
2
2
(3
0
2)
(0
2
0)
P2
9
0
2
3
0
2
6
0
0
P3
2
2
2
2
1
1
0
1
1
P4
4
3
3
0
0
2
4
3
1
图3-15T时刻的资源分配表
(1）To时刻的安全性：利用安全性算法对To时刻的资源分配情况进行分析(如图3-16
所示)可知，在To时刻存在着一个安全序列{P1,P3,P4,P2,Po}，故系统是安全的。
资源
Max
Need
Allocation
Work+Allocation
情况
Finish
A
B
C
A
B
C
A
B
C
A
B
C
进程
P
3
3
2
1
2
2
2
0
0
5
3
2
true
P3
5
3
2
0
1
1
7
4
1
2
1
3
true
P4
7
4
3
4
3
1
0
0
2
7
4
5
true
P2
7
4
5
6
0
0
3
0
2
10
4
7
true
10
4
0
10
Po
7
4
3
0
1
7
7
true
图3-16To时刻的安全序列
113

--- Page 123 ---
计算机操作系统
(2）P请求资源：P发出请求向量Request(1,0,2)，系统按银行家算法进行检查：
① Request;(1, 0, 2)≤Need(1, 2, 2);
② Request;(1, 0, 2)≤Available;(3, 3, 2);
③系统先假定可为P分配资源，并修改Available，Allocation和Need向量，由此形
成的资源变化情况如图3-15中的圆括号所示；
④再利用安全性算法检查此时系统是否安全，如图3-17所示。
资源
Work
Need
Allocation
Work+Allocation
情况
Finish
A
B
C
A
B
C
A
B
C
A
B
C
进程
P
2
3
0
2
0
3
0
2
3
2
true
P3
5
3
2
0
1
1
2
1
1
7
4
3
true
P4
7
4
3
3
1
0
0
2
7
4
5
true
Po
7
4
5
7
4
3
0
1
0
7
5
5
true
P2
7
5
5
6
0
0
3
2
10
5
7
true
0
图3-17P申请资源时的安全性检查
由所进行的安全性检查得知，可以找到一个安全序列{P，P3，P4，P2，Po}。因此，系
统是安全的，可以立即将P所申请的资源分配给它。
① Request4(3, 3, 0)≤Need4(4, 3, 1);
②Request4(3，3，0)>Available(2，3，0)，让P4等待。
(4）Po请求资源：Po发出请求向量Requesto(0，2，O)，系统按银行家算法进行检查：
① Requesto(0, 2,0)≤Needo(7, 4, 3);
② Requesto(0, 2,0)≤Available(2, 3,0);
③系统暂时先假定可为Po分配资源，并修改有关数据，如图3-18所示。
资源
Allocation
Need
Available
情况
A
B
C
A
B
C
A
B
C
进
程
Po
0
3
0
7
2
3
2
1
0
P
3
0
2
0
2
0
P2
3
0
2
6
0
0
1
P3
2
0
1
1
0
0
2
4
3
P4
1
图3-18为Po分配资源后的有关资源数据
(5）进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系
统进入不安全状态，此时系统不分配资源。
如果在银行家算法中把Po发出的请求向量改为Requesto(O，1，0)，系统是否能将资源
分配给它，请读者考虑。
114
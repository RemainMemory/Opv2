

--- Page 113 ---
计算机操作系统
3.5死锁概述
在第二章中，我们已经涉及到死锁的概念。例如，系统中只有一台扫描仪R和一台刻
录机R2。有两个进程P和P2，它们都准备将扫描的文挡刻录到CD光盘上，进程Pi先请
求扫描仪R并获得成功，进程P2先请求CD刻录机R2也获得成功。后来P又请求CD刻
录机，因它已被分配给了P2而阻塞。P2又请求扫描仪，也因被分配给了P而阻塞，此时
两个进程都被阻塞，双方都希望对方能释放出自己所需要的资源，但它们谁都因不能获得
自己所需的资源去继续运行，从而无法释放出自己占有的资源，并且一直处于这样的僵持
状态而形成死锁。又如，在第二章的哲学家进餐问题中，如果每一个哲学家因饥饿都拿起
了他们左边的筷子，当每一个哲学家又试图去拿起他们右边的筷子时，将会因无筷子可拿
而无限期地等待，从而产生死锁问题。在本章的后半部分，我们将对死锁发生的原因、如
何预防和避免死锁等问题作较详细的介绍。
3.5.1资源问题
在系统中有许多不同类型的资源，其中可以引起死锁的主要是，需要采用互斥访问方
法的、不可以被抢占的资源，即在前面介绍的临界资源。系统中这类资源有很多，如打印
机、数据文件、队列、信号量等。
1.可重用性资源和消耗性资源
1）可重用性资源
可重用性资源是一种可供用户重复使用多次的资源，它具有如下性质：
（1）每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。
（2）进程在使用可重用性资源时，须按照这样的顺序：①请求资源。如果请求资源失
败，请求进程将会被阻塞或循环等待。②使用资源。进程对资源进行操作，如用打印机进
行打印；③释放资源。当进程使用完后自己释放资源。
（3）系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能
创建也不能删除它。
对资源的请求和释放通常都是利用系统调用来实现的，例如对于设备，一般用
request/release；对于文件，可用open/close。对于需要互斥访问的资源，进程可以用信号量
的wait/signal操作来完成。进程在每次提出资源请求后，系统在执行时都需要做一系列的
工作。计算机系统中大多数资源都属于可重用性资源。
2）可消耗性资源
可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的，
它具有如下性质：①每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，
有时它可以有许多，有时可能为0；②进程在运行过程中，可以不断地创造可消耗性资源
的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目。③进程在运行过
程中，可以请求若干个可消耗性资源单元，用于进程自已的消耗，不再将它们返回给该资
104

--- Page 114 ---
第三章处理机调度与死锁
源类中。可消耗性资源通常是由生产者进程创建，由消费者进程消耗。最典型的可消耗性
资源就是用于进程间通信的消息等。
2.可抢占性资源和不可抢占性资源
1）可抢占性资源
可把系统中的资源分成两类，一类是可抢占性资源，是指某进程在获得这类资源后，
该资源可以再被其它进程或系统抢占。例如优先级高的进程可以抢占优先级低的进程的处
理机。又如可把一个进程从一个存储区转移到另一个存储区，在内存紧张时，还可将一个
进程从内存调出到外存上，即抢占该进程在内存的空间。可见，CPU和主存均属于可抢占
性资源。对于这类资源是不会引起死锁的。
2）不可抢占性资源
另一类资源是不可抢占性资源，即一旦系统把某资源分配给该进程后，就不能将它强
行收回，只能在进程用完后自行释放。例如，当一个进程已开始刻录光盘时，如果突然将
刻录机分配给另一个进程，其结果必然会损坏正在刻录的光盘，因此只能等刻好光盘后由
进程自己释放刻录机。另外磁带机、打印机等也都属于不可抢占性资源。
3.5.2计算机系统中的死锁
死锁的起因，通常是源于多个进程对资源的争夺，不仅对不可抢占资源进行争夺时会
引起死锁，而且对可消耗资源进行争夺时，也会引起死锁。
1.竞争不可抢占性资源引起死锁
通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进
备写两个文件F和F2，而这两者都属于可重用和不可抢占性资源。进程P先打开F，然
后再打开文件F2；进程P2先打开文件F2，后打开F，下面示出了这段代码。
P1
P2
....
...
Open(fi, w);
Open(f2,w)；
Open(f2, w);
Open(fi, w);
由于文件Fi(F2)已被P打开，故P2会被阻塞。当P写完文件Fi(或F2)而关闭F(F2)时，P2
会由阻塞状态转为就绪状态，被调度执行后重新打开文件F（或F2)。在这种情况下，P和
P2都能正常运行下去。若P2先打开F和F2，然后P才去打开F（或F2)，P和P2同样也可
以正常运行下去。
但如果在P打开F的同时，P2去打开F2，每个进程都占有一个打开的文件，此时就
已被打开而阻塞，它们希望对方关闭自己所需要的文件，但谁也无法运行，因此这两个进
程将会无限期地等待下去，而形成死锁。
我们可将上面的问题利用资源分配图进行描述，用方块代表可重用的资源（文件），用
圆圈代表进程，见图3-12所示。当箭头从进程指向文件时，表示进程请求资源(打开文件)；
105

--- Page 115 ---
计算机操作系统
当箭头从资源指向进程时，表示该资源已被分配给该进程(已被进程打开)。从中可以看出，
这时在P、P2及R和R2之间，已经形成了一个环路，说明已进入死锁状态。
P
接收
图3-12共享文件时的死锁情况
图3-13进程之间通信时的死锁
2.竞争可消耗资源引起死锁
现在进一步介绍竞争可消耗资源所引起的死锁。图3-13示出了在三个进程之间，在利
用消息通信机制进行通信时所形成的死锁情况。图中，m、m2和m是可消耗资源。进程
P一方面产生消息mi，利用send(p2，m)原语将它发送给P2；另一方面，它又要求从P3接
收消息m3。而进程P2一方面产生消息m2，利用send(p3,m2)原语将它发送给P3；另一方面，
它又需要接收进程P,所产生的消息m。类似地，进程Ps也产生消息m3，利用 send(pi,m3)
原语将它发送给P，而它又要求从进程P2接收其所产生的消息m2。如果三个进程间的消
息通信，则按下述顺序进行：
P1:·"send(p2, m1);receive(p3,m3);*.
P2:"send(p3, m2);receive(p1, m1); .….
P3:·send（p1,m3);-receive(p2,m2);
这三个进程都可以先将消息发送给下一个进程，相应地它们也都能够接收到从上一个
进程发来的消息，因此三个进程可以顺利地运行下去，而不会发生死锁。但若改成三个进
程都先执行receive操作，后执行send操作，即按下述的运行顺序：
P1:receive(p3, m3);send(p2, m1); ".
P2:receive(p1, m1);send(p3, m2); -".
P3:.-receive(p2, m2); send(pi, m3); ..
则这三个进程就会永远阻塞在它们的receive操作上，等待一条永远不会发出的消息，于是
发生了死锁。
3.进程推进顺序不当引起死锁
除了系统中多个进程对资源的竞争会引发死锁外，进程在运行过程中，对资源进行申
请和释放的顺序是否合法，也是在系统中是否会产生死锁的一个重要因素。例如，系统中
只有一台打印机R和一台磁带机R2，可供进程P和P2共享，由于进程在运行中具有异步
性特征，这就可能使P和P2两个进程按下述两种顺序向前推进。
1）进程推进顺序合法
在进程P和P2并发执行时，如果按图3-14中的曲线①所示的顺序推进：P1:Request(Rt)
→P1:Request(R2)→P:Releast(R)→P:Release(R2)→P2:Request(R2)→P2:Request(R1)
→P2：Release(R2)→P2：Release(Ri)，两个进程可顺利完成。类似地，若按图中曲线②和③
106

--- Page 116 ---
第三章处理机调度与死锁
所示的顺序推进，两进程也可以顺利完成。我们称这种不会引起进程死锁的推进顺序是合
法的。
2）进程推进顺序非法
若并发进程P和P2按图3-14中曲线④所示的顺序推进，它们将进入不安全区D内。
此时P保持了资源R，P2保持了资源R2，系统处于不安全状态。此刻，如果两个进程继
续向前推进，就可能发生死锁。例如，当P运行到P：Request(R2)时，将因R2已被P2占
用而阻塞；当P2运行到P2：Request(R,)时，也将因R,已被P占用而阻塞，于是发生了进
程死锁，这样的进程推进顺序就是非法的。
tp2
②
PRel(R)
P2Rel(R2)
P2Req(R)
D
P2Req(R2)
③
④
P
P
P
P
tp1
Req(R)
Req(Rz)
Rel(R)
Rel(R2)
图3-14进程推进顺序对死锁的影响
3.5.3死锁的定义、必要条件和处理方法
1.死锁的定义
在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁
进程所占有的资源。或者说每个进程所等待的事件是该组中其它进程释放所占有的资源。
可被唤醒。这样这组进程只能无限期地等待下去。由此可以给死锁做出如下的定义：
如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，
那么该组进程是死锁的(Deadlock)。
2.产生死锁的必要条件
虽然进程在运行过程中可能会发生死锁，但产生进程死锁是必须具备一定条件的。综
上所述不难看出，产生死锁必须同时具备下面四个必要条件，只要其中任一个条件不成立，
死锁就不会发生：
（1）互斥条件。进程对所分配到的资源进行排它性使用，即在一段时间内，某资源只
能被一个进程占用。如果此时还有其它进程请求该资源，则请求进程只能等待，直至占有
该资源的进程用毕释放。
107
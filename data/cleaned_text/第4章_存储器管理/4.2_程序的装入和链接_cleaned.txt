计算机操作系统 幅度地提高程序执行速度。高速缓存容量远大于寄存器，而比内存约小两到三个数量级左 右，从几十KB到几MB，访问速度快于主存储器。在计算机系统中，为了缓和内存与处 理机速度之间的矛盾，许多地方都设置了高速缓存。在以后各章中将会经常遇见各种高速 缓存的，届时再对它们进行详细的介绍。 将一些常用数据放在高速缓存中是否有效，这将涉及到程序执行的局部性原理（前已提 及：程序在执行时将呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个 部分。关于局部性原理问题，我们将在第五章中做进一步的介绍)。通常，进程的程序和数 据存放在主存储器中，每当要访问时，才被临时复制到一个速度较快的高速缓存中。这样， 当CPU访问一组特定信息时，须首先检查它是否在高速缓存中，如果已存在，便可直接从 中取出使用，以避免访问主存，否则，就须从主存中读出信息。如大多数计算机都有指令 高速缓存，用来暂存下一条将执行的指令，如果没有指令高速缓存，CPU将会空等若干个 周期，直到下一条指令从主存中取出。由于高速缓存的速度越高价格也越贵，故在有的计 算机系统中设置了两级或多级高速缓存。紧靠内存的一级高速缓存的速度最高，而容量最 小，二级高速缓存的容量稍大，速度也稍低。

2.磁盘缓存 由于目前磁盘的I/O速度远低于对主存的访问速度，为了缓和两者之间在速度上的不 访问磁盘的次数。但磁盘缓存与高速缓存不同，它本身并不是一种实际存在的存储器，而 是利用主存中的部分存储空间暂时存放从磁盘中读出（或写入)的信息。主存也可以看作是 辅存的高速缓存，因为，辅存中的数据必须复制到主存方能使用，反之，数据也必须先存 在主存中，才能输出到辅存。 一个文件的数据可能先后出现在不同层次的存储器中，例如，一个文件的数据通常被 存储在辅存中(如硬盘)，当其需要运行或被访问时，就必须调入主存，也可以暂时存放在 主存的磁盘高速缓存中。大容量的辅存常常使用磁盘，磁盘数据经常备份到磁带或可移动 磁盘组上，以防止硬盘故障时丢失数据。有些系统自动地把老文件数据从辅存转储到海量 存储器中，如磁带上，这样做还能降低存储价格。 1/4.2程序的装入和链接 用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的 程序，通常都要经过以下几个步骤：

(1）编译，由编译程序(Compiler)对用户源程序进行编译，形成若干个目标模块(Object Module);

(2）链接，由链接程序(Linker)将编译后形成的一组目标模块以及它们所需要的库函数 链接在一起，形成一个完整的装入模块(Load Module);

(3）装入，由装入程序(Loader)将装入模块装入内存。 图4-2示出了这样的三步过程。本节将扼要阐述程序(含数据)的链接和装入过程。 122  第四章存储器管理 内存 （库（ 链接 装入 编译程序 装入模块 程序 程序 产生的目 标模块 第一步 第二步 第三步 图4-2对用户程序的处理步骤

4.2.1程序的装入 为了阐述上的方便，我们先介绍一个无需进行链接的单个目标模块的装入过程。该目 标模块也就是装入模块。在将一个装入模块装入内存时，可以有如下三种装入方式：

1.绝对装入方式（AbsoluteLoadingMode） 当计算机系统很小，且仅能运行单道程序时，完全有可能知道程序将驻留在内存的什 么位置。此时可以采用绝对装入方式。用户程序经编译后，将产生绝对地址（即物理地址） 的目标代码。例如，事先已知用户程序（进程）驻留在从R处开始的位置，则编译程序所产 生的目标模块(即装入模块)，便可从R处开始向上扩展。绝对装入程序便可按照装入模块 中的地址，将程序和数据装入内存。装入模块被装入内存后，由于程序中的相对地址（即逻 辑地址）与实际内存地址完全相同，故不需对程序和数据的地址进行修改。 程序中所使用的绝对地址既可在编译或汇编时给出，也可由程序员直接赋予。但由程 序员直接给出绝对地址时，不仅要求程序员熟悉内存的使用情况，而且一旦程序或数据被 修改后，可能要改变程序中的所有地址。因此，通常是宁可在程序中采用符号地址，然后 在编译或汇编时，再将这些符号地址转换为绝对地址。

2.可重定位装入方式（RelocationLoadingMode） 绝对装入方式只能将目标模块装入到内存中事先指定的位置，这只适用于单道程序环 何处。因此，对于用户程序编译所形成的若干个目标模块，它们的起始地址通常都是从0 开始的，程序中的其它地址也都是相对于起始地址计算的。此时，不可能再用绝对装入方 式，而应采用可重定位装入方式，它可以根据内存的具体情况将装入模块装入到内存的适 当位置。 值得注意的是，在采用可重定位装入程序将装入模块装入内存后，会使装入模块中的 所有逻辑地址与实际装入内存后的物理地址不同，图4-3示出了这一情况。例如，在用户 程序的1000号单元处有一条指令LOAD1，2500，该指令的功能是将2500单元中的整数 365取至寄存器1。但若将该用户程序装入到内存的10000～15000号单元而不进行地址变 换，则在执行11000号单元中的指令时，它将仍从2500号单元中把数据取至寄存器1，而 123  计算机操作系统 导致数据错误。由图4-3可见，正确的方法应该是，将取数指令中的地址2500修改成12500， 即把指令中的逻辑地址2500与本程序在内存中的起始地址10000相加，才得到正确的物理 地址12500。除了数据地址应修改外，指令地址也须做同样的修改，即将指令的逻辑地址 1000与起始地址10000相加，得到绝对地址11000。通常，把在装入时对目标程序中指令 和数据地址的修改过程称为重定位。又因为地址变换通常是在进程装入时一次完成的，以 后不再改变，故称为静态重定位。 0 10000 1000 LOAD12500 11000 LOAD12500 2500 365 12500 365 5000 15000 作业地址空间 内存空间 图4-3作业装入内存时的情况

3.动态运行时的装入方式（DynamicRun-timeLoading） 可重定位装入方式可将装入模块装入到内存中任何允许的位置，故可用于多道程序环 境。但该方式并不充许程序运行时在内存中移动位置。因为，程序在内存中的移动，意味 着它的物理位置发生了变化，这时必须对程序和数据的地址（绝对地址）进行修改后方能运 行。然而，实际情况是，在运行过程中它在内存中的位置可能经常要改变，例如，在具有 对换功能的系统中，一个进程可能被多次换出，又多次被换入，每次换入后的位置通常是 不同的。在这种情况下，就应采用动态运行时装入的方式。 动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址 转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存 后的所有地址都仍是逻辑地址。为使地址转换不影响指令的执行速度，这种方式需要一个 重定位寄存器的支持，我们将在本章4.3节中做详细介绍。

4.2.2程序的链接 源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它 们所需要的库函数装配成一个完整的装入模块。在对目标模块进行链接时，根据进行链接 的时间不同，可把链接分成如下三种。

1.静态链接（StaticLinking）方式 在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块， 以后不再拆开。我们把这种事先进行链接的方式称为静态链接方式。我们通过一个例子来 说明在实现静态链接时应解决的一些问题。在图4-4(a)中示出了经过编译后所得到的三个 目标模块A、B、C，它们的长度分别为L、M和N。在模块A中有一条语句CALLB，用 124  第四章存储器管理 于调用模块B。在模块B中有一条语句CALLC，用于调用模块C。B和C都属于外部调 用符号，在将这几个目标模块装配成一个装入模块时，须解决以下两个问题：

（1）对相对地址进行修改。在由编译程序所产生的所有目标模块中，使用的都是相对 地址，其起始地址都为0，每个模块中的地址都是相对于起始地址计算的。在链接成一个 装入模块后，原模块B和C在装入模块的起始地址不再是0，而分别是L和L+M，所以 有相对地址都加上L+M。

（2）变换外部调用符号。将每个模块中所用的外部调用符号也都变换为相对地址，如 链接所形成的一个完整的装入模块，又称为可执行文件。通常都不再把它拆开，要运行时 可直接将它装入内存。把这种事先进行链接而以后不再拆开的链接方式称为静态链接方式。 模块A 模块A CALL B; JSR“L" L-1 Return; L- Return: 模块B 模块B CALL C; JSR“L+M" M-1 Return; L+M-1 Return; L+M 模块C 模块C ） L+M+N-1 Return; N-1 Return; (a)目标模块 (b)装入模块 图4-4程序链接示意图

2.装入时动态链接（Load-timeDynamicLinking） 接的链接方式。即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程 序去找出相应的外部目标模块，并将它装入内存，还要按照图4-4所示的方式修改目标模 块中的相对地址。装入时动态链接方式有以下优点：

(1）便于修改和更新。对于经静态链接装配在一起的装入模块，如果要修改或更新其 中的某个目标模块，则要求重新打开装入模块。这不仅是低效的，而且有时是不可能的。 若采用动态链接方式，由于各目标模块是分开存放的，所以要修改或更新各目标模块是件 非常容易的事。

(2）便于实现对目标模块的共享。在采用静态链接方式时，每个应用模块都必须含有 其目标模块的拷贝，无法实现对目标模块的共享。但采用装入时动态链接方式时，OS就很 容易将一个目标模块链接到几个应用模块上，实现多个应用程序对该模块的共享。

3.运行时动态链接（Run-timeDynamicLinking） 在许多情况下，应用程序在运行时，每次要运行的模块可能是不相同的。但由于事先 无法知道本次要运行哪些模块，故只能是将所有可能要运行到的模块全部都装入内存，并 在装入时全部链接在一起。显然这是低效的，因为往往会有部分目标模块根本就不运行。 125  计算机操作系统 比较典型的例子是作为错误处理用的目标模块，如果程序在整个运行过程中都不出现错误， 则显然就不会用到该模块。 近几年流行起来的运行时动态链接方式，是对上述装入时链接方式的一种改进。这种 链接方式是，将对某些模块的链接推迟到程序执行时才进行。亦即，在执行过程中，当发 现一个被调用模块尚未装入内存时，立即由OS去找到该模块，并将之装入内存，将其链 接到调用者模块上。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到 装入模块上，这样不仅能加快程序的装入过程，而且可节省大量的内存空间。

14.3连续分配存储管理方式 为了能将用户程序装入内存，必须为它分配一定大小的内存空间。连续分配方式是最 早出现的一种存储器分配方式，曾被广泛应用于上世纪60～80年代的OS中，该分配方式 为一个用户程序分配一个连续的内存空间，即程序中代码或数据的逻辑地址相邻，体现在 内存空间分配时物理地址的相邻。连续分配方式可分为四类：单一连续分配、固定分区分 配、动态分区分配以及动态可重定位分区分配算法四种方式。

4.3.1单一连续分配 一一← 在单道程序环境下，当时的存储器管理方式是把内存分为系统区和用户区两部分，系 统区仅提供给OS使用，它通常是放在内存的低址部分。而在用户区内存中，仅装有一道 用户程序，即整个内存的用户空间由该程序独占。这样的存储器分配方式被称为单一连续 分配方式。 虽然在早期的单用户、单任务操作系统中，有不少都配置了存储器保护机构，用于防 正用户程序对操作系统的破坏，但在20世纪80年代所产生的几种常见的单用户操作系统 中，如CP/M、MS-DOS及RT11等，并未采取存储器保护措施。这是因为，一方面可以节 省硬件，另一方面在单用户环境下，机器由一用户独占，不可能存在其他用户干扰的问题， 因此这是可行的。即使出现破坏行为，也仅仅会是用户程序自己破坏操作系统，其后果并不

4.3.2固定分区分配 一一→ 20世纪60年代出现的多道程序系统，如IBM360的MFT操作系统，为了能在内存中 装入多道程序，且使这些程序之间又不会发生相互干扰，于是将整个用户空间划分为若干 个固定大小的区域，在每个分区中只装入一道作业，这样就形成了最早的、也是最简单的 一种可运行多道程序的分区式存储管理方式。如果在内存中有四个用户分区，便允许四个 程序并发运行。当有一空闲分区时，便可以再从外存的后备作业队列中选择一个适当大 小的作业，装入该分区。当该作业结束时，又可再从后备作业队列中找出另一作业调入 该分区。

1.划分分区的方法 可用下述两种方法将内存的用户空间划分为若干个固定大小的分区： 126
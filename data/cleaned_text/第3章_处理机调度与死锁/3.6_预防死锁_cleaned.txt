计算机操作系统 该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

(3）不可抢占条件。进程已获得的资源在未使用完之前不能被抢占，只能在进程使用 完时由自己释放。

(4）循环等待条件。在发生死锁时，必然存在一个进程一资源的循环链，即进程集合 {Po,P1，P2，“，P}中的Po正在等待一个P占用的资源，P正在等待P2占用的资源，··， P正在等待已被Po占用的资源。

3.处理死锁的方法 目前处理死锁的方法可归结为四种：

(1）预防死锁。这是一种较简单和直观的事先预防方法。该方法是通过设置某些限制 条件，去破坏产生死锁四个必要条件中的一个或几个来预防产生死锁。预防死锁是一种较 易实现的方法，已被广泛使用。

（2）避免死锁。同样是属于事先预防策略，但它并不是事先采取各种限制措施，去破 坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法防止系统进入不 安全状态，从而可以避免发生死锁。

（3）检测死锁。这种方法无须事先采取任何限制性措施，允许进程在运行过程中发生 死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁 中解脱出来。

（4）解除死锁。当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态 中解脱出来。常用的方法是撤消一些进程，回收它们的资源，将它们分配给已处于阻塞状 态的进程，使其能继续运行。 上述的四种方法，从(1)到(4)对死锁的防范程度逐渐减弱，但对应的是资源利用率的提 高，以及进程因资源因素而阻塞的频度下降（即并发程度提高)。

3.6预防死锁 锁。由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破 坏产生死锁的后三个条件。

3.6.1破坏“请求和保持”条件 一一← 为了能破坏“请求和保持”条件，系统必须保证做到：当一个进程在请求资源时，它 不能持有不可抢占资源。该保证可通过如下两个不同的协议实现：

1.第一种协议 该协议规定，所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需 的全部资源。此时若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给它。 这样，该进程在整个运行期间，便不会再提出资源要求，从而破坏了“请求”条件。系统 在分配资源时，只要有一种资源不能满足进程的要求，即使其它所需的各资源都空闲也不 分配给该进程，而让该进程等待。由于该进程在等待期间未占有任何资源，于是破坏了“保 108  第三章处理机调度与死锁 持”条件，从而可以预防死锁的发生。 第一种协议的优点是简单、易行且安全。但缺点也极其明显：

（1）资源被严重浪费，严重地恶化了资源的利用率。进程在开始运行时就一次性地占 用了整个运行过程所需的全部资源，其中有些资源可能仅在运行初期或运行快结束时才使 用，甚至根本不使用。

（2）使进程经常会发生饥饿现象。因为仅当进程在获得了其所需的全部资源后才能开 始运行，这样就可能由于个别资源长期被其它进程占用，而致使等待该资源的进程迟迟不 能开始运行，而个别资源有可能仅在进程运行到最后才需要，如打印机往往就是如此。

2.第二种协议 该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开 始运行。进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求 新的所需资源。我们可以通过一个具体例子来说明，第二种协议比第一种协议要好。例如 有一个进程，它所要完成的任务是，先将数据从磁带上复制到磁盘文件上，然后对磁盘文 件进行排序，最后把结果打印出来。在采用第一种协议时，进程必须在开始时就请求磁带 机、磁盘文件和打印机。然而打印机仅在最后才会用到，既影响到其利用率，还会影响到 其它进程的运行。此外，又如磁带机和磁盘文件虽然空闲，但因打印机已分配给其它进程， 因而进程还需要等待。 在采用第二种协议时，进程在开始时只需请求磁带机、磁盘文件，然后就可运行。等 到全部磁带上的数据已复制到磁盘文件中并已排序好后，便可将磁带机和磁盘文件释放掉， 再去请求磁盘文件和打印机。这不仅能使进程更快地完成任务，提高设备的利用率，还可 减少进程发生饥饿的机率。

3.6.2破坏“不可抢占”条件 一一一一→ 为了能破坏“不可抢占”条件，协议中规定，当一个已经保持了某些不可被抢占资源 的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后 需要时再重新申请。这意味着进程已占有的资源会被暂时地释放，或者说是被抢占了，从 而破坏了“不可抢占”条件。 该方法实现起来比较复杂，且需付出很大的代价。因为一个不可抢占的资源如打印机、 CD刻录机等在使用一段时间后被抢占，可能会造成进程前一阶段工作的失效，即使是采取 了某些防范措施，也还会使进程前后两次运行的信息不连续。这种策略还可能因为反复地 申请和释放资源致使进程的执行被无限地推迟，这不仅延长了进程的周转时间，而且也增 加了系统开销，降低了系统吞吐量。

3.6.3破坏“循环等待”条件 并赋予不同的序号。设R=(R，R2,R3，，Rm)为资源类型的集合，为每个资源类型赋予唯一 的序号。如果系统中有磁带驱动器、硬盘驱动器、打印机，则函数F可按如下形式来定义： F(tape drive) = 1; 109  计算机操作系统 F(disk drive) = 5; F(printer) =12; 在对系统所有资源类型进行线性排序后，便可采用这样的预防协议：规定每个进程必 须按序号递增的顺序请求资源。一个进程在开始时，可以请求某类资源R；的单元。以后， 当且仅当F(R)>F(R;)时，进程才可以请求资源R的单元。如果需要多个同类资源单元， 则必须一起请求。例如，当某进程需要同时使用打印机和磁带机时，由于磁带机序号低， 而打印机序号高，故必须先请求磁带机，再请求打印机。假如某进程已请求到一些序号较 高的资源，后来它又想请求一个序号低的资源时，它必须先释放所有具有相同和更高序号 的资源后，才能申请序号低的资源。在采用这种策略后所形成的资源分配图中，不可能再 出现环路，因而破坏了“循环等待”条件。事实上，总有一个进程占据了较高序号的资源， 此后它继续申请的资源必然是空闲的，因而进程可以一直向前推进。 在采用这种策略时，应如何来规定每种资源的序号是十分重要的。通常应根据大多数 进程需要资源的先后顺序来确定。一般情况下，进程总是先输入程序和数据，继而进行运 算，最后将计算结果输出。故可以为输入设备规定较低的序号，如前面是将磁带机定为1； 为输出设备规定较高的序号，如把打印机定为12。 善。但也存在下述问题：首先，为系统中各类资源所规定的序号必须相对稳定，这就限制 了新类型设备的增加：其次，尽管在为资源的类型分配序号时，已经考虑到大多数作业在 定的顺序不同，造成对资源的浪费。第三，为方便用户，系统对用户在编程时所施加的限制 条件应尽量少，然而这种按规定次序申请资源的方法必然会限制用户简单、自主地编程，

13.7避免死锁 避免死锁同样是属于事先预防的策略，但并不是事先采取某种限制措施，破坏产生死 锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。 这种方法所施加的限制条件较弱，可能获得较好的系统性能，目前常用此方法来避免发生 死锁。

3.7.1系统安全状态 在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态 时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。

1.安全状态 在该方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次 否则，令进程等待。所谓安全状态，是指系统能按某种进程推进顺序（P，P2，“，P)为每个 进程P;分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完 成。此时称(P1，P2，“，P)为安全序列。如果系统无法找到这样一个安全序列，则称系统处 110
理机分配的公平性。如果在系统中有n个相同类型的进程同时运行，为公平起见，须保证每 个进程都获得相同的处理机时间1/n。在实施公平调度算法时系统中必须具有这样一些功能：

（1）跟踪计算每个进程自创建以来已经执行的处理时间。

(2）计算每个进程应获得的处理机时间，即自创建以来的时间除以n。

(3）计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机 时间之比。

（4）比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比 率为0.8，进程C的比率为1.2等。

(5）调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到 超过最接近它的进程比率为止。

2.公平分享调度算法 分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公 平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。假如系统中仅 有两个用户，用户1启动了4个进程，用户2只启动1个进程，采用轮转法让每个进程轮 流运行一个时间片时间，对进程而言很公平，但用户1和用户2得到的处理机时间分别为 80%和20%，显然对用户2而言就有失公平。在该调度算法中，调度的公平性主要是针对 用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。然而调度又是以 进程为基本单位，为此，必须考虑到每一个用户所拥有的进程数目。例如系统中有两个用 同的处理机时间，则必须执行如下所示的强制调度序列： AEBECEDEAEBECEDE. 如果希望用户1所获得的处理机时间是用户2的两倍，则必须执行如下所示的强制调 度序列： ABECDEABECDEABECDE.

3.4实时调度 在实时系统中，可能存在着两类不同性质的实时任务，即HRT 任务和SRT 任务，它 们都联系着一个截止时间。为保证系统能正常工作，实时调度必须能满足实时任务对截止 时间的要求。为此，实现实时调度应具备一定的条件。

3.4.1：实现实时调度的基本条件

1.提供必要的信息 为了实现实时调度，系统应向调度程序提供有关任务的信息：

(1）就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事 先预知的一串时间序列。

(2）开始截止时间和完成截止时间，对于典型的实时应用，只须知道开始截止时间， 或者完成截止时间。 97  计算机操作系统

(3）处理时间，一个任务从开始执行，直至完成时所需的时间。

（4）资源要求，任务执行时所需的一组资源。

(5）优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝 对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予 “相对”优先级，供调度程序参考。

2.系统处理能力强 在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些 实时任务不能得到及时处理，从而导致发生难以预料的后果。假定系统中有m个周期性的 硬实时任务HRT，它们的处理时间可表示为C，周期时间表示为P，则在单处理机情况下， 必须满足下面的限制条件系统才是可调度的： P 顺便说明一下，上述的限制条件并未考虑到任务切换所花费的时间，因此，当利用上 述限制条件时，还应适当地留有余地。 提高系统处理能力的途径有二：一是采用单处理机系统，但须增强其处理能力，以显 著地减少对每一个任务的处理时间；二是采用多处理机系统。假定系统中的处理机数为N， 则应将上述的限制条件改为： ≤N

3.采用抢占式调度机制 在含有HRT任务的实时系统中，广泛采用抢占机制。这样便可满足HRT任务对截止 时间的要求。但这种调度机制比较复杂。对于一些小的实时系统，如果能预知任务的开始 截止时间，则对实时任务的调度可采用非抢占调度机制，以简化调度程序和在任务调度时 所花费的系统开销。在设计这种调度机制时，应使所有的实时任务都比较小，并在执行完 关键性程序和临界区后，能及时地将自已阻塞起来，以便释放出处理机，供调度程序去调 度那个开始截止时间即将到达的任务。

4.具有快速切换机制 为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的 快速切换。该机制应具有如下两方面的能力：

（1）对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有 快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机(其它紧迫任务）。

（2）快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的 每个运行功能单位适当的小，以减少任务切换的时间开销。

3.4.2实时调度算法的分类 可以按不同方式对实时调度算法加以分类：①根据实时任务性质，可将实时调度的算 98  第三章处理机调度与死锁 法分为硬实时调度算法和软实时调度算法；②按调度方式，则可分为非抢占调度算法和抢 占调度算法。

1.非抢占式调度算法

（1）非抢占式轮转调度算法。由一台计算机控制若干个相同的（或类似的）对象，为每一 个被控对象建立一个实时任务，并将它们排成一个轮转队列。调度程序每次选择队列中的 第一个任务投入运行。当该任务完成后，便把它挂在轮转队列的末尾等待，调度程序再选 择下一个队首任务运行。这种调度算法可获得数秒至数十秒的响应时间，可用于要求不太 严格的实时控制系统中。

（2）非抢占式优先调度算法。如果在系统中还含有少数具有一定要求的实时任务，则 可采用非抢占式优先调度算法，系统为这些任务赋予了较高的优先级。当这些实时任务到 达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后，便可去调度 秒至数百毫秒，因而可用于有一定要求的实时控制系统中。

2.抢占式调度算法 可根据抢占发生时间的不同而进一步分成以下两种调度算法：

（1）基于时钟中断的抢占式优先级调度算法。在某实时任务到达后，如果它的优先级 高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时， 调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。该算法能获得较 好的响应效果，其调度延迟可降为几十至几毫秒，可用于大多数的实时系统中。

(2）立即抢占（ImmediatePreemption）的优先级调度算法。在这种调度策略中，要求操作 系统具有快速响应外部事件中断的能力。一旦出现外部中断，只要当前任务未处于临界区， 便能立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。这种算法能获得非 常快的响应，可把调度延迟降低到几毫秒至100微秒，甚至更低。图3-5中的(a)、(b)、(c)、 （d)分别示出了四种情况的调度时间。 实时进程请求调度 调度实时进程运行 实时进程请求调度 时钟中断到来时 进程1 进程2 进程n 实时进程 当前进程 实时进程 调度时间 调度时间 (c)基于时钟中断抢占的优先权抢占调度 (a)非抢占轮转调度 实时进程请求调度 当前进程运行完成 实时进程请求调度 实时进程抢占当前 进程，并立即执行 当前进程 实时进程 当前进程 实时进程 调度时间 调度时间 (b)非抢占优先权调度 (d)立即抢占的优先权调度 图3-5：实时进程调度

3.4.3最早截止时间优先EDF(EarliestDeadlineFirst)算法 该算法是根据任务的截止时间确定任务的优先级，任务的截止时间愈早，其优先级愈 99  计算机操作系统 高，具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是选择就绪队 列中的第一个任务，为之分配处理机。最早截止时间优先算法既可用于抢占式调度方式中， 也可用于非抢占式调度方式中。

1.非抢占式调度方式用于非周期实时任务 图3-6示出了将该算法用于非抢占调度方式之例。该例中具有四个非周期任务，它们 先后到达。系统先调度任务1执行，在任务1执行期间，任务2、3又先后到达。由于任务 3的开始截止时间早于任务2的，故系统在任务1后将先调度任务3执行。在此期间又到 达作业4，其开始截止时间仍是早于任务2的，故在任务3执行完后，系统又先调度任务4 执行，最后才调度任务2执行。 开始截止时间 3 任务执行 1 3 4 2 任务到达 2 4 图3-6EDF算法用于非抢占调度方式

2.抢占式调度方式用于周期实时任务 图3-7示出了将该算法用于抢占调度方式之例。在该例中有两个周期任务，任务A和 任务B的周期时间分别为20ms和50ms，每个周期的处理时间分别为10ms和25ms。 BI B 截止时间 截止时间 Ai A2 A3 A4 As 截止时间 截止时间 截止时间 截止时间 截止时间 到达时间、执行时间和 A2 A. AG A A 最后截止时间 B B2 时间/ms 10 20 30 40 50 60 70 80 90 100 固定优先级调度 B B B2 A B2 As B2 A Ai A2 B A3 A4 A5，B2 (错过) A 固定优先级调度 B B2 ★ A A2 B A3 A4 AsB2 (错过) (错过) 使用完成截止时间最早和 B A B AB2A4 A B2 As 最后截止时间调度 T A A2 B A3 A4 As,B2 图3-7最早截止时间优先算法用于抢占调度方式之例 100  第三章处理机调度与死锁 图3-7示出了将最早截止时间（最后期限）优先算法用于抢占调度的示意图。图中的第一行 示出了两个任务的到达时间、截止时间和执行时间图。其中任务A的到达时间为0、20ms、 40ms，任务A的最后期限为20ms、40ms、60ms，任务B的到达时间为0、50ms、 100ms"，任务B的最后期限为50ms、100ms"。 为了说明通常的优先级调度不能适用于实时系统，该图特增加了第二和第三行。在第 二行中，假定任务A具有较高的优先级，所以在t=Oms时，先调度A执行，在Ai完成 后（t=10ms)才调度B执行。在t=20ms时，又重新调度A2执行，在t=30ms时，A2完 成，又调度B执行。在t=40ms时，又调度A3执行，在t=50ms时，虽然A3已完成， 但B，已错过了它的最后期限。这说明利用通常的优先级调度已经失败。第三行与第二行类 似，只是假定任务B具有较高的优先级。 第四行是采用最早截止时间优先算法的时间图。在t=0时，Ai和B同时到达，由于 A的截止时间比B早，故调度A执行。在t=10时，A完成又调度B执行。在t=20时， A2到达，由于A2的截止时间比B2早，B被中断而调度A2执行。在t=30时，A2完成， 又重新调度B执行。在t=40时，A3又到达，但B的截止时间要比A3早，仍应让B继 续执行直到完成（t=45)，然后再调度A3执行。在t=55时，A3完成又调度B2执行。在该 例中，利用最早截止时间优先算法可以满足系统的要求。

3.4.4最低松弛度优先LLF(LeastLaxityFirst)算法 该算法在确定任务的优先级时，根据的是任务的紧急（或松弛）程度。任务紧急程度愈 高，赋予该任务的优先级就愈高，以使之优先执行。例如，一个任务在200ms时必须完成， 而它本身所需的运行时间是100ms，因此调度程序必须在100ms之前调度执行，该任务 的紧急程度（松弛程度）为100ms。又如另一任务在400ms时必须完成，它本身需要运行 150ms，则其松弛程度为250ms。在实现该算法时要求系统中有一个按松弛度排序的实时 任务就绪队列，松弛度最低的任务排在最前面，调度程序选择队列中的队首任务执行。 该算法主要用于可抢占调度方式中。假如在一个实时系统中有两个周期性实时任务A 和B，任务A要求每20ms执行一次，执行时间为10ms，任务B要求每50ms执行一次， 执行时间为25ms。由此可知，任务A和B每次必须完成的时间分别为：A1、A2、A3、 和B1、B2、B3、，见图3-8。为保证不遗漏任何一次截止时间，应采用最低松弛度优先 的抢占调度策略。 A 40 20 60 80 100 120 140 160 B B2 B 图3-8A和B任务每次必须完成的时间 在刚开始时(t=0)，A必须在20ms时完成，而它本身运行又需10ms，可算出A的 松弛度为10ms。B必须在50ms时完成，而它本身运行就需25ms，可算出B的松弛度 101  计算机操作系统 为25ms，故调度程序应先调度Ai执行。在tz=10ms时，A2的松弛度可按下式算出： A2的松弛度=必须完成时间－其本身的运行时间－当前时间 = 40 ms - 10ms - 10 ms = 20 ms 类似地，可算出B的松弛度为15ms，故调度程序应选择B运行。在t=30ms时， A2的松弛度已减为0（即40-10-30)，而B的松弛度为15ms（即50-5-30)，于是调度 程序应抢占B的处理机而调度A2运行。在t4=40ms时，A的松弛度为10ms（即60－10-40)， 而B的松弛度仅为5ms（即50-5-40)，故又应重新调度B执行。在t5s=45ms时，B 执行完成，而此时A3的松弛度已减为5ms（即60－10-45），而B2的松弛度为30ms（即 100-25-45），于是又应调度A3执行。在t6=55ms时，任务A尚未进入第4周期，而任 务B已进入第2周期，故再调度B2执行。在t=70ms时，A4的松弛度已减至0ms（即 80－10-70)，而B2的松弛度为20ms（即100-10-70)，故此时调度程序又应抢占B2的 处理机而调度A4执行。图3-9示出了具有两个周期性实时任务的调度情况。 A;(10) A2(10) A3(10) A4(10) 20 60 50 70 80 0 B,(20) B(5) B2(15) B2(10) 图3-9利用ELLF算法进行调度的情况

3.4.5优先级倒置（priorityinversionproblem）

1.优先级倒置的形成 当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的 延迟或阻塞。我们通过一个例子来说明该问题。假如有三个完全独立的进程P1、P2和P3， P的优先级最高，P2次之，P3最低。P和P通过共享的一个临界资源进行交互。下面是一 段代码： P:...P(mutex);CS-1; V(mutex);... P2:... program2... P3:...P(mutex); CS-3; V(mutex);... 假如P最先执行，在执行了P(mutex）操作后，进入到临界区CS-3。在时刻a，P2就绪， 因为它比P3的优先级高，P2抢占了P3的处理机而运行，如图3-10所示。在时刻b，P就 绪，因为它又比P2的优先级高，P抢占了P2的处理机而运行。在时刻c，P执行P(mutex) 操作，试图进入临界区CS-1，但因为相应的临界资源已被P3占用，故P将被阻塞。由P2 继续运行，直到时刻d运行结束。然后由P接着运行，到时刻e时P3退出临界区，并唤醒 P1。因为它比P3的优先级高，故它抢占了P3的处理机而运行。 根据优先级原则，高优先级进程应当能优先执行，但在此例中，P和P3共享着“临界 102  第三章处理机调度与死锁 存在而延长了P被阻塞的时间，而且被延长的时间是不可预知和无法限定的。由此所产生 阻塞在 进入 P(mutex) CS-1 P 抢占 抢占 P2 b P结束 抢占 P3 d 进入 离开CS-3 CS-3 V(mutex) P(mutex) 图3-10优先级倒置示意图

2.优先级倒置的解决方法 一种简单的解决方法是规定：假如进程P3在进入临界区后P3所占用的处理机就不允许 被抢占。由图3-10可以看出，P2即使优先级高于P3也不能执行。于是P3就有可能会较快 地退出临界区，不会出现上述情况。如果系统中的临界区都较短且不多，该方法是可行的。 反之，如果P临界区非常长，则高优先级进程P仍会等待很长的时间，其效果是无法令人 满意的。 一个比较实用的方法是建立在动态优先级继承基础上的。该方法规定，当高优先级进 程P要进入临界区，去使用临界资源R，如果已有一个低优先级进程P3正在使用该资源， 此时一方面P被阻塞，另一方面由P继承P的优先级，并一直保持到P退出临界区。这 样做的目的在于不让比P优先级稍高，但比P优先级低的进程如P2进程插进来，导致延 缓P退出临界区。图3-11示出了采用动态优先级继承方法后，P、P2、P三个进程的运行 情况。由图可以看出，在时刻c，P被阻塞，但由于P3已继承了P的优先级，它比P2优 先级高，这样就避免了P2的插入，使P在时刻d进入临界区。该方法已在一些操作系统中 得到应用，而在实时操作系统中是必须的。 阻塞在 进入 P(mutex) CS-1 P结束 P, P2 b P3 c 进入 离开CS-3 CS-3 继承 V(mutex) P(mutex) 图3-11 采用了动态优先级继承方法的运行情况 103  计算机操作系统

3.5死锁概述 在第二章中，我们已经涉及到死锁的概念。例如，系统中只有一台扫描仪R和一台刻 录机R2。有两个进程P和P2，它们都准备将扫描的文挡刻录到CD光盘上，进程Pi先请 求扫描仪R并获得成功，进程P2先请求CD刻录机R2也获得成功。后来P又请求CD刻 录机，因它已被分配给了P2而阻塞。P2又请求扫描仪，也因被分配给了P而阻塞，此时 两个进程都被阻塞，双方都希望对方能释放出自己所需要的资源，但它们谁都因不能获得 自己所需的资源去继续运行，从而无法释放出自己占有的资源，并且一直处于这样的僵持 状态而形成死锁。又如，在第二章的哲学家进餐问题中，如果每一个哲学家因饥饿都拿起 了他们左边的筷子，当每一个哲学家又试图去拿起他们右边的筷子时，将会因无筷子可拿 而无限期地等待，从而产生死锁问题。在本章的后半部分，我们将对死锁发生的原因、如 何预防和避免死锁等问题作较详细的介绍。

3.5.1资源问题 在系统中有许多不同类型的资源，其中可以引起死锁的主要是，需要采用互斥访问方 法的、不可以被抢占的资源，即在前面介绍的临界资源。系统中这类资源有很多，如打印 机、数据文件、队列、信号量等。

1.可重用性资源和消耗性资源 1）可重用性资源 可重用性资源是一种可供用户重复使用多次的资源，它具有如下性质：

（1）每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。

（2）进程在使用可重用性资源时，须按照这样的顺序：①请求资源。如果请求资源失 败，请求进程将会被阻塞或循环等待。②使用资源。进程对资源进行操作，如用打印机进 行打印；③释放资源。当进程使用完后自己释放资源。

（3）系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能 创建也不能删除它。 对资源的请求和释放通常都是利用系统调用来实现的，例如对于设备，一般用 request/release；对于文件，可用open/close。对于需要互斥访问的资源，进程可以用信号量 的wait/signal操作来完成。进程在每次提出资源请求后，系统在执行时都需要做一系列的 工作。计算机系统中大多数资源都属于可重用性资源。 2）可消耗性资源 可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的， 它具有如下性质：①每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的， 有时它可以有许多，有时可能为0；②进程在运行过程中，可以不断地创造可消耗性资源 的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目。③进程在运行过 程中，可以请求若干个可消耗性资源单元，用于进程自已的消耗，不再将它们返回给该资 104
计算机操作系统F(disk drive) = 5;F(printer) =12;在对系统所有资源类型进行线性排序后，便可采用这样的预防协议：规定每个进程必须按序号递增的顺序请求资源。一个进程在开始时，可以请求某类资源R；的单元。以后，当且仅当F(R)>F(R;)时，进程才可以请求资源R的单元。如果需要多个同类资源单元，则必须一起请求。例如，当某进程需要同时使用打印机和磁带机时，由于磁带机序号低，而打印机序号高，故必须先请求磁带机，再请求打印机。假如某进程已请求到一些序号较高的资源，后来它又想请求一个序号低的资源时，它必须先释放所有具有相同和更高序号的资源后，才能申请序号低的资源。在采用这种策略后所形成的资源分配图中，不可能再出现环路，因而破坏了“循环等待”条件。事实上，总有一个进程占据了较高序号的资源，此后它继续申请的资源必然是空闲的，因而进程可以一直向前推进。
在采用这种策略时，应如何来规定每种资源的序号是十分重要的。通常应根据大多数进程需要资源的先后顺序来确定。一般情况下，进程总是先输入程序和数据，继而进行运算，最后将计算结果输出。故可以为输入设备规定较低的序号，如前面是将磁带机定为1；
为输出设备规定较高的序号，如把打印机定为12。
善。但也存在下述问题：首先，为系统中各类资源所规定的序号必须相对稳定，这就限制了新类型设备的增加：其次，尽管在为资源的类型分配序号时，已经考虑到大多数作业在定的顺序不同，造成对资源的浪费。第三，为方便用户，系统对用户在编程时所施加的限制条件应尽量少，然而这种按规定次序申请资源的方法必然会限制用户简单、自主地编程，13.7避免死锁避免死锁同样是属于事先预防的策略，但并不是事先采取某种限制措施，破坏产生死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。
这种方法所施加的限制条件较弱，可能获得较好的系统性能，目前常用此方法来避免发生死锁。
3.7.1系统安全状态在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。
1.安全状态在该方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次否则，令进程等待。所谓安全状态，是指系统能按某种进程推进顺序（P，P2，“，P)为每个进程P;分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时称(P1，P2，“，P)为安全序列。如果系统无法找到这样一个安全序列，则称系统处110第三章处理机调度与死锁于不安全状态。虽然并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，就有可能进入死锁状态。反之，只要系统处于安全状态，系统便不会进入死锁状态。
因此，避免死锁的实质在于，系统在进行资源分配时，应使系统不进入不安全状态。
2.安全状态之例假定系统中有三个进程P、P2和P3，共有12台磁带机。进程P总共要求10台磁带机，P2和P3分别要求4台和9台。假设在T时刻，进程P、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，如下表所示：
进程-最大需求已分配可用P1053P242P392经分析发现，在To时刻系统是安全的，因为这时存在一个安全序列（P2，P1，P3)，即只要系统按此进程序列分配资源，就能使每个进程都顺利完成。例如将剩余的磁带机取2台分配给P2，使之继续运行，待P2完成便可释放出4台磁带机，于是可用资源增至5台；
以后再将这些全部分配给进程P1，使之运行，待P完成后，将释放出10台磁带机，P3便能获得足够的资源，从而使P、P2、P3每个进程都能顺利完成。
3.由安全状态向不安全状态的转换如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如在To时刻以后P又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入不安全状态。因为此时也无法再找到一个安全序列。例如把其余的2台分配给P2，这样在P2完成后，只能释放出4台，既不能满足P尚需5台的要求，也不能满足P3需要6台的要求，致使它们都无法推进到完成，彼此都在等待对方释放资源，结果导致死锁。类似地，如果我们将剩余的2台磁带机先分配给P或P3，也同样都无法使它们推进到完成，因此从给P分配了第3台磁带机开始，系统便又进入了不安全状态。
在建立了系统安全状态的概念后，便可知道避免死锁的基本思想，就是确保系统始终处于安全状态。一个系统开始是处于安全状态的。当有进程请求一个可用资源时，系统需对该进程的请求进行计算，若将资源分配给进程后系统仍处于安全状态，才将该资源分配给进程。在上面的例子中，在P请求1台磁带机时，尽管系统中有可用的磁带机，但却不能分配给它。必须等待到P和P2完成并释放出资源后再将足够的资源分配给P3。
3.7.2利用银行家算法避免死锁最有代表性的避免死锁的算法是Dijkstra的银行家算法。起这样的名字是由于该算法原本是为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。在OS中也可用它来实现避免死锁。
为实现银行家算法，每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，111计算机操作系统否则让进程等待。
1.银行家算法中的数据结构为了实现银行家算法，在系统中必须设置这样四个数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。
随该类资源的分配和回收而动态地改变。如果Available[j]=K，则表示系统中现有R;类资源K个。
(2）最大需求矩阵Max。这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rg类资源的最大数目为K。
（3）分配矩阵Allocation。这也是一个n×m的矩阵，它定义了系统中每一类资源当前的数目为K。
（4）需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rg类资源K个方能完成其任务。
上述三个矩阵间存在下述关系：
Need[i, j] = Max[i, j] - Allocation[i, j]2.银行家算法设Request是进程P的请求向量，如果Request;[j]=K，表示进程P需要K个R类型的资源。当P发出资源请求后，系统按下述步骤进行检查：
(1）如果Request;[j]≤Need[i，j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。
(2）如果Request;[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。
(3）系统试探着把资源分配给进程P，并修改下面数据结构中的数值：
Available[j] =Available[j] -Request;[j];Allocation[i, j] = Allocation[i, j] + Request;[j];Need[i, j] = Need[i, j] - Request;[j];(4）系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程P，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程P等待。
3.安全性算法系统所执行的安全性算法可描述如下：
（1）设置两个向量：①工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work：=Available；②Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]：=false；当有112第三章处理机调度与死锁足够资源分配给进程时，再令Finish[i]：=true。
(2）从进程集合中找到一个能满足下述条件的进程：
① Finish[i]=false;② Need[i, j]≤Work[j];若找到，执行步骤(3)，否则，执行步骤(4)。
(3）当进程P获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：
Work[j] =Work[j]+Allocation[i,j];Finish[i] =true;go to step 2;(4）如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。
4.银行家算法之例假定系统中有五个进程{Po,P，P2,P3,P4}和三类资源{A，B,C}，各种资源的数量分别为10、5、7，在T时刻的资源分配情况如图3-15所示。
资源MaxAllocationNeedAvailable情况ABCABCABCABC进程Po753010743332(230)P322200122(302)(020)P2902302600P3222211011P4433002431图3-15T时刻的资源分配表(1）To时刻的安全性：利用安全性算法对To时刻的资源分配情况进行分析(如图3-16所示)可知，在To时刻存在着一个安全序列{P1,P3,P4,P2,Po}，故系统是安全的。
资源MaxNeedAllocationWork+Allocation情况FinishABCABCABCABC进程P332122200532trueP3532011741213trueP4743431002745trueP27456003021047true104010Po7430177true图3-16To时刻的安全序列113计算机操作系统(2）P请求资源：P发出请求向量Request(1,0,2)，系统按银行家算法进行检查：
① Request;(1, 0, 2)≤Need(1, 2, 2);② Request;(1, 0, 2)≤Available;(3, 3, 2);③系统先假定可为P分配资源，并修改Available，Allocation和Need向量，由此形成的资源变化情况如图3-15中的圆括号所示；
④再利用安全性算法检查此时系统是否安全，如图3-17所示。
资源WorkNeedAllocationWork+Allocation情况FinishABCABCABCABC进程P2302030232trueP3532011211743trueP474331002745truePo745743010755trueP2755600321057true0图3-17P申请资源时的安全性检查由所进行的安全性检查得知，可以找到一个安全序列{P，P3，P4，P2，Po}。因此，系统是安全的，可以立即将P所申请的资源分配给它。
① Request4(3, 3, 0)≤Need4(4, 3, 1);②Request4(3，3，0)>Available(2，3，0)，让P4等待。
(4）Po请求资源：Po发出请求向量Requesto(0，2，O)，系统按银行家算法进行检查：
① Requesto(0, 2,0)≤Needo(7, 4, 3);② Requesto(0, 2,0)≤Available(2, 3,0);③系统暂时先假定可为Po分配资源，并修改有关数据，如图3-18所示。
资源AllocationNeedAvailable情况ABCABCABC进程Po030723210P302020P23026001P3201100243P41图3-18为Po分配资源后的有关资源数据(5）进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。
如果在银行家算法中把Po发出的请求向量改为Requesto(O，1，0)，系统是否能将资源分配给它，请读者考虑。
114
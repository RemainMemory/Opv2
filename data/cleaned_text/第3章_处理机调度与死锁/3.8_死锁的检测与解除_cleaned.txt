第三章处理机调度与死锁 /3.8死锁的检测与解除 如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，系统很可能会发生 死锁。在这种情况下，系统应当提供两个算法： ①死锁检测算法。该方法用于检测系统状态，以确定系统中是否发生了死锁。 ②死锁解除算法。当认定系统中已发生了死锁，利用该算法可将系统从死锁状态中解 脱出来。

3.8.1死锁的检测 1 为了能对系统中是否已发生了死锁进行检测，在系统中必须：①保存有关资源的请求 和分配信息；②提供一种算法，它利用这些信息来检测系统是否已进入死锁状态。

1.资源分配图（ResourceAllocationGraph) 系统死锁，可利用资源分配图来描述。该图是由一组结点N和一组边E所组成的一个 对偶G=(N,E)，它具有下述形式的定义和限制：

(1）把N分为两个互斥的子集，即一组进程结点P={P，P2，“,Pn}和一组资源结点 R={R,R2，",Rn}，N=PUR。在图3-19所示的例子中，P={P,P2}，R={R,R2}， N={R,R2}U{P1,P2}。 是资源请求边，由进程P指向资源R，它表示进程P;请求一个单位的R;资源。E={R，P} 是资源分配边，由资源R指向进程P，它表示把一个单位的资源R分配给进程P。图3-19 中示出了两个请求边和两个分配边，即E={(P1,R2),(R2,P2),(P2,R1),(R,P1)}。 (P R2O O O 图3-19每类资源有多个时的情况 我们用圆圈代表一个进程，用方框代表一类资源。由于一种类型的资源可能有多个， 我们用方框中的一个点代表一类资源中的一个资源。此时，请求边是由进程指向方框中的 R，而分配边则应始于方框中的一个点。图3-20示出了一个资源分配图。图中，P进程已 又请求R资源。 115  计算机操作系统

2.死锁定理 我们可以利用把资源分配图加以简化的方法（图3-19)，来检测当系统处于S状态时， 是否为死锁状态。简化方法如下：

(1）在资源分配图中，找出一个既不阻塞又非独立的进程结点P。在顺利的情况下， P;可获得所需资源而继续运行，直至运行完毕，再释放其所占有的全部资源，这相当于消 去P;的请求边和分配边，使之成为孤立的结点。在图3-20(a)中，将P的两个分配边和一 个请求边消去，便形成图（b)所示的情况。 ? P OOR R00 R2OO ROO P2 (P2 (a) (b) (c) 图3-20资源分配图的简化

（2）P释放资源后，便可使P2获得资源而继续运行，直至P2完成后又释放出它所占有 的全部资源，形成图（c)所示的情况，即将P2的两条请求边和一条分配边消去。

(3）在进行一系列的简化后，若能消去图中所有的边，使所有的进程结点都成为孤立 结点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可 完全简化的。 对于较复杂的资源分配图，可能有多个既未阻塞又非孤立的进程结点。不同的简化顺 序，是否会得到不同的简化图？有关文献已经证明，所有的简化顺序都将得到相同的不可 简化图。同样可以证明：S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不 可完全简化的。该充分条件被称为死锁定理。

3.死锁检测中的数据结构 死锁检测中的数据结构类似于银行家算法中的数据结构：

(1）可利用资源向量Available，它表示了m类资源中每一类资源的可用数目。

(2）把不占用资源的进程（向量Allocation=O)记入L表中，即L;UL。 简化，释放出资源，增加工作向量Work=Work+Allocationi。②将它记入L表中。

（4）若不能把所有进程都记入L表中，便表明系统状态S的资源分配图是不可完全简 化的。因此，该系统状态将发生死锁。 Work=Available; L=-{L,lAllocation =OnRequest;=O} for (all Li L) 116  第三章处理机调度与死锁 for(all Request ;≤Work){ Work=Work + Allocation 1; L,UL; } deadlock=(L={P1,P2,"，Pn});

3.8.2死锁的解除 如果利用死锁检测算法检测出在系统中已发生了死锁，则应立即采取相应的措施，以 解除死锁。最简单的处理措施就是立即通知操作员，请操作员来以人工方法处理死锁。另 一种措施则是利用死锁解除算法，把系统从死锁状态中解脱出来。常采用解除死锁的两种 方法是： 死锁状态。

(2）终止(或撤消)进程。终止(或撤消)系统中的一个或多个死锁进程，直至打破循环环 路，使系统从死锁状态解脱出来。

1.终止进程的方法 1）终止所有死锁进程 这是一种最简单的方法，即是终止所有的死锁进程，死锁自然也就解除了，但所付出 的代价可能会很大。因为其中有些进程可能已经运行了很长时间，已接近结束，一旦被终 止真可谓“功亏一”，以后还得从头再来。还可能会有其它方面的代价，在此不再一一 列举。 2）逐个终止进程 稍微温和的方法是，按照某种顺序，逐个地终止进程，直至有足够的资源，以打破循 环等待，把系统从死锁状态解脱出来为止。但该方法所付出的代价也可能很大。因为每终 止一个进程，都需要用死锁检测算法确定系统死锁是否已经被解除，若未解除还需再终止 止的进程。选择策略最主要的依据是，为死锁解除所付出的“代价最小”。但怎么样才算是 “代价最小”，很难有一个精确的度量。我们在此仅提供在选择被终止进程时应考虑的若干 因素：

(1）进程的优先级的大小;

(2）进程已执行了多少时间，还需要多少时间方能完成？

(3）进程在运行中已经使用资源的多少，以后还需要多少资源？

(4）进程的性质是交互式的还是批处理式的？

2.付出代价最小的死锁解除算法 一种付出代价最小的死锁解除算法如图3-21所示。假定在死锁状态时，已有死锁进程 P，P2，“，Pk。首先终止进程P，使系统状态由S→U1，付出的代价为Cu1，然后，仍然从 S状态中终止进程P2，使状态由S→U2，其代价为Cu2，，如此下去可得到状态U1,U2，“， 117  计算机操作系统 Un。若此时系统仍处于死锁状态，需再进一步终止进程，如此下去，直至解除死锁状态为 止。可见，如果在每一层中找到了所有终止代价最小的进程后，此时通过终止进程以解除 死锁的代价最小。但是，这种方法为了找到这些进程可能付出的代价将是k(k-1)(k-2)·/2C。 显然，所花费的代价很大，因此，这是一种很不实际的方法。 Cs P(Cu,) P(Cu) P(Cu) P 图3-21付出代价最小的死锁解除算法 一个比较有效的方法是对死锁状态S做如下处理：从死锁状态S中先终止一个死锁进 程P，使系统状态由S演变成U1，将P记入被终止进程的集合d(T)中，并把所付出的代 价C加入到Rc（T)中；对死锁进程P2、P等重复上述过程，得到状态U，U2，，U，U后， 再按终止进程时所花费代价的大小，把它插入到由S状态所演变的新状态的队列L中。显 止一个进程后，若系统仍处于死锁状态，则再从U状态按照上述处理方式再依次地终止一 个进程，得到U，U，U’，··，U状态，再从U状态中选取一个代价最小的U，如此 下去，直到死锁状态解除为止。这样，为把系统从死锁状态中解脱出来，所花费的代价可 表示为： R(S)min=min{Cui} +min{Cu;} +min{Cuk} +

1.高级调度与低级调度的主要任务是什么？为什么要引入中级调度？

2.处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？

3.何谓作业、作业步和作业流？

4.在什么情况下需要使用作业控制块JCB，其中包含了哪些内容？

5.在作业调度中应如何确定接纳多少个作业和接纳哪些作业？

6.为什么要引入高响应比优先调度算法？它有何优点？

7.试说明低级调度的主要功能。

8.在抢占调度方式中，抢占的原则是什么？ 118
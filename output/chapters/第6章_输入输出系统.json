[
  {
    "一级标题": "第6章_输入输出系统",
    "二级内容": [
      {
        "二级标题": "6.1_IO系统的功能、模型和接口",
        "三级内容": [
          {
            "三级标题": "6.1.110 系统的基本功能 为了满足系统和用户的要求，IVO系统应具有下述几方面的基本功能，其中，第一、二 方面的功能是为了方便用户使用I/O设备；第三、四方面的功能是用于提高CPU和I/O设 备的利用率；第五、六方面的功能是为用户在共享设备时提供方便，以保证系统能有条不 紊的运行，当系统发生错误时能及时发现错误，甚至于能自动修正错误。",
            "正文": "1.隐藏物理设备的细节 I/O设备的类型非常多，且彼此间在多方面都有差异，诸如它们接收和产生数据的速度， 传输方向、粒度、数据的表示形式及可靠性等方面。为了对这些千差万别的设备进行控制， 通常都为它们配置相应的设备控制器。这是一种硬件设备，其中包含有若干个用于存放控 制命令的寄存器和存放参数的寄存器。用户通过这些命令和参数，可以控制外部设备执行 所要求的操作。 显然，对于不同的设备，需要有不同的命令和参数。例如，在对磁盘进行操作时，不 仅要给出本次是读还是写的命令，还需给出源或目标数据的位置，包括磁盘的盘面号、磁 道号和扇区号。由此可见，如果要求程序员或用户编写直接面向这些设备的程序，是极端 困难的。因此，I/O系统必须通过对设备加以适当的抽象，以隐藏掉物理设备的实现细节， 仅向上层进程提供少量的、抽象的读/写命令，如read、write等。实际上，关于隐藏性问题， 我们在第一章中已做了类似的介绍。\n\n2.与设备的无关性 隐藏物理设备的细节，在早期的OS中就已实现，它可方便用户对设备的使用。与设 178  第六章输入输出系统 备的无关性是在较晚时才实现的，这是在隐藏物理设备细节的基础上实现的。一方面，用 户不仅可以使用抽象的IO命令，还可使用抽象的逻辑设备名来使用设备，例如，当用户 要输出打印时，他只须提供读(或写)的命令(提出对I/O的要求)，和提供抽象的逻辑设备名， 性和易适应性，对于OS本身而言，应允许在不需要将整个操作系统进行重新编译的情况 下，增添新的设备驱动程序，以方便新的I/O设备的安装。如Windows中，系统可以为新 I/O设备自动安装和寻找驱动程序，从而做到即插即用。\n\n3.提高处理机和V/O设备的利用率 在一般的系统中，许多I/O设备间是相互独立的，能够并行操作，在处理机与设备之 间也能并行操作。因此，I/O系统的第三个功能是要尽可能地让处理机和I/O设备并行操作， 以提高它们的利用率。为此，一方面要求处理机能快速响应用户的I/O请求，使I/O设备 尽快地运行起来；另一方面也应尽量减少在每个I/O设备运行时处理机的干预时间。在本 章中将介绍许多有助于实现该目标的方法。\n\n4.对VO设备进行控制 对IO设备进行控制是驱动程序的功能。目前对I/O设备有四种控制方式：①采用轮 询的可编程IO方式：②采用中断的可编程IO方式；③直接存储器访问方式：④I/O 通道方式。具体应采用何种控制方式，与IO设备的传输速率、传输的数据单位等因素有 关。如打印机、键盘终端等低速设备，由于其传输数据的基本单位是字节（或字），故应采 用中断的可编程IVO方式；而对于磁盘、光盘等高速设备，由于其传输数据的基本单位是 数据块，故应采用直接存储器访问方式，以提高系统的利用率；而IO通道方式的引入， 使对I/O操作的组织和数据的传输，都能独立进行而无需CPU的干预。为了方便高层软件 和用户，显然IVO软件也应屏蔽掉这种差异，向高层软件提供统一的操作接口。\n\n5.确保对设备的正确共享 从设备的共享属性上，可将系统中的设备分为如下两类：\n\n（1）独占设备，进程应互斥地访问这类设备，即系统一旦把这类设备分配给了某进程 后，便由该进程独占，直至用完释放。典型的独占设备有打印机、磁带机等。系统在对独 占设备进行分配时，还应考虑到分配的安全性。\n\n（2）共享设备，是指在一段时间内允许多个进程同时访问的设备。典型的共享设备是 磁盘，当有多个进程需对磁盘执行读、写操作时，可以交叉进行，不会影响到读、写的正 确性。\n\n6.错误处理 大多数的设备都包括了较多的机械和电气部分，运行时容易出现错误和故障。从处理 的角度，可将错误分为临时性错误和持久性错误。对于临时性错误，可通过重试操作来纠 正，只有在发生了持久性错误时，才需要向上层报告。例如，在磁盘传输过程中发生错误， 系统并不认为磁盘已发生了故障，而是可以重新再传，一直要重传多次后，若仍有错，才 认为磁盘发生了故障。由于多数错误是与设备紧密相关的，因此对于错误的处理，应该尽 可能在接近硬件的层面上进行，即在低层软件能够解决的错误就不向上层报告，因此高层 179  计算机操作系统 也就不能感知；只有低层软件解决不了的错误才向上层报告，请求高层软件解决。"
          },
          {
            "三级标题": "6.1.21 /0系统的层次结构和模型 I/O软件涉及的面很宽，向下与硬件有密切关系，向上又与文件系统、虚拟存储器系统 和用户直接交互，它们都需要IVO系统来实现IVO操作。为使十分复杂的IVO软件能具有清 晰的结构、更好的可移植性和易适应性，目前已普遍采用层次式结构的IV/O系统。这是将 系统中的设备管理模块分为若干个层次，每一层都是利用其下层提供的服务，完成输入输 出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。",
            "正文": "1.VO软件的层次结构 通常把IO软件组织成四个层次，如图6-1所示，各层次及其功能如下，图中的箭头 表示I/O的控制流：\n\n（1）用户层IVO软件，实现与用户交互的接口，用户可直接调用该层所提供的、与IVO 操作有关的库函数对设备进行操作。\n\n(2）设备独立性软件，用于实现用户程序与设备驱动器的统一接口、设备命名、设备 的保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。\n\n（3）设备驱动程序，与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱 动I/O设备工作的驱动程序。\n\n（4）中断处理程序，用于保存被中断进程的CPU环境，转入相应的中断处理程序进行 处理，处理完毕再恢复被中断进程的现场后，返回到被中断的进程。 VO应答 用户层软件 产生I/O请求、格式化I/O、Spooling 设备独立性软件 映射、保护、分块、缓冲、分配 设备驱动程序 设置设备寄存器：检查状态 中断处理程序 硬件 执行I/O操作 图6-1I/O系统的层次结构\n\n2.1/0系统中各种模块之间的层次视图 为了能更清晰地描述I/O系统中主要模块之间的关系，我们进一步介绍IV/O系统中各 种I/O模块之间的层次视图。见图6-2所示。 1)I/O系统的上、下接口\n\n（1）I/O系统接口。它是IO系统与上层系统之间的接口，向上层提供对设备进行操作 的抽象I/O命令，以方便高层对设备的使用。有不少OS在用户层提供了与I/O操作有关的 库函数，供用户使用。在上层系统中有文件系统、虚拟存储器系统以及用户进程等。\n\n(2）软件/硬件(RW/HW)接口。下面一个接口是软件/硬件接口，在它的上面是中断处理 程序和用于不同设备的设备驱动程序。在它的下面是各种设备的控制器。如CD-ROM控制 器、硬盘控制器、键盘控制器、打印机控制器、网络控制器等，它们都属于硬件。由于设 备种类繁多，故该接口相当复杂。如图6-2所示，在上、下两个接口之间则是IO系统。 180  第六章 输入输出系统 应用程序 用户层软件 虚拟内存 文件系统 管理 IVO系统接口 网络接口 打开/关闭 块设备接口 打开/关闭 打开/关闭 流设备接口 取/放 读/写 发送/接收 io_control 设备独立性 软件 块设备管理 流设备管理 网络通信软件 CD-ROM 硬盘 键盘 打印机 网络 设备驱动程序 驱动程序 驱动程序 驱动程序 驱动程序 驱动程序 1 CD-ROM 硬盘 键盘 打印机 网络 中断处理程序 中断处理程序 中断处理程序 中断处理程序 中断处理程序 中断处理程序 RW/HW接口 Y 键盘 CD-ROM 硬盘 打印机 网络 设备控制器 控制器 控制器 控制器 控制器 控制器 Y 光盘 硬盘 键盘 打印机) 网络 驱动器 驱动器 图6-2I/O系统中各种模块之间的层次视图 2）I/O系统的分层 与前面所述的IVO软件组织的层次结构相对应，IVO系统本身也可分为如下三个层次：\n\n（1）中断处理程序。它处于IO系统的底层，直接与硬件进行交互。当有IVO设备发来 中断请求信号时，在中断硬件做了初步处理后，便转向中断处理程序。它首先保存被中断 进程的CPU环境，然后转入相应设备的中断处理程序进行处理，在处理完成后，又恢复被 中断进程的CPU环境，返回断点继续运行。\n\n（2）设备驱动程序。它处于IVO系统的次底层，是进程和设备控制器之间的通信程序， 其主要功能是，将上层发来的抽象I/O请求转换为对I/O设备的具体命令和参数，并把它 装入到设备控制器中的命令和参数寄存器中，或者相反。由于设备之间的差异很大，每类 设备的驱动程序都不相同，故必须由设备制造厂商提供，而不是由OS设计者来设计。因 此，每当在系统中增加一个新设备时，都需要由安装厂商提供新的驱动程序。\n\n（3）设备独立性软件。现代OS中的IO系统基本上都实现了与设备无关性，也称为与设 备无关的软件。其基本含义是：I/O软件独立于具体使用的物理设备。由此带来的最大好处 是，提高了IO系统的可适应性和可扩展性。使它们能应用于许多类型的设备，而且在每次 增加新设备或替换老设备时，都不需要对IVO软件进行修改，这样就方便了系统的更新和扩 展。设备独立性软件的内容包括设备命名、设备分配、数据缓冲和数据高速缓冲一类软件等。"
          },
          {
            "三级标题": "6.1.31 /0系统接口 在IVO系统与高层之间的接口中，根据设备类型的不同，又进一步分为若干个接口。 在图6-2中示出了块设备接口、流设备接口和网络接口。",
            "正文": "1.块设备接口 块设备接口是块设备管理程序与高层之间的接口。该接口反映了大部分磁盘存储器和 181  计算机操作系统 光盘存储器的本质特征，用于控制该类设备的输入或输出。\n\n（1）块设备。所谓块设备，是指数据的存取和传输都是以数据块为单位的设备。典型 的块设备是磁盘。该设备的基本特征是传输速率较高，通常每秒钟为数MB 到数十MB。 另一特征是可寻址，即能指定数据的输入源地址及输出的目标地址，可随机地读/写磁盘中 任一块；磁盘设备的I/O常采用DMA方式。\n\n(2）隐藏了磁盘的二维结构。块设备接口将磁盘上的所有扇区从0到n-1依次编号，n 是磁盘中的扇区总数。经过这样编号后，就把磁盘的二维结构改变为一种线性序列。在二 维结构中，每个扇区的地址需要用磁道号和扇区号来表示。或者说，块设备接口隐藏了磁 盘地址是二维结构的情况。\n\n（3）将抽象命令映射为低层操作。块设备接口支持上层发来的对文件或设备的打开、 读、写和关闭等抽象命令。该接口将上述命令映射为设备能识别的较低层具体操作。例如， 上层发来读磁盘命令时，它先将抽象命令中的逻辑块号转换为磁盘的盘面、磁道和扇区等。 虚拟存储器系统也需要使用块设备接口，因为在进程运行期间，每当它所访问的页面 不在内存时便会发生缺页中断，此时就需要利用IO系统，通过块设备接口从磁盘存储器 中将所缺之页面调入内存。\n\n2.流设备接口 流设备接口是流设备管理程序与高层之间的接口。该接口又称为字符设备接口，它反 映了大部分字符设备的本质特征，用于控制字符设备的输入或输出。\n\n（1）字符设备。所谓字符设备，是指数据的存取和传输是以字符为单位的设备，如键 盘、打印机等。字符设备的基本特征是传输速率较低，通常为每秒几个字节至数千字节。 另一特征是不可寻址，即不能指定数据的输入源地址及输出的目标地址。字符设备在输入/ 输出时，常采用中断驱动方式。\n\n(2）get和put操作。由于字符设备是不可寻址的，因而对它只能采取顺序存取方式。 入)，或从字符缓冲区顺序地送出到设备（输出）。用户程序获取或输出字符的方法是采用get 和put操作。get操作用于从字符缓冲区取得一个字符(到内存)，将它返回给调用者。而put 操作则用于把一个新字符(从内存)输出到字符缓冲区中，以待送出到设备。\n\n（3）in-control指令。因字符设备的类型非常多，且差异甚大，为了以统一的方式来处 理它们，通常在流设备接口中提供了一种通用的in-control指令，在该指令中包含了许多参 数，每个参数表示一个与具体设备相关的特定功能。 由于大多数流设备都属于独占设备，必须采取互斥方式实现共享，为此，流设备接口 提供了打开和关闭操作。在使用这类设备时，必须先用打开操作来打开设备。如果设备已 被打开，则表示它正被其它进程使用。\n\n3.网络通信接口 在现代OS中，都提供了面向网络的功能。但首先还需要通过某种方式把计算机连接到网 络上。同时操作系统也必须提供相应的网络软件和网络通信接口，使计算机能通过网络与网络 上的其它计算机进行通信或上网浏览。由于网络通信接口涉及到许多关于网络方面的知识，如 网络中的网络通信协议和网络的层次结构等，故放在第10.6节（网络操作系统)中做专门的介绍。 182  /6.21/0设备和设备控制器 IO设备一般是由执行IO操作的机械部分和执行控制I/O的电子部件组成。通常将这 两部分分开，执行IO操作的机械部分就是一般的I/O设备，而执行控制IO的电子部件则 称为设备控制器或适配器（adapter)。在微型机和小型机中的控制器常做成印刷电路卡形式， 因而也常称为控制卡、接口卡或网卡，可将它插入计算机的扩展槽中。在有的大、中型计 算机系统中，还配置了I/O通道或IO处理机。"
          },
          {
            "三级标题": "6.2.11 /0设备 一",
            "正文": "1.I/O设备的类型 I/O设备的类型繁多，除了能将它们分为块设备和字符设备、独占设备和共享设备外， 还可从设备使用特性上分为存储设备和IO设备；从设备的传输速率上又分为高速设备、 中速共享设备和高速共享设备。下面对这两种分类进行介绍。 1）按使用特性分类 第一类是存储设备，也称外存、辅存，是用以存储信息的主要设备。该类设备存取速 度较内存慢，但容量却大得多，价格也便宜。第二类就是IO设备，它又可分为输入设备、 输出设备和交互式设备。输入设备用来接收外部信息，如键盘、鼠标、扫描仪、视频摄像 交互式设备则是指集成的上述两类设备，主要是显示器，用于同步显示用户命令以及命令 执行的结果。 2）按传输速率分类 按传输速度的高低，可将I/O设备分为三类。第一类是低速设备，其传输速率仅为每 秒钟几个字节至数百个字节。典型的低速设备有键盘、鼠标器。第二类是中速设备，其传 输速率在每秒钟数千个字节至数十万个字节。典型的中速设备有行式打印机、激光打印机 等。第三类是高速设备，其传输速率在数十万字节至千兆字节。典型的高速设备有磁带机、 磁盘机、光盘机等。\n\n2.设备与控制器之间的接口 IVO设备 通常，设备并不是直接与CPU进行通信， 至设备数据信号线 信号 而是与设备控制器通信，因此，在I/O设备中 缓冲转换器 控制器 数据 应含有与设备控制器间的接口，在该接口中有 状态信号线 控制逻辑 三种类型的信号（见图6-3所示），各对应一条 控制信号线 信号线。\n\n（1）数据信号线。这类信号线用于在设备 图6-3设备与控制器间的接口 和设备控制器之间传送数据信号。对输入设备 而言，由外界输入的信号经转换器转换后，所形成的数据通常先送入缓冲器中，当数据量 达到一定的比特（字符）数后，再从缓冲器通过一组数据信号线传送给设备控制器，如图6-3 183"
          }
        ]
      },
      {
        "二级标题": "6.2_IO设备和设备控制器",
        "三级内容": [
          {
            "三级标题": "6.2.11 /0设备 一",
            "正文": "1.I/O设备的类型 I/O设备的类型繁多，除了能将它们分为块设备和字符设备、独占设备和共享设备外， 还可从设备使用特性上分为存储设备和IO设备；从设备的传输速率上又分为高速设备、 中速共享设备和高速共享设备。下面对这两种分类进行介绍。 1）按使用特性分类 第一类是存储设备，也称外存、辅存，是用以存储信息的主要设备。该类设备存取速 度较内存慢，但容量却大得多，价格也便宜。第二类就是IO设备，它又可分为输入设备、 输出设备和交互式设备。输入设备用来接收外部信息，如键盘、鼠标、扫描仪、视频摄像 交互式设备则是指集成的上述两类设备，主要是显示器，用于同步显示用户命令以及命令 执行的结果。 2）按传输速率分类 按传输速度的高低，可将I/O设备分为三类。第一类是低速设备，其传输速率仅为每 秒钟几个字节至数百个字节。典型的低速设备有键盘、鼠标器。第二类是中速设备，其传 输速率在每秒钟数千个字节至数十万个字节。典型的中速设备有行式打印机、激光打印机 等。第三类是高速设备，其传输速率在数十万字节至千兆字节。典型的高速设备有磁带机、 磁盘机、光盘机等。\n\n2.设备与控制器之间的接口 IVO设备 通常，设备并不是直接与CPU进行通信， 至设备数据信号线 信号 而是与设备控制器通信，因此，在I/O设备中 缓冲转换器 控制器 数据 应含有与设备控制器间的接口，在该接口中有 状态信号线 控制逻辑 三种类型的信号（见图6-3所示），各对应一条 控制信号线 信号线。\n\n（1）数据信号线。这类信号线用于在设备 图6-3设备与控制器间的接口 和设备控制器之间传送数据信号。对输入设备 而言，由外界输入的信号经转换器转换后，所形成的数据通常先送入缓冲器中，当数据量 达到一定的比特（字符）数后，再从缓冲器通过一组数据信号线传送给设备控制器，如图6-3 183  计算机操作系统 所示。对输出设备而言，则是将从设备控制器经过数据信号线传送来的一批数据先暂存于 缓冲器中，经转换器作适当转换后，再逐个字符地输出。\n\n(2）控制信号线。这是作为由设备控制器向IVO设备发送控制信号时的通路。该信号规 定了设备将要执行的操作，如读操作（指由设备向控制器传送数据）或写操作（从控制器接收 数据），或执行磁头移动等操作。\n\n(3）状态信号线。该信号线用于传送指示设备当前状态的信号。设备的当前状态有正 在读（或写）；设备已读（写）完成，并准备好新的数据传送。"
          },
          {
            "三级标题": "6.2.2 设备控制器 设备控制器的主要功能是，控制一个或多个IVO设备，以实现IO设备和计算机之间 的数据交换。它是CPU与IVO设备之间的接口，接收从CPU发来的命令，去控制IIO设备 工作，使处理机能够从繁杂的设备控制事务中解脱出来。设备控制器是一个可编址的设备， 当它仅控制一个设备时，它只有一个唯一的设备地址；若控制器可连接多个设备，则应含 控制字符设备的控制器，另一类是用于控制块设备的控制器。",
            "正文": "1.设备控制器的基本功能\n\n（1）接收和识别命令。设备控制器能接收并识别处理机发来的多种命令。在控制器中 具有相应的控制寄存器，用来存放接收的命令和参数，并对所接收的命令进行译码。例如， 磁盘控制器可以接收CPU发来的read、write、format等15条不同的命令，而且有些命 令还带有参数。相应地，在磁盘控制器中有多个寄存器和命令译码器等。\n\n(2）数据交换。设备控制器可实现CPU与控制器之间、控制器与设备之间的数据交换 对于前者，是通过数据总线，由CPU并行地把数据写入控制器，或从控制器中并行地读出 数据。对于后者，是设备将数据输入到控制器，或从控制器传送给设备。为此，在控制器 中须设置数据寄存器。\n\n（3）标识和报告设备的状态。控制器应记下设备的状态供CPU了解。例如，仅当该设 备处于发送就绪状态时，CPU才能启动控制器从设备中读出数据。为此，在控制器中应设 置一状态寄存器，用其中的每一位反映设备的某一种状态。当CPU将该寄存器的内容读入 后，便可了解该设备的状态。\n\n(4）地址识别。就像内存中的每一个单元都有一个地址一样，系统中的每一个设备也 都有一个地址。设备控制器必须能够识别其所控制的每个设备的地址。此外，为使CPU能 向(或从)寄存器中写入(或读出)数据，这些寄存器都应具有唯一的地址。控制器应能正确识 别这些地址。为此，在控制器中应配置地址译码器。\n\n（5）数据缓冲区。由于IO设备的速率较低，而CPU和内存的速率却很高，故在控制 器中必须设置一缓冲区。在输出时，用此缓冲区暂存由主机高速传来的数据，然后才以与 IVO设备所匹配的速率将缓冲器中的数据传送给IVO设备。在输入时，缓冲区则用于暂存从 IO设备送来的数据，待接收到一批数据后，再将缓冲区中的数据高速地传送给主机。\n\n（6）差错控制。对于由IO设备传送来的数据，设备控制器还兼管进行差错检测。若发 现传送中出现了错误，通常是将差错检测码置位，并向CPU报告，于是CPU将本次传送 来的数据作废，并重新进行一次传送。这样便可保证数据输入的正确性。 184  第六章输入输出系统\n\n2.设备控制器的组成 由于设备控制器位于CPU与设备之间，它既要与CPU通信，又要与设备通信，还应 具有按照CPU所发来的命令去控制设备工作的功能，因此，现有的大多数控制器都是由以 下三部分组成：\n\n（1）设备控制器与处理机的接口。该接口用于实现CPU与设备控制器之间的通信，在 该接口中共有三类信号线：数据线、地址线和控制线。数据线通常与两类寄存器相连接： ①第一类是数据寄存器，在控制器中可以有一个或多个数据寄存器，用于存放从设备送来 的数据（输入），或从CPU送来的数据（输出）。②第二类是控制/状态寄存器，在控制器中可 以有一个或多个这类寄存器，用于存放从CPU送来的控制信息或设备的状态信息。\n\n(2）设备控制器与设备的接口。在一个设备控制器上，可以连接一个或多个设备。相 应的，在控制器中便有一个或多个设备接口。在每个接口中都存在数据、控制和状态三种\n\n(3）I/O逻辑。I/O逻辑用于实现对设备的控制。它通过一组控制线与处理机交互，处 理机利用该逻辑向控制器发送IVO命令。每当CPU要启动一个设备时，一方面将启动命令 发送给控制器，另一方面又同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对 收到的地址进行译码，再根据所译出的命令对所选设备进行控制。 设备控制器的组成示于图6-4中。 CPU与控制器接口 控制器与设备接口 控制器 数据 数据线 数据寄存器 与设备 状态 接口1 控制 控制/状态 寄存器 地址线 控制器 数据 1O逻辑 与设备 状态 控制线 接口i 控制 图6-4设备控制器的组成"
          },
          {
            "三级标题": "6.2.3 内存映像VO 一← 驱动程序将抽象I/O命令转换出的一系列具体的命令、参数等数据装入设备控制器的 相应寄存器，由控制器来执行这些命令，具体实施对IVO设备的控制。这一工作可用如下 两种方法完成：",
            "正文": "1.利用特定的I/0指令 在早期的计算机中，包括大型计算机，为实现CPU和设备控制器之间的通信，为每个 控制寄存器分配一个I1/0端口，这是一个8位或16位的整数，如图6-5（a）所示。另外还设 置了一些特定的IO指令。例如，为了将CPU寄存器中的内容复制到控制器寄存器中，所 需使用的特定I/O指令可表示如下： io-storecpu-reg,dev-no, dev-reg 185  计算机操作系统 其中，cpu-reg是CPU的某个寄存器；dev-no是指定的设备，即控制器地址；dev-reg 指定 控制器中的寄存器。如果是将CPU寄存器中的内容存入内存的某个单元(k)中，将使用下面 的指令： Store cpu-reg, k 该方法的主要缺点是，访问内存和访问设备需要两种不同的指令。\n\n2.内存映像1/O 在这种方式中，在编址上不再区分内存单元地址和设备控制器中的寄存器地址，都采 用k。当k值处于0～n-1范围时，被认为是内存地址，若k大于等于n时，被认为是某个 控制器的寄存器地址。由图6-5（b）可以看出，当k=n时，表示设备控制器0的第1个寄存 器opcode的地址。因此，如果要想将CPU寄存器中的内容传送到控制器0的第1个寄存 器opcode，只需要用下面的一般存储指令： Store cpu-reg, n 内存映像IV/O方式统一了对内存和对控制器的访问方法，这无疑将简化IO的编程。 地址 地址 0 0 内存 内存 n- n-1 dev_o opcode opcode Operand 0 设备 Operand 0 设备 n+2 Operand 1 控制器0 Operand1 控制器0 ： dev_1 opcode opcode Operand O 设备 Operand0 设备 Operand1 控制器1 Operand 1 控制器1 (a)采用特定的指令形式 (b)内存映像I/O形式 图6-5设备寻址形式"
          },
          {
            "三级标题": "6.2.41 /0通道",
            "正文": "1.1V/0通道设备的引入 虽然在CPU与IO设备之间增加了设备控制器后，已能大大减少CPU对IVO的干预， 但当主机所配置的外设很多时，CPU的负担仍然很重。为此，在CPU和设备控制器之间又 增设了I/O通道（VOChannel)。其主要目的是为了建立独立的IO操作，不仅使数据的传送 能独立于CPU，而且也希望有关对I/O操作的组织、管理及其结束处理尽量独立，以保证 CPU有更多的时间去进行数据处理；或者说，其目的是使一些原来由CPU处理的IO任务 转由通道来承担，从而把CPU从繁杂的IVO任务中解脱出来。在设置了通道后，CPU只需 186  第六章输入输出系统 向通道发送一条IO指令。通道在收到该指令后，便从内存中取出本次要执行的通道程序， 然后执行该通道程序，仅当通道完成了规定的IVO任务后，才向CPU发中断信号。 实际上，IVO通道是一种特殊的处理机。它具有执行IO指令的能力，并通过执行通道 (IV/O)程序来控制IO操作。但I/O通道又与一般的处理机不同，主要表现在以下两个方面： 一是其指令类型单一，这是由于通道硬件比较简单，其所能执行的命令，主要局限于与I/O 操作有关的指令；二是通道没有自己的内存，通道所执行的通道程序是放在主机的内存中 的，换言之，是通道与CPU共享内存。\n\n2.通道类型 前已述及，通道是用于控制外围设备（包括字符设备和块设备）的。由于外围设备的类 型较多，且其传输速率相差甚大，因而使通道具有多种类型。这里，根据信息交换方式的 不同，可把通道分成以下三种类型。 1）字节多路通道（ByteMultiplexorChannel) 这是一种按字节交叉方式工作的通道。它通常都含有许多非分配型子通道，其数量可 从几十到数百个，每一个子通道连接一台I/O设备，并控制该设备的I/O操作。这些子通 道按时间片轮转方式共享主通道。当第一个子通道控制其I/O设备完成一个字节的交换后， 便立即腾出主通道，让给第二个子通道使用；当第二个子通道也完成一个字节的交换后， 同样也把主通道让给第三个子通道：依此类推。当所有子通道轮转一周后，重又返回来由 第一个子通道去使用字节多路主通道。这样，只要字节多路通道扫描每个子通道的速率足 够快，而连接到子通道上的设备的速率又不是太高，便不致丢失信息。 图6-6示出了字节多路通道的工作原理。它所含有的多个子通道为A，B，C，D，E，， N，分别通过控制器各与一台设备相连。假定这些设备的速率相近，且都同时向主机传 送数据。设备A所传送的数据流为A1，A2，A3，“；设备B所传送的数据流为B1，B2， B3，；·……·把这些数据流合成后（通过主通道)送往主机的数据流为A1，B1，C，D，， A2, B2， C2， D2，…….，A3， B3，C3，D3，…。 设备 AA子通道A 控制器A O BB·子通道B 控制器B O AB,C.·.·ABC... CiC.子通道C 控制器C O 控制器D O O NN.子通道N 控制器E O O 图6-6字节多路通道的工作原理 2）数组选择通道（BlockSelectorChannel) 字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通 道的形成。这种通道虽然可以连接多台高速设备，但由于它只含有一个分配型子通道，在 一段时间内只能执行一道通道程序，控制一台设备进行数据传送，致使当某台设备占用了 该通道后，便一直由它独占，即使是它无数据传送，通道被闲置，也不允许其它设备使用 187  计算机操作系统 该通道，直至该设备传送完毕释放该通道。可见，这种通道的利用率很低。 3）数组多路通道(BlockMultiplexorChannel) 数组选择通道虽有很高的传输速率，但它却每次只允许一个设备传输数据。数组多路 通道是将数组选择通道传输速率高和字节多路通道能使各子通道(设备)分时并行操作的优 点相结合而形成的一种新通道。它含有多个非分配型子通道，因而这种通道既具有很高的 数据传输速率，又能获得令人满意的通道利用率。也正因此，才使该通道能被广泛地用于 连接多台高、中速的外围设备，其数据传送是按数组方式进行的。\n\n3.“瓶颈”问题 由于通道价格昂贵，致使机器中所设置的通道数量势必较少，这往往又使它成了I/O 的瓶颈，进而造成整个系统吞吐量的下降。例如，在图6-7中，假设设备1至设备4是四 个磁盘，为了启动磁盘4，必须用通道1和控制器2；但若这两者已被其它设备占用，必然 无法启动磁盘4。类似地，若要启动盘1和盘2，由于它们都要用到通道1，因而也不可能 启动。这些就是由于通道不足所造成的“瓶颈”现象。 设备1 控制器1 通道1 设备2 控制器2 设备3 存储器 设备4 设备5 控制器3 通道2 设备6 控制器4 设备7 图6-7单通路I/O系统 6-8所示。换言之，就是把一个设备连接到多个控制器上，而一个控制器又连接到多个通道上。 图中的设备1、2、3和4，都有4条通往存储器的通路。例如，通过控制器1和通道1到存储 器；也可通过控制器2和通道1到存储器。多通路方式不仅解决了“瓶颈”问题，而且提高 了系统的可靠性，因为个别通道或控制器的故障不会使设备和存储器之间没有通路。 设备1 通道1 控制器1 设备2 存储器 设备3 通道2 控制器2 设备4 图6-8多通路IO系统 188  第六章输入输出系统\n\n16.3中断机构和中断处理程序 NE 对于操作系统中的IO系统，本章采取从低层向高层的介绍方法，从本节开始首先介 绍中断处理程序。中断在操作系统中有着特殊重要的地位，它是多道程序得以实现的基础， 没有中断，就不可能实现多道程序，因为进程之间的切换是通过中断来完成的。另一方面， 中断也是设备管理的基础，为了提高处理机的利用率和实现CPU与IVO设备并行执行，也 必需有中断的支持。中断处理程序是IO系统中最低的一层，它是整个I/O系统的基础。"
          },
          {
            "三级标题": "6.3.1 中断简介",
            "正文": "1.中断和陷入 1）中断 中断是指CPU对IO设备发来的中断信号的一种响应。CPU暂停正在执行的程序，保 留CPU环境后，自动地转去执行该IVO设备的中断处理程序。执行完后，再回到断点，继 续执行原来的程序。IO设备可以是字符设备，也可以是块设备、通信设备等。由于中断是 由外部设备引起的，故又称外中断。 2）陷入 另外还有一种由CPU内部事件所引起的中断，例如进程在运算中发生了上溢或下溢， 又如程序出错，如非法指令、地址越界，以及电源故障等。通常把这类中断称为内中断或 陷入（trap)。与中断一样，若系统发现了有陷入事件，CPU也将暂停正在执行的程序，转去 执行该陷入事件的处理程序。中断和陷入的主要区别是信号的来源，即是来自CPU外部， 还是CPU内部。\n\n2.中断向量表和中断优先级 1）中断向量表 为了处理上的方便，通常是为每种设备配以相应的中断处理程序，并把该程序的入口 地址放在中断向量表的一个表项中，并为每一个设备的中断请求规定一个中断号，它直接 对应于中断向量表的一个表项中。当IVO设备发来中断请求信号时，由中断控制器确定该 请求的中断号，根据该设备的中断号去查找中断向量表，从中取得该设备中断处理程序的 入口地址，这样便可以转入中断处理程序执行。 2）中断优先级 然而实际情况是：经常会有多个中断信号源，每个中断源对服务要求的紧急程度并不 相同，例如，键盘终端的中断请求的紧急程度不如打印机，而打印机中断请求的紧急程度 又不如磁盘等。为此，系统就需要为它们分别规定不同的优先级。\n\n3.对多中断源的处理方式 对于多中断信号源的情况，当处理机正在处理一个中断时，又来了一个新的中断请求， 信号。对于这种情况，可有两种处理方式：屏蔽(禁止)中断与嵌套中断。 189"
          }
        ]
      },
      {
        "二级标题": "6.3_中断机构和中断处理程序",
        "三级内容": [
          {
            "三级标题": "6.3.1 中断简介",
            "正文": "1.中断和陷入 1）中断 中断是指CPU对IO设备发来的中断信号的一种响应。CPU暂停正在执行的程序，保 留CPU环境后，自动地转去执行该IVO设备的中断处理程序。执行完后，再回到断点，继 续执行原来的程序。IO设备可以是字符设备，也可以是块设备、通信设备等。由于中断是 由外部设备引起的，故又称外中断。 2）陷入 另外还有一种由CPU内部事件所引起的中断，例如进程在运算中发生了上溢或下溢， 又如程序出错，如非法指令、地址越界，以及电源故障等。通常把这类中断称为内中断或 陷入（trap)。与中断一样，若系统发现了有陷入事件，CPU也将暂停正在执行的程序，转去 执行该陷入事件的处理程序。中断和陷入的主要区别是信号的来源，即是来自CPU外部， 还是CPU内部。\n\n2.中断向量表和中断优先级 1）中断向量表 为了处理上的方便，通常是为每种设备配以相应的中断处理程序，并把该程序的入口 地址放在中断向量表的一个表项中，并为每一个设备的中断请求规定一个中断号，它直接 对应于中断向量表的一个表项中。当IVO设备发来中断请求信号时，由中断控制器确定该 请求的中断号，根据该设备的中断号去查找中断向量表，从中取得该设备中断处理程序的 入口地址，这样便可以转入中断处理程序执行。 2）中断优先级 然而实际情况是：经常会有多个中断信号源，每个中断源对服务要求的紧急程度并不 相同，例如，键盘终端的中断请求的紧急程度不如打印机，而打印机中断请求的紧急程度 又不如磁盘等。为此，系统就需要为它们分别规定不同的优先级。\n\n3.对多中断源的处理方式 对于多中断信号源的情况，当处理机正在处理一个中断时，又来了一个新的中断请求， 信号。对于这种情况，可有两种处理方式：屏蔽(禁止)中断与嵌套中断。 189  计算机操作系统 1）屏蔽（禁止）中断 当处理机正在处理一个中断时，将屏蔽掉所有的中断，即处理机对任何新到的中断请 求，都暂时不予理睬，而让它们等待。直到处理机已完成本次中断的处理后，处理机再去 检查是否有中断发生。若有，再去处理新到的中断，若无，则返回被中断的程序。在该方 法中，所有中断都将按顺序依次处理。其优点是简单，但不能用于对实时性要求较高的中 断请求。图6-9(a)示出了禁止中断时多中断顺序处理时的情况。 2）嵌套中断 在设置了中断优先级的系统中，通常按这样的规则来进行优先级控制：\n\n（1）当同时有多个不同优先级的中断请求时，CPU优先响应最高优先级的中断请求；\n\n（2）高优先级的中断请求可以抢占正在运行的低优先级中断的处理机，该方式类似于 基于优先级的抢占式进程调度。例如，处理机正在处理打印机中断，当有磁盘中断到来时， 可暂停对打印机中断的处理，转去处理磁盘中断。如果新到的是键盘中断，由于它的优先 级低于打印机的优先级，故处理机继续处理打印机中断。图6-9(b)示出了可多重中断时的 情况。 用户程序 中断处理器X 用户程序 中断处理器X V 三 中断处理器Y 中断处理器Y 一 (a)顺序中断处理 (b)嵌套中断处理 图6-9对多中断的处理方式"
          },
          {
            "三级标题": "6.3.2 中断处理程序 当一个进程请求IVO操作时，该进程将被挂起，直到I/O设备完成I/O操作后，设备 控制器便向CPU发送一个中断请求，CPU响应后便转向中断处理程序，中断处理程序执行 相应的处理，处理完后解除相应进程的阻塞状态。 中断处理程序的处理过程可分成以下几个步骤：",
            "正文": "(1）测定是否有未响应的中断信号。每当设备完成一个字符(字或数据块)的读入(或输 出），设备控制器便向处理机发送一个中断请求信号。请求处理机将设备已读入的数据传送 到内存的缓冲区中（读入），或者请求处理机将要输出的数据（输出）传送给设备控制器。程序 每当执行完当前指令后，处理机都要测试是否有未响应的中断信号。若没有，继续执行下 一条指令。若有，则停止原有进程的执行，准备转去执行中断处理程序，为把处理机的控 制权转交给中断处理程序做准备。 190  第六章输入输出系统\n\n（2）保护被中断进程的CPU环境。在把控制权转交给中断处理程序之前，需要先保护 被中断进程的CPU环境，以便以后能恢复运行。首先需要保存的是，从中断现场恢复到当 前进程运行所需要的信息。通常由硬件自动将处理机状态字(PSW)和保存在程序计数器(PC) 中下一条指令的地址保存在中断保留区（栈)中。然后，把被中断进程的CPU现场信息，即 将包括所有CPU寄存器的（如通用寄存器、段寄存器等）内容都压入中断栈中。因为在中断 处理时可能会用到这些寄存器。图6-10给出了一个简单的保护中断现场的示意图。该程序 是指令在N位置时被中断的，程序计数器中的内容为N+1，所有寄存器的内容都被保留在 栈中。 PSW T 程序状态字 Rn 线指针 PC(N+1) 寄存器 程序记数器 开始 PSW PC(N+1) Ro N Rn N-1 返回 中断栈 中断服务子例程 用户程序 图6-10中断现场保护示意图\n\n（3）转入相应的设备处理程序。由处理机对各个中断源进行测试，以确定引起本次中 断的IV/O设备，并向提供中断信号的设备发送确认信号。在该设备收到确认信号后，就立 即取消它所发出的中断请求信号。然后，将相应的设备中断处理程序的入口地址装入到程 序计数器中。这样，当处理机运行时，便可自动地转向中断处理程序。\n\n（4）中断处理。对不同的设备，有不同的中断处理程序。该程序首先从设备控制器中 读出设备状态，以判别本次中断是正常完成中断还是异常结束中断。若是前者，中断程序 便做结束处理。假如这次是字符设备的读操作，则来自输入设备的中断是表明该设备已经 读入了一个字符（字）的数据，并已放入数据寄存器中。此时中断处理应将该数据传送给 CPU，再将它存入缓冲区中，并修改相应的缓冲区指针，使其指向下一个内存单元。若还 有命令，可再向控制器发送新的命令，进行新一轮的数据传送。若是异常结束中断，则根 据发生异常的原因做相应的处理。\n\n(5）恢复CPU的现场并退出中断。当中断处理完成以后，需要恢复CPU的现场，退出 中断。但是，此刻是否返会到被中断的进程，取决于两个因素： ①本中断是否采用了屏蔽（禁止)中断方式，若是，就会返回被中断的进程。 ②采用的是中断嵌套方式，如果没有优先级更高的中断请求IO，在中断完成后，仍 会返回被中断的进程；反之，系统将处理优先级更高的中断请求。 如果是要返回到被中断的进程，可将保存在中断栈中的被中断进程的现场信息取出， 并装入到相应的寄存器中，其中包括该程序下一次要执行的指令的地址N+1、处理机状态 191  计算机操作系统 字PSW，以及各通用寄存器和段寄存器的内容。这样，当处理机再执行本程序时，便从 N+1处开始，最终返回到被中断的程序。 中断的处理流程如图6-11所示。 中断请求信号 唤醒被阻塞的 驱动程序进程 对被中断进程的 CPU环境进行保护 分析中断原因，转入 相应的中断处理程序 终端中断 终端中断 终端中断 处理程序 处理程序 处理程序 恢复被中断 进程的现场 返回被中断的进 程，继续执行 图6-11中断处理流程 IO操作完成后，驱动程序必须检查本次I/O操作中是否发生了错误，并向上层软件报 告，最终向调用者报告本次I/O的执行情况。除了上述的第4步外，其它各步骤对所有I/O 设备都是相同的，因而对于某种操作系统，例如UNIX系统，是把这些共同的部分集中起 来，形成中断总控程序。每当要进行中断处理时，都要首先进入中断总控程序。而对于第 4步，则对不同设备须采用不同的设备中断处理程序继续执行。 设备驱动程序 4 设备处理程序通常又称为设备驱动程序，它是IVO系统的高层与设备控制器之间的通 信程序，其主要任务是接收上层软件发来的抽象I/O要求，如read或write命令，再把它转 换为具体要求后，发送给设备控制器，启动设备去执行；反之，它也将由设备控制器发来 的信号传送给上层软件。由于驱动程序与硬件密切相关，故通常应为每一类设备配置一种 驱动程序。例如，打印机和显示器需要不同的驱动程序。"
          },
          {
            "三级标题": "6.4.1 设备驱动程序概述",
            "正文": "1.设备驱动程序的功能 为了实现IO系统的高层与设备控制器之间的通信，设备驱动程序应具有以下功能：\n\n(1）接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设 192"
          }
        ]
      },
      {
        "二级标题": "6.4_设备驱动程序",
        "三级内容": [
          {
            "三级标题": "6.4.1 设备驱动程序概述",
            "正文": "1.设备驱动程序的功能 为了实现IO系统的高层与设备控制器之间的通信，设备驱动程序应具有以下功能：\n\n(1）接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设 192  第六章输入输出系统 备相关的低层操作序列。\n\n(2）检查用户IVO请求的合法性，了解I/O设备的工作状态，传递与IVO设备操作有关 的参数，设置设备的工作方式。\n\n(3）发出IO命令，如果设备空闲，便立即启动I/O设备，完成指定的I/O操作；如果 设备忙碌，则将请求者的请求块挂在设备队列上等待。\n\n(4）及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处 理程序进行处理。\n\n2.设备驱动程序的特点 设备驱动程序属于低级的系统例程，它与一般的应用程序及系统程序之间有下述明显 差异：\n\n（1）驱动程序是实现在与设备无关的软件和设备控制器之间通信和转换的程序，具体 说，它将抽象的IVO请求转换成具体的IIO操作后传送给控制器。又把控制器中所记录的 设备状态和I/O操作完成情况，及时地反映给请求IO的进程。 应配置不同的驱动程序。但可以为相同的多个终端设置一个终端驱动程序。\n\n（3）驱动程序与IO设备所采用的IO控制方式紧密相关，常用的I/O控制方式是中断 驱动和DMA方式。\n\n（4）由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。目前有 很多驱动程序的基本部分已经固化在ROM中。\n\n（5）驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次 调用。\n\n3.设备处理方式 在不同的操作系统中，所采用的设备处理方式并不完全相同。根据在设备处理时是否 设置进程，以及设置什么样的进程，而把设备处理方式分成以下三类：\n\n（1）为每一类设备设置一个进程，专门用于执行这类设备的IVO操作。比如，为所有的 交互式终端设置一个交互式终端进程；又如，为同一类型的打印机设置一个打印进程。这 种方式比较适合于较大的系统。\n\n（3）不设置专门的设备处理进程，而只为各类设备设置相应的设备驱动程序，供用户 或系统进程调用。这种方式目前用得较多。"
          },
          {
            "三级标题": "6.4.2 设备驱动程序的处理过程 设备驱动程序的主要任务是启动指定设备，完成上层指定的IVO工作。但在启动之前， 才向设备控制器发送一条启动命令。以下是设备驱动程序的处理过程：",
            "正文": "(1）将抽象要求转换为具体要求。通常在每个设备控制器中都含有若干个寄存器，分 别用于暂存命令、参数和数据等。由于用户及上层软件对设备控制器的具体情况毫无了解， 193  计算机操作系统 因而只能发出命令(抽象的要求)，这些命令是无法传送给设备控制器的。因此，就需要将 这些抽象要求转换为具体要求。例如，将抽象要求中的盘块号转换为磁盘的盘面、磁道号 及扇区。而这一转换工作只能由驱动程序来完成，因为在OS中只有驱动程序才同时了解 抽象要求和设备控制器中的寄存器情况，也只有它才知道命令、数据和参数应分别送往哪 个寄存器。\n\n(2）对服务请求进行校验。驱动程序在启动IO设备之前，必须先检查该用户的I/O请 求是不是该设备能够执行的。一个非法请求的典型例子是，用户试图请求从一台打印机读 入数据。如果驱动程序能检查出这类错误，便认为这次IVO请求非法，它将向IVO系统报 告IVO请求出错。IVO系统可以根据具体情况做出不同的决定。如可以停止请求进程的运行， 或者仅通知请求进程它的IVO请求有错，但仍然让它继续运行。此外，还有些设备如磁盘 和终端，它们虽然都是既可读、又可写的，但若在打开这些设备时规定的是读，则用户的 写请求必然被拒绝。\n\n（3）检查设备的状态。启动某个设备进行I/O操作，其前提条件应是该设备正处于就绪 状态。为此，在每个设备控制器中，都配置有一个状态寄存器。驱动程序在启动设备之前， 要先把状态寄存器中的内容读入到CPU的某个寄存器中，通过测试寄存器中的不同位，来 了解设备的状态，如图6-12所示。例如，为了向某设备写入数据，此前应先检查状态寄存 器中接收就绪的状态位，看它是否处于接收就绪状态。仅当它处于接收就绪状态时，才能 启动其设备控制器，否则只能等待。 DD6DsD4DD2DDo [TRT DSR DET EMPRDYRDY 发送就绪 接收就绪 发送器空 奇偶校验错 溢出错 组帧错 检出的SYNC特征 DSR引脚的状态 图6-12状态寄存器中的格式\n\n(4）传送必要的参数。在确定设备处于接收(发送)就绪状态后，便可向控制器的相应寄 存器传送数据及与控制本次数据传输有关的参数。例如，在某种设备控制器中配置了两个 IVO操作是接收数据还是发送数据等。另一个是方式寄存器，它用于控制本次传送数据的速 率、发送的字符长度等。如果是利用RS232C接口进行异步通信，在启动该接口之前，应 先按通信规程设定下述参数：波特率、奇偶校验方式、停止位数目及数据字节长度等。对 于较为复杂的块设备，除必须向其控制器发出启动命令外，还需传送更多的参数。\n\n(5）启动IO设备。在完成上述各项准备工作后，驱动程序便可以向控制器中的命令寄 存器传送相应的控制命令。对于字符设备，若发出的是写命令，驱动程序便把一个字符（或 字)，传送给控制器；若发出的是读命令，则驱动程序等待接收数据，并通过读入控制器的 状态寄存器中状态字的方法来确定数据是否到达。 194  第六章输入输出系统 在多道程序系统中，驱动程序一旦发出I/O命令，启动了一个IO操作后，驱动程序 便把控制返回给IVO系统，把自己阻塞起来，直到中断到来时再被唤醒。具体的IVO操作 是在设备控制器的控制下进行的，因此，在设备忙于传送数据时，处理机又可以去干其它 的事情，实现了处理机与I/O设备的并行操作。"
          },
          {
            "三级标题": "6.4.3 对1/0设备的控制方式 对设备的控制，早期是使用轮询的可编程I/O方式，后来发展为使用中断的可编程I/O 方式。随着DMA控制器的出现，从以字节为单位，改为以数据块为单位进行转输，大大 地改善了块设备的IO性能。IO通道的出现，又使对IO操作的组织和数据的传送都能独 立进行，而无需CPU的干预。应当指出，在I/O控制方式的整个发展过程中，始终贯穿着 这样一条宗旨，即尽量减少主机对I/O控制的干预，把主机从繁杂的I/O控制事务中解脱 出来，以便更多地去完成数据处理任务。",
            "正文": "1.使用轮询的可编程I/O方式 处理机对IVO设备的控制采取轮询的可编程I/O方式，即在处理机向控制器发出一条 IO指令，启动输入设备输入数据时，要同时把状态寄存器中的忙/闲标志busy置为1，然 后便不断地循环测试busy（称为轮询）。当busy=1时，表示输入机尚未输完一个字（符），处 理机应继续对该标志进行测试，直至busy=0，表明输入机已将输入数据送入控制器的数据 寄存器中。于是处理机将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了 一个字（符）的I/O。接着再去启动读下一个数据，并置busy=1。图6-13(a)示出了程序I/O方 式的流程。 CPU→I0 向V/O控制器 向1/0控制器 CPU→I/0 发读命令 发读命令 CPU做其它事 读V/O控制器 读IVO控制器 中断 的状态 1/O→CPU 的状态 未 VO-→CPU 就 绪 检查 检查 出错 出错 状态？ 状态？ 就绪 就绪 从IO控制器 从1O控制 VO→CPU VO-CPU 中读入字 器中读入字 CPU-DMA 向VO控制器 发布读块命令 向存储器 向存储器 CPU→内存 CPU→内存 CPU做其它事 中写字 中写字 中断 未完成传送 未完成 读DMA控制 传送 器的状态 完成？ 完成？ DMA→CPU 完成 完成 下一条指令 下一条指令 下一条指令 (a)程序IVO方式 (b）中断驱动1/0方式 (c)DMA方式 图6-13程序I/O和中断驱动方式的流程 195  计算机操作系统 在程序IO方式中，CPU的绝大部分时间都处于等待I/O设备完成数据IO的循环测 试中，造成对CPU的极大浪费。在该方式中，CPU之所以要不断地测试IO设备的状态， 操作。\n\n2.使用中断的可编程1VO方式 当前，对I/O设备的控制，广泛采用中断的可编程IO方式，即当某进程要启动某个 行原来的任务。设备控制器于是按照该命令的要求去控制指定IVO设备。此时，CPU与I/O 设备并行操作。例如，在输入时，当设备控制器收到CPU发来的读命令后，便去控制相 应的输入设备读数据。一旦数据进入数据寄存器，控制器便通过控制线向CPU发送一中 断信号，由CPU检查输入过程中是否出错，若无错，便向控制器发送取走数据的信号， 然后再通过控制器及数据线，将数据写入内存指定单元中。图6-13(b)示出了中断驱动方 式的流程。 在IO设备输入每个数据的过程中，可使CPU与IO设备并行工作。仅当输完一个数 据时，才需CPU花费极短的时间去做些中断处理。这样可使CPU和I/O设备都处于忙碌 状态，从而提高了整个系统的资源利用率及吞吐量。例如，从终端输入一个字符的时间约 为100ms，而将字符送入终端缓冲区的时间小于0.1ms。若采用程序IO方式，CPU约有\n\n99.9ms的时间处于忙一等待中。但采用中断驱动方式后，CPU可利用这99.9ms的时间去 做其它的事情，而仅用0.1ms的时间来处理由控制器发来的中断请求。可见，中断驱动方 式可以成百倍地提高CPU的利用率。\n\n3.直接存储器访问方式 1）接存储器访问方式的引入 虽然中断驱动I/O比程序IVO方式更有效，但它仍是以字(节)为单位进行IO的。每当 完成一个字（节）的I/O时，控制器便要向CPU请求一次中断。换而言之，采用中断驱动I/O 方式时的CPU，是以字（节)为单位进行干预的。如果将这种方式用于块设备的IVO，显然 是极其低效的。例如，为了从磁盘中读出1KB的数据块，需要中断CPU1K次。为了进 一步减少CPU对I/O的干预，而引入了直接存储器访问方式，见图6-13(c)所示。该方式 的特点是：\n\n（1）数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数 据块。\n\n(2）所传送的数据是从设备直接送入内存的，或者相反。\n\n(3）仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是 在控制器的控制下完成的。可见，DMA方式较之中断驱动方式又进一步提高了CPU与I/O 设备的并行操作程度。 2)DMA控制器的组成 DMA控制器由三部分组成：主机与DMA控制器的接口；DMA控制器与块设备的接 口；I/O控制逻辑。图6-14示出了DMA控制器的组成。这里主要介绍主机与控制器之间 的接口。 196  第六章输入输出系统 CPU 内存 主机—控制器接口 控制器与块设备接口 DR 1/0 MAR 控 count 制 DC 逻 辑 CR 命令 系统总线 DMA控制器 图6-14DMA控制器的组成 为了实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中，设置如 下四类寄存器：\n\n（1）命令/状态寄存器CR，用于接收从CPU发来的I/O命令，或有关控制信息，或设 备的状态。\n\n(2）内存地址寄存器MAR，在输入时，它存放把数据从设备传送到内存的起始目标地 址，在输出时，它存放由内存到设备的内存源地址。\n\n（3）数据寄存器DR，用于暂存从设备到内存，或从内存到设备的数据。\n\n(4）数据计数器DC，存放本次CPU要读或写的字(节)数。 3）DMA工作过程 当CPU要从磁盘读入一数据块时，便向磁盘控制器发送一条读命令。该命令被送入命 令寄存器CR中。同时，需要将本次要读入数据在内存的起始目标地址送入内存地址寄存 器MAR中。将要读数据的字（节)数送入数据 计数器DC中。还须将磁盘中的源地址直接送 设置MAR和DC初值 至DMA控制器的I/O控制逻辑上。然后，启 启动DMA传送命令 动DMA控制器进行数据传送。以后，CPU便 1 可去处理其它任务，整个数据传送过程由 挪用存储器周期 传送数据字 DMA控制器进行控制。当DMA控制器已从 在继续执行用户程序 的同时，准备又一次传送 磁盘中读入一个字（节）的数据，并送入数据寄 存储器地址增1 数据计数寄存器减！ 存器DR后，再挪用一个存储器周期，将该字 （节)传送到MAR所指示的内存单元中。然后 否 DC=0? 便对MAR内容加1，将DC内容减1，若减1 是 后DC内容不为O，表示传送未完，便继续传 请求中断 送下一个字(节)：否则，由DMA控制器发出 中断请求。图6-15是DMA方式的工作流程。 图6-15DMA方式的工作流程图\n\n4.VO通道控制方式 1）IO通道控制方式的引入 虽然DMA方式比起中断方式来已经显著地减少了CPU的干预，即已由以字(节)为单 一个连续的数据块。而当我们需要一次去读多个数据块且将它们分别传送到不同的内存区 197  计算机操作系统 域，或者相反时，则须由CPU分别发出多条IVO指令及进行多次中断处理才能完成。 IO通道方式是DMA方式的发展，它可进一步减少CPU的干预，即把对一个数据块 的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干 预。同时，又可实现CPU、通道和IVO设备三者的并行操作，从而更有效地提高整个系统 的资源利用率。例如，当CPU要完成一组相关的读（或写)操作及有关控制时，只需向I/O 通道发送一条IO指令，以给出其所要执行的通道程序的首址和要访问的IO设备，通道 接到该指令后，通过执行通道程序便可完成CPU指定的IVO任务。 2）通道程序 通道是通过执行通道程序并与设备控制器共同实现对IO设备的控制的。通道程序是 由一系列通道指令（或称为通道命令）所构成的。通道指令与一般的机器指令不同，在它的 每条指令中都包含下列诸信息：\n\n（1）操作码，它规定了指令所执行的操作，如读、写、控制等操作。\n\n(2）内存地址，标明字符送入内存(读操作)和从内存取出(写操作)时的内存首址。\n\n（3）计数，表示本条指令所要读（或写）数据的字节数。\n\n（4）通道程序结束位P，用于表示通道程序是否结束。P=1表示本条指令是通道程序的 最后一条指令。\n\n（5）记录结束标志R，R=0表示本通道指令与下一条指令所处理的数据是同属于一个记 录；R=1表示这是处理某记录的最后一条指令。 下面示出了一个由六条通道指令所构成的简单的通道程序。该程序的功能是将内存中 不同地址的数据写成多个记录。其中，前三条指令是分别将813～892单元中的80个字符 操作 P R 计数 内存地址 WRITE 0 0 80 813 WRITE 0 0 140 1034 WRITE 0 1 60 5830 0 1 300 WRITE 2000 WRITE 0 0 50 1650 WRITE 1 1 250 2720\n\n76.5 5与设备无关的I/O软件 为了方便用户和提高OS的可适应性与可扩展性，在现代OS的IVO系统中，都无一例 外地增加了与设备无关的IO软件，以实现设备独立性，也称为设备无关性。其基本含义 备驱动程序是与硬件紧密相关的软件。为了实现设备独立性，必须再在设备驱动程序之上 198"
          }
        ]
      },
      {
        "二级标题": "6.5_与设备无关的IO软件",
        "三级内容": [
          {
            "三级标题": "6.5.1 与设备无关(DeviceIndependence)软件的基本概念",
            "正文": "1.以物理设备名使用设备 在早期OS中，应用程序在使用IVO设备时，都使用设备的物理名称，这使应用程序与 系统中的物理设备直接相关。当应用进程运行时，如果所请求的物理设备（独占设备类型） 已分配给其它进程，而此时尽管还有几台其它的相同设备空闲可用，但系统只能根据设备 的物理名来分配，无法将另外相同的设备(但具有不同的物理设备名)分配给它，致使该应 用进程请求I/O失败而被阻塞。特别是，当应用程序所需要的设备在系统中已经被更新时， 该应用程序将再也无法在该系统上运行。可见，应用程序直接与物理设备相关是非常不灵 活的，给用户带来了很大的不便，且对提高IO设备的利用率也很不利。\n\n2.引入了逻辑设备名 为了实现与设备的无关性而引入了逻辑设备和物理设备两个概念。逻辑设备是抽象的 设备名。如/dev/printer，该设备名只是说明用户需要使用打印机来打印输出，但并没有指 定具体是哪一台打印机。这样，如果在应用程序中，使用逻辑设备名称请求使用某类设备， 系统在对它进行设备分配时，先查找该类设备中的第一台，如它已被分配，系统可立即去 查找该类设备中第二台，若又被分配，系统接着去找第三台，若它尚未分配，便可将这台 设备分配给进程。事实上，只要系统中有一台该类设备未被分配，进程就不会被阻塞。仅 当所请求的此类设备已全部分配完毕时，进程才会因请求失败而阻塞。所以，应用进程就 不会由于某台指定设备退役而无法在本系统上运行。 与设备的无关软件还可实现IVO重定向。所谓I/O重定向，是指用于I/O操作的设备可 以更换（即重定向），而不必改变应用程序。例如，我们在调试一个应用程序时，可将程序 的所有输出送往屏幕显示。而在程序调试完后，若须正式将程序的运行结果打印出来，此 时便须将I/O重定向的数据结构一—逻辑设备表中的显示终端改为打印机即可，而不必修 改应用程序。I/O重定向功能具有很大的实用价值，现已被广泛地引入到各类OS中。\n\n3.逻辑设备名称到物理设备名称的转换 在应用程序中，用逻辑设备名称使用设备虽然方便了用户，但系统却只识别物理设备 名称，因此在实际执行时，还必须使用物理名称。为此，在系统中，必须具有将逻辑设备 名称转换为某物理设备名称的功能。关于逻辑设备名称和物理设备名称的概念，与存储器 管理中所介绍的逻辑地址和物理地址的概念非常类似，在应用程序中所使用的是逻辑地址， 而系统在分配和使用内存时，必须使用物理地址。在程序执行时，必须先将逻辑地址转换 为物理地址。类似地，为实现从逻辑设备名称和物理设备名称，在系统中需要配置一张逻 辑设备表。转换的详细情况将在后面介绍。"
          },
          {
            "三级标题": "6.5.2 与设备无关的软件 一 与设备无关的软件是I/O系统的最高层软件，在它下面的是设备驱动程序，其间的界 限，因操作系统和设备的不同而有所差异。比如，对于一些本应由设备独立性软件实现的 功能，却放在设备驱动程序中实现。这样的差异主要是出于对操作系统、设备独立性和设 199  计算机操作系统 备驱动程序运行效率等多方面因素的权衡和考虑。总的来说，在与设备无关的软件中，包 括了执行所有设备公有操作的软件，具体有如下几项。",
            "正文": "1.设备驱动程序的统一接口 为了使所有的设备驱动程序有着统一的接口，一方面，要求每个设备驱动程序与OS 之间都有着相同的接口，或者相近的接口，这样会使添加一个新的设备驱动程序变得很容 易，同时在很大程度上方便了开发人员对设备驱动程序的编制。另一方面，要将抽象的设 备名映射到适当的驱动程序上，或者说，将抽象的设备名转换为具体的物理设备名，并进 一步可以找到相应物理设备的驱动程序入口。此外，还应对设备进行保护，禁止用户直接 访问设备，以防止无权访问的用户使用。\n\n2.缓冲管理 无论是字符设备还是块设备，它们的运行速度都远低于CPU的速度。为了缓和CPU 和IVO设备之间的矛盾、提高CPU的利用率，在现代OS中都无一例外地分别为字符设备 和块设备配置了相应的缓冲区。缓冲区有着多种形式，如单缓冲区、双缓冲区、循环缓冲 区、公用缓冲池等，以满足不同情况的需要。由于这部分的内容较多，故我们将它作为独 立的一节，在6.7节中对它进行详细介绍。\n\n3.差错控制 由于设备中有着许多的机械和电气部分，因此，它们比主机更容易出现故障，这就导 致I/O操作中的绝大多数错误都与设备有关。错误可分为如下两类：\n\n（1）暂时性错误。暂时性错误是因发生暂时性事件引起的，如电源的波动。它可以通 过重试操作来纠正。例如，在网络传输中，由于传输路途较远、缓冲区数量暂时不足等因 素，会经常发生在网络中传输的数据包丢失或延误性的暂时性错误。当网络传输软件检测 到这种情况后，可以通过重新传送来纠正错误。又如，当磁盘传送发生错误后，开始驱动 程序并不立即认为传送出错，而是令磁盘重传，只有连续多次（如10次）出错，才认为磁盘 出错，并向上层报告。一般地，设备出现故障后，主要由设备驱动程序处理，而设备独立 性软件只处理那些设备驱动程序无法处理的错误。\n\n(2）持久性错误。持久性错误是由持久性故障引起的，如电源掉电、磁盘上有一条划 痕或者在计算中发生除以零的情况等。持久性错误容易发现，有些错误是只要重复执行相 同的程序就会再现的错误。要排除持久性错误，通常需要查清发生错误的原因。但也有某 些持久性硬件错误可由操作系统进行有效的处理，而不用涉及高层软件。如磁盘上的少数 盘块遭到破坏而失效，此时无需更换磁盘，而只需将它们作为坏的盘块记录下来，并放入 一张坏盘块表中，以后不再使用这些坏块即可。\n\n4.对独立设备的分配与回收 在系统中有两类设备：独占设备和共享设备。对于独占设备，为了避免诸进程对独占 设备的争夺，必须由系统来统一分配，不允许进程自行使用。每当进程需要使用某（独占） 设备时，必须先提出申请。OS接到对设备的请求后，先对进程所请求的独占设备进行检查， 看该设备是否空闲。若空闲，才把该设备分配给请求进程。否则，进程将被阻塞，放入该 设备的请求队列中等待。等到其它进程释放该设备时，再将队列中的第一个进程唤醒，该 进程得到设备后继续运行。 200  第六章输入输出系统\n\n5.独立于设备的逻辑数据块 不同类型的设备，其数据交换单位是不同的，读 设备驱动程序的统一接口 取和传输速率也各不相同，如字符型设备以单个字符 缓冲 （字）为单位，块设备是以一个数据块为单位。即使同 一类型的设备，其数据交换单位的大小也是有差异的， 错误报告 如不同磁盘由于扇区大小的不同，可能造成数据块大 分配与释放专用设备 小的不一致。设备独立性软件应能够隐藏这些差异而 提供与设备无关的块大小 被逻辑设备使用，并向高层软件提供大小统一的逻辑 数据块。与设备无关软件的功能如图6-16所示。 图6-16与设备无关软件的功能层次"
          },
          {
            "三级标题": "6.5.3 设备分配 一一→ 系统为实现对独占设备的分配，必须在系统中配置相应的数据结构。",
            "正文": "1.设备分配中的数据结构 在用于设备分配的数据结构中，记录了对设备或控制器进行控制所需的信息。在进行 设备分配时需要如下的数据结构。 1）设备控制表DCT 系统为每一个设备都配置了一张设备控制表，用于记录设备的情况，如图6-17所示。 DCT1 设备类型：type 设 备 设备标识符：deviceid 控 设备状态：等待/不等待忙/闲 制 DCT2 表 指向控制器表的指针 集 合 重复执行次数或时间 设备队列的队首指针 DCTn 图6-17设备控制表 设备控制表中，除了有用于指示设备类型的字段type和设备标识字段deviceid外，还 应含有下列字段：\n\n（1）设备队列队首指针，凡因请求本设备而未得到满足的进程，应将其PCB按照一定 的策略排成一个设备请求队列，其队首指针指向队首PCB；\n\n（2）忙闲标志，用于表示当前设备的状态是忙或闲；\n\n（3）与设备连接的控制器表指针，该指针指向该设备所连接的控制器的控制表；\n\n（4）重复执行次数，由于外部设备在传送数据时较易发生数据传送错误，因而在许多 系统中规定了设备在工作中发生错误时应重复执行的次数，在重复执行时，若能恢复正常 传送，则仍认为传送成功，仅当重复执行次数达到规定值仍不成功时，才认为传送失败。 2）控制器控制表、通道控制表和系统设备表\n\n（1）控制器控制表（COCT）。系统为每一个控制器都设置了用于记录控制器情况的控制 201  计算机操作系统 器控制表，如图6-18（a)所示。\n\n(2）通道控制表（CHCT)。每个通道都有一张通道控制表，如图6-18(b）所示。\n\n(3）系统设备表（SDT)。这是系统范围的数据结构，记录了系统中全部设备的情况，每 个设备占一个表目，其中包括有设备类型、设备标识符、设备控制表及设备驱动程序的入 口等项，如图6-18(c)所示。 控制器标识符：controllerid 表目1 通道标识符：channelid 控制器状态：忙/闲 通道状态：忙/闲 设备类 与控制器连接的通道表指针 与通道连接的控制器表首址 设备标识符 表目 控制器队列的队首指针 通道队列的队首指针 DCT 控制器队列的队尾指针 通道队列的队尾指针 ： 驱动程序入口 （a)控制器控制表（COCT） (b)通道控制表（CHCT) (c)系统设备表(SDT) 图6-18COCT、CHCT 和SDT表\n\n2.设备分配时应考虑的因素 系统在分配设备时，应考虑如下几个因素： 1）设备的固有属性 设备的固有属性可分成三种，对它们应采取不同的分配策略：\n\n(1）独占设备的分配策略。将一个设备分配给某进程后，便由该进程独占，直至该进 程完成或释放该设备。\n\n(2）共享设备的分配策略。对于共享设备，可同时分配给多个进程使用，此时须注意 对这些进程访问该设备的先后次序进行合理的调度。\n\n（3）虚拟设备的分配策略，虚拟设备属于可共享的设备，可以将它同时分配给多个进 程使用。 2）设备分配算法 对设备分配的算法，通常只采用以下两种分配算法：\n\n（1）先来先服务。该算法是根据诸进程对某设备提出请求的先后次序，将这些进程排 成一个设备请求队列，设备分配程序总是把设备首先分配给队首进程。\n\n（2）优先级高者优先。在利用该算法形成设备队列时，将优先级高的进程排在设备队 列前面，而对于优先级相同的IVO请求，则按先来先服务原则排队。 3）设备分配中的安全性 从进程运行的安全性上考虑，设备分配有以下两种方式：\n\n（1）安全分配方式。每当进程发出IVO请求后，便进入阻塞状态，直到其IO操作完成 时才被唤醒。在采用该策略时，一旦进程已经获得某种设备后便阻塞，不能再请求任何资 源，而在它阻塞时又不保持任何资源。因此，摒弃了造成死锁的四个必要条件之一的“请 求和保持”条件，故设备分配是安全的。其缺点是CPU与IVO设备是顺序工作的。\n\n(2）不安全分配方式。在这种分配方式中，进程在发出IVO请求后仍继续运行，需要时 又发出第二个I/O请求、第三个IVO请求等。仅当进程所请求的设备已被另一进程占用时， 才进入阻塞状态。该策略的优点是，一个进程可同时操作多个设备，使进程推进迅速。其 202  第六章输入输出系统 缺点是分配不安全，因为它可能具备“请求和保持”条件，从而可能造成死锁。因此，在 明分配是安全的情况下，才进行设备分配。\n\n3.独占设备的分配程序 1）基本的设备分配程序 我们通过一个例子来介绍设备分配过程。当某进程提出I/O请求后，系统的设备分配 程序可按下述步骤进行设备分配：\n\n（1）分配设备。首先根据IVO请求中的物理设备名查找系统设备表SDT，从中找出该 设备的DCT，再根据DCT中的设备状态字段，可知该设备是否正忙。若忙，便将请求I/O 的进程的PCB挂在设备队列上；否则，便按照一定的算法，计算本次设备分配的安全性。 如果不会导致系统进入不安全状态，便将设备分配给请求进程；否则，仍将其PCB插入设 备等待队列。\n\n（2）分配控制器。在系统把设备分配给请求IVO的进程后，再到其DCT中找出与该设 备连接的控制器的COCT，从COCT的状态字段中可知该控制器是否忙碌。若忙，便将请 求IO进程的PCB，挂在该控制器的等待队列上。否则，便将该控制器分配给进程。\n\n（3）分配通道。在该COCT中又可找到与该控制器连接的通道的CHCT，再根据CHCT 内的状态信息可知该通道是否忙碌。若忙，便将请求I/O的进程挂在该通道的等待队列上； 否则，将该通道分配给进程。只有在设备、控制器和通道三者都分配成功时，这次的设备 分配才算成功。然后，便可启动该I/O设备进行数据传送。 2）设备分配程序的改进 在上面的例子中，进程是以物理设备名提出IO请求的。如果所指定的设备已分配给 其它进程，则分配失败。或者说上面的设备分配程序不具有与设备无关性。为获得设备的 独立性，进程应使用逻辑设备名请求IVO。这样，系统首先从SDT中找出第一个该类设备 的DCT。若该设备忙，又查找第二个该类设备的DCT，仅当所有该类设备都忙时，才把进 程挂在该类设备的等待队列上。而只要有一个该类设备可用，系统便进一步计算分配该设 备的安全性。如安全，便可把设备分配给它。"
          },
          {
            "三级标题": "6.5.4 逻辑设备名到物理设备名映射的实现 为了实现与设备的无关性，当应用程序请求使用IO设备时，应当用逻辑设备名。但 系统只识别物理设备名，因此在系统中需要配置一张逻辑设备表，用于将逻辑设备名映射 为物理设备名。",
            "正文": "1.逻辑设备表LUT（LogicalUnitTable) 在逻辑设备表的每个表目中包含了三项：逻辑设备名、物理设备名和设备驱动程序的 入口地址，如图6-19（a）所示。当进程用逻辑设备名请求分配IVO设备时，系统根据当时的 具体情况，为它分配一台相应的物理设备。与此同时，在逻辑设备表上建立一个表目，填 上应用程序中使用的逻辑设备名和系统分配的物理设备名，以及该设备驱动程序的入口地 址。当以后进程再利用该逻辑设备名请求IVO操作时，系统通过查找LUT，便可找到该逻 辑设备所对应的物理设备和该设备的驱动程序。 203  计算机操作系统 驱动程序 逻辑设备名 物理设备名 逻辑设备名 系统设备表指针 入口地址 /dev/tty 1024 /dev/tty 3 /dev/printer 5 2046 /dev/printer 5 ： (a)表一 (b)表二 图6-19逻辑设备表\n\n2.逻辑设备表的设置问题 在系统中可采取两种方式设置逻辑设备表： 第一种方式，是在整个系统中只设置一张LUT。由于系统中所有进程的设备分配情况 都记录在同一张LUT中，因而不允许在LUT中具有相同的逻辑设备名，这就要求所有用 户都不使用相同的逻辑设备名。在多用户环境下这通常是难以做到的，因而这种方式主要 用于单用户系统中。 第二种方式，是为每个用户设置一张LUT。每当用户登录时，系统便为该用户建立一 个进程，同时也为之建立一张LUT，并将该表放入进程的PCB中。由于通常在多用户系统 中都配置了系统设备表，故此时的逻辑设备表可以采用图6-19(b)中的格式。 用户层的I/O软件\n\n6.6 一般而言，大部分的I/O软件都放在操作系统内部，但仍有一小部分在用户层，其中 包括与用户程序链接在一起的库函数，以及完全运行于内核之外的假脱机系统等。"
          },
          {
            "三级标题": "6.6.1 系统调用与库函数",
            "正文": "1.系统调用 一方面，为使诸进程能有条不素地使用IO设备，且能保护设备的安全性，不允许运 行在用户态的应用进程去直接调用运行在核心态(系统态)的OS过程。但另一方面，应用进 程在运行时，又必须取得OS所提供的服务，否则，应用程序几乎无法运行。为了解决此 矛盾，OS在用户层中引I入了一个中介过程一系统调用，应用程序可以通过它间接调用 OS中的IO过程，对IO设备进行操作。 系统中会有许多系统调用，它们的实现方法 用户态 内核态 是基本相同的。下面简单说明系统调用的执行过 用户程序 程。当应用程序需要执行某种IVO操作时，在应 系统调用 系统调用 用程序中必须使用相应的系统调用。当OS捕获 调用 命令 到应用程序中的该系统调用后，便将CPU的状 态从用户态转换到核心态，然后转向操作系统中 相应过程，由该过程完成所需的IO操作。执行 返回 完成后，系统又将CPU状态从核心态转换到用 户态，返回到应用程序继续执行。图6-20示出 图6-20系统调用的执行过程 204"
          }
        ]
      },
      {
        "二级标题": "6.6_用户层的IO软件",
        "三级内容": [
          {
            "三级标题": "6.6.1 系统调用与库函数",
            "正文": "1.系统调用 一方面，为使诸进程能有条不素地使用IO设备，且能保护设备的安全性，不允许运 行在用户态的应用进程去直接调用运行在核心态(系统态)的OS过程。但另一方面，应用进 程在运行时，又必须取得OS所提供的服务，否则，应用程序几乎无法运行。为了解决此 矛盾，OS在用户层中引I入了一个中介过程一系统调用，应用程序可以通过它间接调用 OS中的IO过程，对IO设备进行操作。 系统中会有许多系统调用，它们的实现方法 用户态 内核态 是基本相同的。下面简单说明系统调用的执行过 用户程序 程。当应用程序需要执行某种IVO操作时，在应 系统调用 系统调用 用程序中必须使用相应的系统调用。当OS捕获 调用 命令 到应用程序中的该系统调用后，便将CPU的状 态从用户态转换到核心态，然后转向操作系统中 相应过程，由该过程完成所需的IO操作。执行 返回 完成后，系统又将CPU状态从核心态转换到用 户态，返回到应用程序继续执行。图6-20示出 图6-20系统调用的执行过程 204  第六章输入输出系统 了系统调用的执行过程。 事实上，由OS向用户提供的所有功能，用户进程都必须通过系统调用来获取，或者 说，系统调用是应用程序取得OS所有服务的唯一途径。在早期的操作中，系统调用是以 汇编语言形式提供的，所以只有在用汇编语言编写的程序中，才能直接使用系统调用，这 对用户是非常不方便的，后来在C语言中，首先提供了与系统调用相对应的库函数。\n\n2.库函数 在C语言以及UNIX系统中，系统调用(如read)与各系统调用所使用的库函数(如read) 之间几乎是一一对应的。而微软定义了一套过程，称为Win32API的应用程序接口 （ApplicationProgramInterface），程序员利用它们取得Os服务，该接口与实际的系统调用 并不一一对应。用户程序通过调用对应的库函数使用系统调用，这些库函数与调用程序连 接在一起，被嵌入在运行时装入内存的二进制程序中。 在C语言中提供了多种类型的库函数，对于IVO方面，主要是对文件和设备进行读/ 写的库函数，以及控制/检查设备状态的库函数。显然这些库函数的集合也应是I/O系统的 组成部分。而且我们可以这样来看待内核和库函数之间的关系：内核提供了OS的基本功 能，而库函数扩展了OS内核，使用户能方便取得操作系统的服务。在许多现代OS中，系 统调用本身已经采用C语言编写，并以函数形式提供，所以在使用C语言编写的用户程序 中，可以直接使用这些系统调用。 另外，操作系统在用户层中还提供了一些非常有用的程序，如下面将要介绍的假脱机 系统，以及在网络传输文件时常使用的守护进程等，它们是运行在内核之外的程序，但它 们仍属于IO系统。"
          },
          {
            "三级标题": "6.6.2 假脱机（Spooling）系统 ← 如果说，通过多道程序技术可将一台物理CPU虚拟为多台逻辑CPU，从而允许多个 用户共享一台主机，那么，通过假脱机技术，则可将一台物理IO设备虚拟为多台逻辑I/O 设备，这样也就允许多个用户共享一台物理I/O设备。",
            "正文": "1.假脱机技术 在20世纪50年代，为了缓和CPU的高速性与IVO设备低速性间的矛盾，而引I入了脱 机输入、脱机输出技术。该技术是利用专门的外围控制机，先将低速IO设备上的数据传 送到高速磁盘上，或者相反。这样当处理机需要输入数据时，便可以直接从磁盘中读取数 据，极大地提高了输入速度。反之，在处理机需要输出数据时，也可以很快的速度把数据 先输出到磁盘上，处理机便可去做自己的事情。 事实上，当系统中引入了多道程序技术后，完全可以利用其中的一道程序，来模拟脱 机输入时的外围控制机功能，把低速IVO设备上的数据传送到高速磁盘上。再用另一道程 序模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。这样，便可 在主机的直接控制下，实现以前的脱机输入、输出功能。此时的外围操作与CPU对数据的 处理同时进行，我们把这种在联机情况下实现的同时外围操作的技术称为SPOOLing (SimultaneausPeriphernalOperatingOnLine）技术，或称为假脱机技术。 205  计算机操作系统\n\n2.SPOOLing的组成 如前所述，SPOOLing技术是对脱机输入/输出系统的模拟，相应地，如图6-21(a)所示， SPOOLing系统建立在通道技术和多道程序技术的基础上，以高速随机外存（通常为磁盘） 为后援存储器。SPOOLing的工作原理如图6-21(b)所示。 输入井 输入设备1 输出设备1 通 道 道 输入设备n 输出设备n 输出井 通道 输入进程 主机 输出进程 (a)SPOOLing系统的组成 输入进程 作业1输入 输入 输入 输入设备 缓冲区1 缓冲区2 作业n输入 井管理 内存 内存 程序 输 作业1输出 输出 输出 输出设备 .*. 缓冲区1 缓冲区2 作业n输出 运行的作业 输出进程 (a)SPOOLing的工作原理 假脱机 文件队列 口□口 空盘块队列 □□□□ 共享打印机 打印缓冲区 满盘块队列 假脱机 内存 打印进程 假脱机 硬盘 管理进程 ()假脱机打印机系统的组成 图6-21SPOOLing系统组成及工作原理 SPOOLing系统主要由以下四部分构成： 206  第六章输入输出系统\n\n(1）输入井和输出井。这是在磁盘上开辟出来的两个存储区域。输入井模拟脱机输入 时的磁盘，用于收容I/O设备输入的数据。输出井模拟脱机输出时的磁盘，用于收容用户 程序的输出数据。输入/输出井中的数据一般以文件的形式组织管理，我们把这些文件称为 井文件。一个文件仅存放某一个进程的输入(或者输出)数据，所有进程的数据输入(或输出) 文件链接成为一个输入（或输出）队列。 盘之间速度不匹配的矛盾。输入缓冲区用于暂存由输入设备传送的数据，之后再传送到输 入井。输出缓冲区用于暂存从输出井传送的数据，之后再传送到输出设备。\n\n（3）输入进程和输出进程。输入进程也称为预输入进程，用于模拟脱机输入时的外围 控制机，将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井。当CPU需要 输入设备时，直接从输入井读入内存。输出进程也称为缓输出进程，用于模拟脱机输出时 的外围控制机，把用户要求输入的数据从内存传送并存放到输出井，待输出设备空闲时， 再将输出井中的数据经过输出缓冲区输出至输出设备上。\n\n（4）井管理程序。用于控制作业与磁盘井之间信息的交换。当作业执行过程中向某台 设备发出启动输入或输出操作请求时，由操作系统调用井管理程序，由其控制从输入井读 取信息或将信息输出至输出井。\n\n3.SPOOLing系统的特点\n\n（1）提高了I/O的速度。这里，对数据所执行的IVO操作，已从对低速I/O设备执行的 I/O操作演变为对磁盘缓冲区中数据的存取，如同脱机输入输出一样，提高了I/O速度，缓 和了CPU与低速I/O设备之间速度不匹配的矛盾。\n\n（2）将独占设备改造为共享设备。因为在假脱机打印机系统中，实际上并没为任何进 程分配设备，而只是在磁盘缓冲区中为进程分配一个空闲盘块和建立一张IVO请求表。这 样，便把独占设备改造为共享设备。\n\n(3）实现了虚拟设备功能。宏观上，虽然是多个进程在同时使用一台独占设备，而对 于每一个进程而言，它们都会认为自己是独占了一个设备。当然，该设备只是逻辑上的设 备。假脱机打印机系统实现了将独占设备变换为若干台对应的逻辑设备的功能。\n\n4.假脱机打印机系统 打印机是经常用到的输出设备，属于独占设备。利用假脱机技术可将它改造为一台可 供多个用户共享的打印设备，从而提高设备的利用率，也方便了用户。共享打印机技术已 被广泛地用于多用户系统和局域网络中。假脱机打印系统主要有以下三部分：\n\n（1）磁盘缓冲区。它是在磁盘上开辟的一个存储空间，用于暂存用户程序的输出数据， 在该缓冲区中可以设置几个盘块队列，如空盘块队列、满盘块队列等。\n\n(2）打印缓冲区。用于缓和CPU和磁盘之间速度不匹配的矛盾，设置在内存中，暂存 从磁盘缓冲区送来的数据，以后再传送给打印设备进行打印。 据建立一个假脱机文件，并把它放入假脱机文件队列中，由假脱机打印进程依次对队列中 的文件进行打印。 图6-21（c)示出了假脱机打印机系统的组成。 207  计算机操作系统 每当用户进程发出打印输出请求时，假脱机打印机系统并不是立即把打印机分配给该 用户进程，而是由假脱机管理进程完成两项工作：①在磁盘缓冲区中为之申请一个空闲盘 块，并将要打印的数据送入其中暂存；②为用户进程申请一张空白的用户请求打印表，并 将用户的打印要求填入其中，再将该表挂到假脱机文件队列上。在这两项工作完成后，虽 然还没有进行任何实际的打印输出，但对于用户进程而言，其打印请求已经得到满足，打 印输出任务已经完成。 真正的打印输出是假脱机打印进程负责的，当打印机空闲时，该进程首先从假脱机文 内存缓冲区，再交付打印机进行打印。一个打印任务完成后，假脱机打印进程将再次查看 假脱机文件队列，若队列非空，则重复上述的工作，直至队列为空。此后，假脱机打印进 程将自己阻塞起来，仅当再次有打印请求时，才被重新唤醒运行。 由此可见，利用假脱机系统向用户提供共享打印机的概念是：对每个用户而言，系统 并非即时执行其程序输出数据的真实打印操作，而只是即时将数据输出到缓冲区，这时的 数据并未真正被打印，只是让用户感觉系统已为他打印；真正的打印操作，是在打印机空 一个时间片，没有使用专门的外围机；以上的过程是对用户屏蔽的，用户是不可见的。\n\n5.守护进程（daemon） 前面是利用假脱机系统来实现打印机共享的一种方案，人们对该方案进行了某些修改， 如取消该方案中的假脱机管理进程，为打印机建立一个守护进程，由它执行一部分原来由 假脱机管理进程实现的功能，如为用户在磁盘缓冲区中申请一个空闲盘块，并将要打印的 数据送入其中，将该盘块的首址返回给请求进程。另一部分由请求进程自己完成，每个要 求打印的进程首先生成一份要求打印的文件，其中包含对打印的要求和指向装有打印输出 数据盘块的指针等信息，然后将用户请求打印文件放入假脱机文件队列（目录）中。 守护进程是允许使用打印机的唯一进程。所有需要使用打印机进行打印的进程都需将 一份要求打印的文件放在假脱机文件队列（目录）中。如果守护进程正在睡眠，便将它唤醒， 由它按照目录中第一个文件中的说明进行打印，打印完成后，再按照目录中第二个文件中 的说明进行打印，如此逐份文件地进行打印，直到目录中的全部文件打印完毕，守护进程 无事可做，又去睡眠。等待用户进程再次发来打印请求。 除了打印机守护进程之外，还可能有许多其它的守护进程，如服务器守护进程和网络 守护进程等。事实上，凡是需要将独占设备改造为可供多个进程共享的设备时，都要为该 设备配置一个守护进程和一个假脱机文件队列（目录）。同样，守护进程是允许使用该独占 设备的唯一进程，所有其它进程都不能直接使用该设备，只能将对该设备的使用要求写入 一份文件中，放在假脱机目录中。由守护进程按照目录中的文件依次来完成诸进程对该设 备的请求，这样就把一台独占设备改造为可为多个进程共享的设备。\n\n6.7缓冲区管理 在现代操作系统中，几乎所有的IVO设备在与处理机交换数据时都用了缓冲区。缓冲 208"
          }
        ]
      },
      {
        "二级标题": "6.7_缓冲区管理",
        "三级内容": [
          {
            "三级标题": "6.7.1 缓冲的引入 -→ 引入缓冲区的原因有很多，可归结为以下几点：",
            "正文": "（1）缓和CPU与I/O设备间速度不匹配的矛盾。 事实上，凡在数据到达速率与其离去速率不同的地方，都可设置缓冲区，以缓和它们 之间速率不匹配的矛盾。众所周知，CPU的运算速率远远高于I/O设备的速率，如果没有 缓冲区，在输出数据时，必然会由于打印机的速度跟不上，而使CPU停下来等待；然而在 计算阶段，打印机又空闲无事。如果在打印机或控制器中设置一缓冲区，用于快速暂存程 序的输出数据，以后由打印机“慢慢地”从中取出数据打印，这样，就可提高CPU的工作 效率。类似地，在输入设备与CPU之间设置缓冲区，也可使CPU的工作效率得以提高。\n\n(2）减少对CPU的中断频率，放宽对CPU中断响应时间的限制。 在远程通信系统中，如果从远地终端发来的数据仅用一位缓冲来接收，如图6-22（a）所 示，则必须在每收到一位数据时便中断一次CPU，这样，对于速率为9.6kb/s的数据通信 来说，就意味着其中断CPU的频率也为9.6kb/s，即每100us就要中断CPU一次，而且 CPU必须在100us内予以响应，否则缓冲区内的数据将被冲掉。倘若设置一个具有8位的 缓冲（移位)寄存器，如图6-22(b)所示，则可使CPU被中断的频率降低为原来的1/8：若再 设置一个8位寄存器，如图6-22（c）所示，则又可把CPU对中断的响应时间从100us放宽 到800μus。类似地，在磁盘控制器和磁带控制器中，都需要配置缓冲寄存器，以减少对CPU 的中断频率，放宽对CPU中断响应时间的限制。随着传输速率的提高，需要配置位数更多 的寄存器进行缓冲。 (a) 8位缓冲寄存器 (b) 送内存 8位缓冲寄存器 (#) 智送内存 图6-22利用缓冲寄存器实现缓冲\n\n(3）解决数据粒度不匹配的问题。 缓冲区可用于解决在生产者和消费者之间交换的数据粒度(数据单元大小)不匹配的问 题。例如，生产者所生产的数据粒度比消费者消费的数据粒度小时，生产者进程可以一连 生产好几个数据单元的数据，当其总和已达到消费者进程所要求的数据单元大小时，消费 209  计算机操作系统 者便可从缓冲区中取出消费。反之，如果生产者所生产的数据粒度比消费者消费的数据粒 度大时，生产者每次生产的数据消费者可以分几次从缓冲区中取出消费。\n\n（4）提高CPU和I/O设备之间的并行性。 设备的利用率。例如，在CPU（生产者）和打印机（消费者）之间设置了缓冲区后，生产者在生 产了一批数据并将它放入缓冲区后，便可立即去进行下一次的生产。与此同时，消费者可 以从缓冲区中取出数据消费，这样便可使CPU与打印机处于并行工作状态。"
          },
          {
            "三级标题": "6.7.2 单缓冲区和双缓冲区 如果在生产者与消费者之间未设置任何缓冲，生产者与消费者之间在时间上会相互限 制。例如，生产者已经完成了数据的生产，但消费者尚未准备好接收，生产者无法把所生 产的数据交付给消费者，此时生产者必须暂停等待，直到消费者就绪。如果在生产者与消 费者之间设置了一个缓冲区，则生产者无需等待消费者就绪，便可把数据输出到缓冲区。",
            "正文": "1.单缓冲区（SingleBuffer) 在单缓冲情况下，每当用户进程发出一I/O请求时，操作系统便在主存中为之分配一 缓冲区，如图6-23所示。在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为 T，OS将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理（计算） 的时间为C。由于T和C是可以并行的（见图6-23)，当T>C时，系统对每一块数据的处 理时间为M+T；反之则为M+C，敌可把系统对每一块数据的处理时间表示为Max（C，T)+M。 用户进程 处理(C) 传送(M) 输入(T) (a) 工作区」 缓冲区 VO设备 T1 T2 T (b) M M M C 图6-23单缓冲工作示意图 在字符设备输入时，缓冲区用于暂存用户输入的一行数据，在输入期间，用户进程被 挂起以等待数据输入完毕；在输出时，用户进程将一行数据输入到缓冲区后继续进行处理。 当用户进程已有第二行数据输出时，如果第一行数据尚未被提取完毕，则此时用户进程应 阻塞。\n\n2.双缓冲区（DoubleBuffer) 由于缓冲区是共享资源，生产者与消费者在使用缓冲区时必须互斥。如果消费者尚未 取走缓冲区中的数据，即使生产者又生产出新的数据，也无法将它送入缓冲区，生产者等 待。如果为生产者与消费者设置了两个缓冲区，便能解决这一问题。 210  第六章：输入输出系统 为了加快输入和输出速度，提高设备利用率，人们又引入了双缓冲区机制，也称为缓 冲对换(BufferSwapping)。在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓 冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程（见图6-24)。接着由 CPU对数据进行计算。在双缓冲时，系统处理一块数据的时间可以粗略地认为是Max(C,T)， 如果C<T，可使块设备连续输入；如果C>T，则可使CPU不必等待设备输入。对于字符 设备，若采用行输入方式，则采用双缓冲通常能消除用户的等待时间，即用户在输入完第 一行后，在CPU执行第一行中的命令时，用户可继续向第二缓冲区输入下一行数据。 用户进程 缓冲区1 工作区 二I/O设备 (a) 缓冲区2 缓冲1 缓冲2 缓冲3 缓冲4 T T2 T, T (b) M2 M C C2 图6-24双缓冲工作示意图 如果在实现两台机器之间的通信时仅为它们配置了单缓冲，如图6-25（a)所示，那么， 它们之间在任一时刻都只能实现单方向的数据传输。例如，只允许把数据从A传送到B， 或者从B传送到A，而绝不允许双方同时向对方发送数据。为了实现双向数据传输，必须 在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另一个用作接收缓冲区，如图 6-25(b)所示。 A机 B机 A机 B机 接收 发送 缓冲区 缓冲区 缓冲区 缓冲区 接收 发送 缓冲区 缓冲区 (a)单缓冲 (b)双缓冲 图6-25双机通信时缓冲区的设置"
          },
          {
            "三级标题": "6.7.3 环形缓冲区 当输入与输出的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消 费者基本上能并行操作。但若两者的速度相差甚远，双缓冲的效果则不够理想，不过可以 随着缓冲区数量的增加，使情况有所改善。因此，又引入了多缓冲机制，可将多个缓冲区 组织成环形缓冲区形式。",
            "正文": "1.环形缓冲区的组成\n\n(1）多个缓冲区。在环形缓冲中包括多个缓冲区，其每个缓冲区的大小相同。作为输 211  计算机操作系统 入的多缓冲区可分为三种类型：用于装输入数据的空缓冲区R、已装满数据的缓冲区G以 及计算进程正在使用的现行工作缓冲区C，如图6-26所示。 Nexti ↓I Nexti R R -G 21R G 2R G 3IGK G5 curren Nextg G G Nextg 图6-26环形缓冲区\n\n（2）多个指针。作为输入的缓冲区可设置三个指针：用于指示计算进程下一个可用缓 冲区G的指针Nextg、指示输入进程下次可用的空缓冲区R的指针Nexti，以及用于指示计 算进程正在使用的缓冲区C的指针Current。\n\n2.环形缓冲区的使用 计算进程和输入进程可利用下述两个过程来使用形环缓冲区。\n\n（1）Getbuf过程。当计算进程要使用缓冲区中的数据时，可调用Getbuf过程。该过程 将由指针Nextg所指示的缓冲区提供给进程使用，相应地，须把它改为现行工作缓冲区， 并令Current指针指向该缓冲区的第一个单元，同时将Nextg移向下一个G缓冲区。类似 地，每当输入进程要使用空缓冲区来装入数据时，也调用Getbuf过程，由该过程将指针 Nexti所指示的缓冲区提供给输入进程使用，同时将Nexti指针移向下一个R缓冲区。\n\n(2）Releasebuf过程。当计算进程把C缓冲区中的数据提取完毕时，便调用Releasebuf 过程，将缓冲区C释放。此时，把该缓冲区由当前（现行）工作缓冲区C改为空缓冲区R。 类似地，当输入进程把缓冲区装满时，也应调用Releasebuf过程，将该缓冲区释放，并改 为G缓冲区。\n\n3.进程之间的同步问题 使用输入循环缓冲，可使输入进程和计算进程并行执行。相应地，指针Nexti和指针 Nextg将不断地沿着顺时针方向移动，这样就可能出现下述两种情况：\n\n(1）Nexti指针追赶上Nextg指针。这意味着输入进程输入数据的速度大于计算进程处 理数据的速度，已把全部可用的空缓冲区装满，再无缓冲区可用。此时，输入进程应阻塞， 直到计算进程把某个缓冲区中的数据全部提取完，使之成为空缓冲区R，并调用Releasebuf 过程将它释放时，才将输入进程唤醒。这种情况被称为系统受计算限制。\n\n(2）Nextg指针追赶上Nexti指针。这意味着输入数据的速度低于计算进程处理数据的 速度，使全部装有输入数据的缓冲区都被抽空，再无装有数据的缓冲区供计算进程提取数 据。这时，计算进程只能阻塞，直至输入进程又装满某个缓冲区，并调用Releasebuf过程 将它释放时，才去唤醒计算进程。这种情况被称为系统受IO限制。 212  第六章输入输出系统"
          },
          {
            "三级标题": "6.7.4 缓冲池(BufferPool) 上述的缓冲区是专门为特定的生产者和消费者设置的，它们属于专用缓冲。当系统较 大时，应该有许多这样的循环缓冲，这不仅要消耗大量的内存空间，而且其利用率不高。 为了提高缓冲区的利用率，目前广泛流行既可用于输入又可用于输出的公用缓冲池，在池 中设置了多个可供若干个进程共享的缓冲区。缓冲池与缓冲区的区别在于：缓冲区仅仅是 一组内存块的链表，而缓冲池则是包含了一个管理的数据结构及一组操作函数的管理机制， 用于管理多个缓冲区。",
            "正文": "1.缓冲池的组成 据的缓冲体两部分组成。缓冲首部一般包括缓冲区号、设备号、设备上的数据块号、同步 信号量以及队列链接指针等。为了管理上的方便，一般将缓冲池中具有相同类型的缓冲区 链接成一个队列，于是可形成以下三个队列： 针L(emq)分别指向该队列的首缓冲区和尾缓冲区。\n\n(2）输入队列inq。这是由装满输入数据的缓冲区所链成的队列。其队首指针F(inq)和 队尾指针L（inq）分别指向输入队列的队首和队尾缓冲区。\n\n(3）输出队列outq。这是由装满输出数据的缓冲区所链成的队列。其队首指针F(outq) 和队尾指针L（outq)分别指向该队列的首、尾缓冲区。 除了上述三个队列外，还应具有四种工作缓冲区：用于收容输入数据的工作缓冲区、 用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区，以及用于提取输出数 据的工作缓冲区。\n\n2.Getbuf过程和Putbuf过程 在数据结构课程中，曾介绍过队列和对队列进行操作的两个过程，第一个是 Addbuf(type，number)过程。该过程用于将由参数number所指示的缓冲区B挂在type队列 上。第二个是Takebuf(type)过程。它用于从type所指示的队列的队首摘下一个缓冲区。 这两个过程能否用于对缓冲池中的队列进行操作呢？答案是否定的。因为缓冲池中的 队列本身是临界资源，多个进程在访问一个队列时，既应互斥，又须同步。为此，需要对 这两个过程加以改造，以形成可用于对缓冲池中的队列进行操作的Getbuf和Putbuf过程。 为使诸进程能互斥地访问缓冲池队列，可为每一队列设置一个互斥信号量MS(type)。 此外，为了保证诸进程同步地使用缓冲区，又为每个缓冲队列设置了一个资源信号量 RS(type)。既可实现互斥又可保证同步的Getbuf过程和Putbuf过程描述如下： voidGetbuf(unsignedtype) Wait(RS(type)); Wait(MS(type)); B(number) = Takebuf(type); Signal(MS(type)); 213  计算机操作系统 void Putbuf(type, number) { Wait(MS(type)); Addbuf(type, number); Signal(MS(type); Signal(RS(type));\n\n3.缓冲区的工作方式 缓冲区可以工作在如下四种工作方式，如图6-27所示。 缓冲池 收容输入 提取输入 hin sin 用户程序 提取输出 收容输出 hout sout 图6-27缓冲区的工作方式\n\n(1）收容输入。输入进程可调用Getbuf(emq)过程，从空缓冲队列emq的队首摘下一空 缓冲区，把它作为收容输入工作缓冲区hin。然后，把数据输入其中，装满后再调用 Putbuf(inq，hin）过程，将它挂在输入队列inq队列上。\n\n(2）提取输入。计算进程可调用Getbuf(inq)过程，从输入队列inq的队首取得一缓冲区， 作为提取输入工作缓冲区（sin)，计算进程从中提取数据。计算进程用完该数据后，再调用 Putbuf(emq，sin）过程，将它挂到空缓冲队列emq上。\n\n(3）收容输出。计算进程可调用Getbuf(emq)，从空缓冲队列emq的队首取得一空缓冲， 作为收容输出工作缓冲区hout。当其中装满输出数据后，又调用Putbuf(outq，hout)过程， 将它挂在outq末尾。\n\n（4）提取输出。输出进程可调用Getbuf（outq）过程，从输出队列的队首取得一装满输出 数据的缓冲区，作为提取输出工作缓冲区sout。在数据提取完后，再调用Putbuf(emq，sout) 过程，将它挂在空缓冲队列末尾。\n\n6.8 磁盘存储器的性能和调度 磁盘存储器是计算机系统中的最重要的存储设备，在其中存放了大量的文件。对文件 的读、写操作都将涉及到对磁盘的访问。磁盘I/O速度的高低和磁盘系统的可靠性，将直 接影响到系统的性能。可以通过多种途经来改善磁盘系统的性能。首先可通过选择好的磁 盘调度算法，以减少磁盘的寻道时间：其次是提高磁盘IVO速度，以提高对文件的访问速 度；第三采取冗余技术，提高磁盘系统的可靠性，建立高度可靠的文件系统。第二和第三 点我们将它放在磁盘存储器管理一章中介绍。 214"
          }
        ]
      },
      {
        "二级标题": "6.8_磁盘存储器的性能和调度",
        "三级内容": [
          {
            "三级标题": "6.8.1 磁盘性能简述 磁盘设备是一种相当复杂的机电设备，在此仅对磁盘的某些性能，如数据的组织、磁 盘的类型和访问时间等方面做扼要的阐述。",
            "正文": "1.数据的组织和格式 磁盘设备可包括一个或多个物理盘片，每个磁盘片分一个或两个存储面（Surface)（见图 起见，在每条磁道上可存储相同数目的二进制位。这样，磁盘密度即每英寸中所存储的位 数，显然是内层磁道的密度较外层磁道的密度高。每条磁道又被从逻辑上划分成若干个扇 区（Sectors)，软盘大约为8至32个扇区，硬盘则可多达数百个，图6-28(b）显示了一个磁道 分成8个扇区的布局情况。一个扇区称为一个盘块（或数据块），各扇区之间保留一定的间 隙(Gap)。 7 盘面9 盘面8 写 盘面7 磁道 HP 19 盘面6 扇区 号 盘面5 磁道间隔 盘面4 盘面3 扇区间隔 盘面2 盘面1 盘面0 读写磁头 轴心 主杆 (a)磁盘驱动器的结构 (b)磁盘的数据布局 图6-28磁盘的结构和布局 一个物理记录存储在一个扇区上，磁盘上能存储的物理记录块数目是由扇区数、磁道 数以及磁盘面数所决定的。例如，一个10GB容量的磁盘，有8个双面可存储盘片，共16 个存储面（盘面），每面有16383个磁道（也称柱面），63个扇区。 为了提高磁盘的存储容量，充分利用磁盘外面磁道的存储能力，现代磁盘不再把内外 磁道划分为相同数目的扇区，而是利用外层磁道容量较内层磁道大的特点，将盘面划分成 若干条环带，同一环带内的所有磁道具有相同的扇区数。显然外层环带的磁道拥有较内层 环带的磁道更多的扇区。为了减少这种磁道和扇区在盘面分布的几何形式变化对驱动程序 的影响，大多数现代磁盘都隐藏了这些细节，仅向操作系统提供虚拟几何的磁盘规格，而 不是实际的物理几何规格。 为了在磁盘上存储数据，必须先将磁盘低级格式化。图6-29示出了一种温盘（温切斯 215  计算机操作系统 特盘)中一条磁道格式化的情况。其中每条磁道(Track)含有30个固定大小的扇区(Sectors)， 每个扇区容量为600个字节，其中512个字节存放数据，其余的用于存放控制信息。每个 作为该字段的定界符，利用磁道号（Track)、磁头号（Head#）及扇区号（Sectors#）三者来标识 一个扇区；CRC字段用于段校验。②数据字段（DataField)，存放512个字节的数据。存放 512个字节的数据。值得强调的是，在磁盘一个盘面的不同磁道（Track）、每个磁道的不同 扇区（Sector)，以及每个扇区的不同字段（Field)之间，为了简化和方便磁头的辨识，都设置 了一个到若干个字节不同长度的间距（Gap，也称间隙)。 Sector Physical Sector O Physical Sector1 Physical Sector 29 — ID Data D Data D Data FieldGap FieldGap Gap GapFieldGap Field Gap GapFieldGapFieldGap 102031292 29 3 1292293 Byte 17 20 17 4151520\n\n600 Byte/Sector SynchTrackHeadSector Synch CRC Data CRC Byte # # # Byte Byte1 2 512 2 图6-29磁盘的格式化 在磁盘格式化完成后，一般要对磁盘进行分区。在逻辑上，每个分区就是一个独立的 逻辑磁盘。每个分区的起始扇区和大小都记录在磁盘0扇区的主引导记录分区表所包含的 分区表中。在这个分区表中必须有一个分区被标记成活动的（即引导块），以保证能够从硬 盘引导系统。 但是，在真正可以使用磁盘前，还需要对磁盘进行一次高级格式化，即设置一个引导块、 空闲存储管理、根目录和一个空文件系统，同时在分区表中标记该分区所使用的文件系统。\n\n2.磁盘的类型 对于磁盘，可以从不同的角度进行分类。最常见的有：将磁盘分成硬盘和软盘、单片盘 和多片盘、固定头磁盘和活动头（移动头）磁盘等。下面仅对固定头磁盘和移动头磁盘做些介绍。\n\n(1）固定头磁盘。这种磁盘在每条磁道上都有一读/写磁头，所有的磁头都被装在一刚 性磁臂中。通过这些磁头可访问所有各磁道，并进行并行读/写，有效地提高了磁盘的IV/O 速度。这种结构主要用于大容量磁盘上。\n\n（2）移动头磁盘。每一个盘面仅配有一个磁头，也被装入磁臂中。为能访问该盘面上 的所有磁道，该磁头必须能移动以进行寻道。可见，移动磁头仅能以串行方式读/写，致使 其IO速度较慢；但由于其结构简单，敌仍广泛应用于中小型磁盘设备中。在微型机上配 置的温盘和软盘，都采用移动磁头结构，故本节主要针对这类磁盘的IO进行讨论。\n\n3.磁盘访问时间 磁盘设备在工作时以恒定速率旋转。为了读或写，磁头必须能移动到所指定的磁道上， 并等待所指定的扇区的开始位置旋转到磁头下，然后再开始读或写数据。故可把对磁盘的 访问时间分成以下三部分。 216  第六章：输入输出系统\n\n(1）寻道时间Ts。这是指把磁臂(磁头)移动到指定磁道上所经历的时间。该时间是启动 磁臂的时间s与磁头移动n条磁道所花费的时间之和，即 T=mxn+s 其中，m是一常数，与磁盘驱动器的速度有关，对一般磁盘，m=0.2；对高速磁盘，m≤0.1， 磁臂的启动时间约为2ms。这样，对一般的温盘，其寻道时间将随寻道距离的增大而增加， 大体上是5～30ms。\n\n(2）旋转延迟时间T。这是指定扇区移动到磁头下面所经历的时间，不同的磁盘类型中， 甚至更高。对于磁盘旋转延迟时间而言，如硬盘，旋转速度为15000r/min，每转需时4ms 平均旋转延迟时间T.为2ms；而对于软盘，其旋转速度为300r/min或600r/min，这样， 平均T为50～100ms。\n\n（3）传输时间T。这是指把数据从磁盘读出或向磁盘写入数据所经历的时间。T的大 小与每次所读/写的字节数b和旋转速度有关： b T= rN 其中，r为磁盘每秒钟的转数；N为一条磁道上的字节数，当一次读/写的字节数相当于半 条磁道上的字节数时，T与T，相同，因此，可将访问时间T。表示为：\n\n1. b 由上式可以看出，在访问时间中，寻道时间和旋转延迟时间基本上都与所读/写数据的 多少无关，而且它通常占据了访问时间中的大头。例如，我们假定寻道时间和旋转延迟时 间平均为20ms，而磁盘的传输速率为10MB/s，如果要传输10KB，此时总的访问时间为 21ms，可见传输时间所占比例是非常小的。当传输100KB数据时，其访问时间也只是 30ms，即当传输的数据量增大10倍时，访问时间只增加约50%。目前磁盘的传输速率已 达80MB/s以上，数据传输时间所占的比例更低。可见，适当地集中数据（不要太零散）传输， 将有利于提高传输效率。"
          },
          {
            "三级标题": "6.8.2 早期的磁盘调度算法 为了减少对文件的访问时间，应采用一种最佳的磁盘调度算法，以使各进程对磁盘的 平均访问时间最小。由于在访问磁盘的时间中主要是寻道时间，因此，磁盘调度的目标是 使磁盘的平均寻道时间最少。目前常用的磁盘调度算法有先来先服务、最短寻道时间优先 及扫描等算法。下面逐一介绍。",
            "正文": "1.先来先服务（FCFS） 这是最简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法 的优点是公平、简单，且每个进程的请求都能依次地得到处理，不会出现某一进程的请求 长期得不到满足的情况。但此算法由于未对寻道进行优化，致使平均寻道时间可能较长。 图6-30示出了有9个进程先后提出磁盘I/O请求时，按FCFS算法进行调度的情况。这里， 将进程号（请求者)按他们发出请求的先后次序排队。这样，平均寻道距离为55.3条磁道， 与后面即将讲到的几种调度算法相比，其平均寻道距离较大，故FCFS算法仅适用于请求 217  计算机操作系统 磁盘I/O的进程数目较少的场合。\n\n2.最短寻道时间优先（SSTF） 该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每 次的寻道时间最短，但这种算法不能保证平均寻道时间最短。图6-31示出按SSTF算法进 行调度时，各进程被调度的次序、每次磁头移动的距离，以及9次磁头平均移动的距离。 比较图6-30和图6-31可以看出，SSTF算法平均每次磁头移动的距离明显低于FCFS算法 的距离，因而SSTF较之FCFS有更好的寻道性能，故过去曾一度被广泛采用。 （从100号磁道开始） （从100号磁道开始） 被访问的 移动距离 被访问的 移动距离 下一个磁道号 （磁道数） 下一个磁道号 (磁道数) 55 45 06 10 58 3 58 32 39 19 55 3 18 21 39 16 90 72 38 1 160 70 18 20 150 10 150 132 38 112 160 10 184 146 184 24 平均寻道长度：55.3 平均寻道长度：27.5 图6-30FCFS调度算法 图6-31SSTF调度算法"
          },
          {
            "三级标题": "6.8.3 基于扫描的磁盘调度算法",
            "正文": "1.扫描(SCAN)算法 SSTF算法的实质是基于优先级的调度算法，因此就可能导致优先级低的进程发生“饥 饿”（Starvation）现象。因为只要不断有新进程的请求到达，且其所要访问的磁道与磁头当 前所在磁道的距离较近，这种新进程的I/O请求必然优先满足。在对SSTF算法略加修改后， 则可防止低优先级进程出现“饥饿”现象。 扫描（SCAN)算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁头 当前的移动方向。例如，当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对 象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直至 再无更外的磁道需要访问时，才将磁臂换向为自外向里移动。这时，同样也是每次选择这 样的进程来调度：即要访问的磁道在当前位置内为距离最近者，这样，磁头又逐步地从外 向里移动，直至再无更里面的磁道要访问，从而避免了出现“饥饿”现象。由于在这种算 法中磁头移动的规律颇似电梯的运行，因而又常称之为电梯调度算法。图6-32示出了按 SCAN算法对9个进程进行调度及磁头移动的情况。\n\n2.循环扫描（CSCAN)算法 SCAN算法既能获得较好的寻道性能，又能防止“饥饿”现象，故被广泛用于大、中、 218  第六章输入输出系统 小型机器和网络中的磁盘调度。但也存在这样的问题：当磁头刚从里向外移动而越过了某 一磁道时，恰好又有一进程请求访问此磁道，这时，该进程必须等待，待磁头继续从里向 外，然后再从外向里扫描完处于外面的所有要访问的磁道后，才处理该进程的请求，致使 该进程的请求被大大地推迟。为了减少这种延迟，CSCAN算法规定磁头单向移动，例如， 只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道， 亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描。采用循环扫描方式后，上 述请求进程的请求延迟将从原来的2T减为T+Smax，其中T为由里向外或由外向里单向扫 描完要访问的磁道所需的寻道时间，而Smax是将磁头从最外面被访问的磁道直接移到最里 及每次磁头移动的距离。 （从100#磁道开始，向磁道号 （从100#磁道开始，向磁道号 增加方向访问） 增加方向访问) 被访问的 移动距离 被访问的 移动距离 下一个磁道号 (磁道数) 下一个磁道号 (磁道数) 150 50 150 50 160 10 160 10 184 24 184 24 90 6 18 166 58 32 38 20 55 3 39 1 39 16 55 16 38 1 58 3 18 20 90 32 平均寻道长度：27.8 平均寻道长度：35.8 图6-32SCAN调度算法示例 图6-33CSCAN调度算法示例\n\n3.NStepSCAN和FSCAN调度算法 1)）NStepSCAN算法 在SSTF、SCAN及CSCAN几种调度算法中，都可能出现磁臂停留在某处不动的情况， 例如，有一个或几个进程对某一磁道有较高的访问频率，即这个（些）进程反复请求对某一磁道 的IO操作，从而垄断了整个磁盘设备。我们把这一现象称为“磁臂粘着”（Armstickiness)。 在高密度磁盘上容易出现此情况。N步SCAN算法是将磁盘请求队列分成若干个长度为N 的子队列，磁盘调度将按FCFS算法依次处理这些子队列。而每处理一个队列时又是按 SCAN算法，对一个队列处理完后，再处理其他队列。当正在处理某子队列时，如果又出 现新的磁盘I/O请求，便将新请求进程放入其他队列，这样就可避免出现粘着现象。当N 值取得很大时，会使N步扫描法的性能接近于SCAN算法的性能；当N=1时，N步SCAN 算法便蜕化为FCFS算法。 2）FSCAN算法 FSCAN算法实质上是N步SCAN算法的简化，即FSCAN只将磁盘请求队列分成两个 219  计算机操作系统 子队列。一个是由当前所有请求磁盘IV/O的进程形成的队列，由磁盘调度按SCAN算法进 行处理。另一个是在扫描期间，将新出现的所有请求磁盘IVO的进程放入等待处理的请求 队列。这样，所有的新请求都将被推迟到下一次扫描时处理。\n\n1.试说明I/O系统的基本功能。\n\n2.简要说明IO软件的四个层次的基本功能。\n\n3.I/O系统接口与软件/硬件（RW/HW)接口分别是什么接口？\n\n4.与设备无关性的基本含义是什么？为什么要设置该层？\n\n5.试说明设备控制器的组成。\n\n6.为了实现CPU与设备控制器间的通信，设备控制器应具备哪些功能？\n\n7.什么是内存映像I/O？它是如何实现的？\n\n8.为什么说中断是OS赖以生存的基础？\n\n9.对多中断源的两种处理方式分别用于何种场合？\n\n10.设备中断处理程序通常需完成哪些工作？\n\n11.简要说明中断处理程序对中断进行处理的几个步骤。\n\n12.试说明设备驱动程序具有哪些特点。\n\n13.设备驱动程序通常要完成哪些工作？\n\n14.简要说明设备驱动程序的处理过程可分为哪几步。\n\n15.试说明推动I/O控制发展的主要因素是什么。\n\n16.有哪几种I/O控制方式？各适用于何种场合？\n\n17.试说明DMA的工作流程。\n\n18.为何要引入与设备的无关性？如何实现设备的独立性？\n\n19.与设备的无关的软件中，包括了哪些公有操作的软件？\n\n20.在考虑到设备的独立性时，应如何分配独占设备？\n\n21.何谓设备虚拟？实现设备虚拟时所依赖的关键技术是什么？\n\n22.在实现后台打印时，SPOOLing系统应为请求I/O的进程提供哪些服务？\n\n23.假脱机系统向用户提供共享打印机的基本思想是什么？\n\n24.引入缓冲的主要原因是什么？\n\n25.在单缓冲情况下，为什么系统对一块数据的处理时间为max(C,T)+M?\n\n26.为什么在双缓冲情况下，系统对一块数据的处理时间为max(T,C)？\n\n27.试绘图说明把多缓冲用于输出时的情况。\n\n28.试说明收容输入工作缓冲区和提取输出工作缓冲区的工作情况。\n\n29.何谓安全分配方式和不安全分配方式？\n\n30.磁盘访问时间由哪几部分组成？每部分时间应如何计算？\n\n31.目前常用的磁盘调度算法有哪几种？每种算法优先考虑的问题是什么？ 220"
          }
        ]
      }
    ]
  }
]
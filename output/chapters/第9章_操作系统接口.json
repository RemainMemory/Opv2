[
  {
    "一级标题": "第9章_操作系统接口",
    "二级内容": [
      {
        "二级标题": "9.1_用户接口",
        "三级内容": [
          {
            "三级标题": "9.1.1 字符显示式联机用户接口 一 不同的OS，其联机用户接口是不同的，即它们的命令形式和用法各不相同，甚至在同 和图形化联机用户接口两类。 字符显示式联机用户接口又称为联机命令接口，是指用户通过命令语言实现对作业的 所需的命令，由终端处理程序接收该命令，并在用户终端屏幕上以字符显示方式反馈用户 输入的命令信息、命令执行及执行结果信息。 所谓命令语言，就是以命令为基本单位，指示操作系统完成特定的功能，由诸多命令 组成了命令集，完整的命令集包含了操作系统提供给用户可使用的全部功能。而命令是由 一组命令动词和参数组成的，具有规定的词法、语法、语义和表达形式，用户在终端键盘 上以命令行的形式输入，并提交给系统。不同操作系统所提供的命令语言在词法、语法、 语义及表达形式等方面各不相同。通常，命令语言可分成两种方式：",
            "正文": "1.命令行方式 该方式是以行为单位，输入和显示不同的命令。每行长度一般不超过256个字符，一 般情况下，以回车符作为一个命令的结束标记。通常，命令的执行采用的是间断式的串行 278  T 处理完成后系统发出新的命令输入提示符，用户才可以继续输入下一条命令。 在许多操作系统中也提供了命令的并行执行方式。例如，当两条命令的执行是不相关 的情况下，即用户对一条命令的执行结果并不急需，而且该命令的执行可能需要耗费较长时 间时，用户可以在该命令的结尾输入特定的标记，将该命令作为后台命令处理，这样，用户 不必等待该条命令执行完毕，即可继续输入下一条命令，系统便可对两条命令进行并行处理。 一般而言，对新用户来说，命令行方式十分繁琐，难以记忆，但对有经验的用户而言， 命令行方式用起来快捷便当、十分灵活，所以，至今许多操作员仍常使用这种命令方式。 简单命令的一般形式为： Command arg1 arg2 .\". argn 其中Command是命令名，又称命令动词，其余为该命令所带的执行参数，有些命令可以 没有参数。\n\n2.批命令方式 在操作命令的实际使用过程中，经常遇到需要对多条命令的连续使用、或对若干条命 令的重复使用、或对不同命令进行选择性使用的情况，如果用户每次都采用命令行方式将 命令一条条由键盘输入，既浪费时间，又容易出错。因此，操作系统都支持一种称为批命 令的特别命令方式，允许用户预先把一系列命令组织在一种称为批命令文件的文件中，一次 建立，多次执行。使用这种方式可减少用户输入命令的次数，既节省了时间，减少了出错概 率，又方便了用户。通常批命令文件都有特殊的文件扩展名，如MS-DOS系统的.BAT文件。 为此，操作系统还提供了一套控制子命令，以增强对命令文件使用的支持。用户可以 使用这些子命令和形式参数书写批命令文件，使得这样的批命令文件可以执行不同的命令 序列，从而增强了命令接口的处理能力。如UNIX和Linux中的Shell不仅是一种交互型命 令解释程序，也是一种命令级程序设计语言解释系统，它允许用户使用Shell简单命令、位 置参数和控制流语句编制带形式参数的批命令文件，称做Shell文件或Shell过程，Shell 可以自动解释和执行该文件或过程中的命令。"
          },
          {
            "三级标题": "9.1.2 图形化联机用户接口",
            "正文": "1..\n\n1.图形用户接口GUI（GraphicsUserInterface）的引[入 虽然用户可以通过命令行方式和批命令方式，取得操作系统的服务，并控制自已的作 业运行，但却要牢记各种命令的动词和参数，必须严格按规定的格式输入命令，而且不同 操作系统所提供的命令语言的词法、语法、语义及表达形式是不一样的，这样既不方便又 花费时间。于是，图形化用户接口GUI（GraphicsUserInterface)便应运而生。 1981年，Xer0x公司在Star8010工作站操作系统中首次推出了图形用户接口，1983年， Apple公司又在AppleLisa机和Macintosh机上的操作系统中成功使用GUI，之后，还有 Microsoft公司的Windows、IBM公司的OS/2、UNIX和Linux使用的X-Window等都使用 了GUI。它已成为近年来最为流行的联机用户接口形式，并制订了国际GUI标准。20世纪 90年代以后推出的主流OS都提供了GUI。\n\n2.使用WIMP技术 GUI采用了图形化的操作界面，使用WIMP技术，该技术将窗口(Window）、图标(Icon)、 279  计算机操作系统 菜单(Menu)、鼠标(Pointingdevice)和面向对象技术等集成在一起，引入形象的各种图标， 将系统的各项功能、各种应用程序和文件直观、逼真地表示出来，形成一个图文并茂的视 窗操作环境。在有了GUI后，在桌面上显示了许多常用的图标，每一个图标对应于一个应 用程序，用户为了启动相应的应用程序，已完全不用像以前那样键入复杂的命令和文件名， 只需双击命令的图标即可。用户还可以轻松地通过选择窗口、菜单、对话框和滚动条，完 成对他们的作业和文件的各种控制与操作。由于GUI的可视性，使许多日常任务更加直观， 再加上简单的约定，使对计算机的操作变得非常容易。\n\n3.Windows的GUI简介 以Microsoft公司的Windows操作系统为例，在系统初始化后，OS为终端用户生成了 一个运行explorer.exe的进程，它运行一个具有窗口界面的命令解释程序，该窗口是一个特 释程序会产生一个新进程，由新进程弹出一个新窗口，并运行该应用程序，该新窗口的菜 单栏或图标栏会显示应用程序的子命令。用户可进一步选择并点击子命令，如果该子命令 需要用户输入参数，则会弹出一个对话窗口，指导用户进行命令参数的输入，完成后用户 点击“确定”按钮，命令进入执行处理过程。 在Windows系统中，采用的是事件驱动控制方式，用户通过动作来产生事件，以驱动 程序工作。事件实质就是发送给应用程序的一个消息。用户的按键或点击鼠标等动作都会 产生一个事件，通过中断系统引出事件驱动控制程序工作，对事件进行接收、分析、处理 和清除。各种命令和系统中所有的资源，如文件、目录、打印机、磁盘、各种系统应用程 序等，都可以定义为一个菜单、一个按钮或一个图标。所有的程序都拥有窗口界面，窗口 中所使用的滚动条、按钮、编辑框、对话框等各种操作对象，都采用统一的图形显示方式 和操作方法。用户可以通过鼠标（或键盘）点击操作，选择所需要的菜单、图标或按钮，从 而达到控制系统、运行某个程序、执行某个操作（命令）的目的。 由于图形用户接口有着非常明显的优点，致使现在多数OS，特别是面向非程序员和无 经验用户的系统，都使用GUI作为上层的OS接口。但联机命令接口也并未过时，而且还 深受高级用户和程序员的欢迎。这是因为使用联机命令可以对资源进行更多和更深入的控 制，它可在一个命令行中包含多条命令，系统能连续地执行这些命令，并且还可将命令语 言变成强大的编程语言，编制出复杂的脚本。因此在UNIX、Linux和其它的OS中仍继续 支持联机命令接口shell，当然它们也可以使用图形用户接口。"
          },
          {
            "三级标题": "9.1.3 .联机命令的类型 一一一一 在联机命令接口中，OS向用户提供了几十条甚至上百条的联机命令。根据这些命令 所完成功能的不同，可把它们分成以下几类：系统访问类、磁盘操作类、文件操作类、目 录操作类、通信类，以及其它命令。现分述如下：",
            "正文": "1.系统访问类 在多用户系统中，为了保证系统的安全性，都毫无例外地设置注册命令Login。凡要 在多用户系统的终端上上机的用户，都必须先在系统管理员处获得一合法的注册名和口令。 以后，每当用户在接通其所用终端的电源后，便由系统直接调用，并在屏幕上显示出以下 280  第九章操作系统接口 的注册命令： Login: /提示用户键入自己的注册名 当用户键入正确的注册名并按下回车键后，屏幕上又会出现： Password：-：/提示用户键入自己的口令 用户在键入口令时，系统将关闭掉回送显示，以使口令不在屏幕上显示出来。如果键 入的口令正确而使注册成功时，屏幕上会立即出现系统提示符（所用符号随系统而异），表 示用户可以开始键入命令。如果用户多次（通常不超过三次）键入的注册名或口令都有错， 系统将解除与用户的联接。\n\n2.文件操作命令 每个操作系统都提供了一组文件操作命令。在微机OS中的文件操作命令有：\n\n（1）显示文件命令type，用于将指定文件内容显示在屏幕上。\n\n(2）拷贝文件命令copy，用于实现文件的拷贝。\n\n(3）文件比较命令comp，该命令用于对两个指定文件进行比较，两文件可以在同一个 或不同的驱动器上。 的名字。\n\n（5）删除文件命令erase，该命令用于删除一个或一组文件，例如，当参数路径名为 *.BAK时，表示删除指定目录下的所有其扩展名为.Bak的文件。\n\n3.目录操作命令 对目录进行操作的命令有：\n\n（1）建立子目录命令mkdir，用于建立指定名字的新目录。\n\n（2）显示目录命令dir，显示指定磁盘中的目录项。\n\n（3）删除子目录命令rmdir，用于删除指定的子目录文件，但不能删除普通文件，而且\n\n（4）显示目录结构命令tree，显示指定盘上的所有目录路径及其层次关系。\n\n（5）改变当前目录命令chdir，将当前目录改变为由路径名参数给定的目录。用“”作 参数时，表示应返回到上一级目录下。\n\n4.其它命令\n\n（1）输入输出重定向命令。在有的OS中定义了两个标准I/O设备。通常，命令的输入 取自标准输入设备，即键盘；而命令的输出通常是送往标准输出设备，即显示终端。如果 在命令中设置输出重定向“>”符，其后接文件名或设备名，表示将命令的输出改向，送到 指定文件或设备上。类似地，若在命令中设置输入重定向“<”符，则不再是从键盘而是从 重定向符左边参数所指定的文件或设备上取得输入信息。\n\n（2）管道连接。这是指把第一条命令的输出信息作为第二条命令的输入信息；类似地， 又可把第二条命令的输出信息作为第三条命令的输入信息。这样，由两个（含两条）以上的 命令可形成一条管道。在MS-DOS和UNIX中，都用“”作为管道符号。其一般格式为： Command1ICommand2l..ICommandn;\n\n(3）过滤命令。在UNIX及MS-DOS中，都有过滤命令，用于读取指定文件或标准输 281  计算机操作系统 入，从中找出由参数指定的模式，然后把所有包含该模式的行都打印出来。例如，MS-DOS 中用命令 find/N“erase”（路径名） 可对由路径名指定的输入文件逐行检索，把含有字符串“erase”的行输出。其中，N是选 择开关，表示输出含有指定字串的行。如果不用N而用C，则表示只输出含有指定字串的 行数；若用V，则表示输出不含指定字串的行。\n\n（4）批命令。为了能连续地使用多条键盘命令，或多次反复地执行指定的若干条命令， 而又免去每次重敲这些命令的麻烦，可以提供一个特定文件。在MS-DOS中提供了一种特 殊文件，其后缀名用“BAT”；在UNIX系统中称为命令文件。它们都是利用一些键盘命令 构成一个程序，一次建立供多次使用。在MS-DOS中用batch命令去执行由指定或默认驱 动器的工作目录上指定文件中所包含的一些命令。"
          }
        ]
      },
      {
        "二级标题": "9.2_Shell命令语言",
        "三级内容": [
          {
            "三级标题": "9.2.1 简单命令简介 在Shell命令语言中提供了许多不同形式的命令，并充许在一条命令行中有多个命令。 如果在一条命令行中仅有一个命令，就把它称为简单命令。实际上，一条简单命令便是一 个能完成某种功能的目标程序的名字。",
            "正文": "1.简单命令的格式 简单命令的格式比较自由，包括命令名字符的个数及用于分隔命令名、选项、各参数 间的空格数等，都是任意的。在UNIX和Linux系统中都规定，命令由小写字母构成，命 令可带有参数表，用于给出执行命令时的附加信息，每个参数是一个单词。命令名与参数 表之间还可使用一种称为选项的自变量，用减号开始，后跟一个或多个字母、数字。一条 命令可有多个选项，用于改变命令执行动作的类型。命令的格式如下： $ Command -option argument list 例如： $ ls file1 file2 282  第九章操作系统接口 这是一条不带选项的列目录命令，$是系统提示符。该命令用于列出file1和file2两个 目录文件中所包含的目录项，并隐含地指出按英文字母顺序列表。若给出-tr选项，该命令 可表示成： $ ls-trfile1 file 2 其中，选项t和r分别表示按最近修改次序及按反字母顺序列表。 通常，命令名与该程序的功能紧密相关，以便于记忆。命令参数可多可少，也可缺省。 例如： $ls 表示自动以当前工作目录为缺省参数，打印出当前工作目录所包含的目录项。\n\n2.简单命令的分类 在Linux或UNIX系统中，一般把简单命令分为两类：\n\n（1）系统提供的标准命令，包括调用各种语言处理程序、实用程序等，其数量随系统 版本的不同而有所差异，系统管理员可以增添新的系统标准命令。\n\n（2）用户自定义的命令。系统管理员和用户自行定义的命令的执行方式与系统标准命 令的执行方式相同。 对于简单命令，还可根据命令是否包含在Shell内部，即是否常驻内存，而分为内部命 令和外部命令两类：\n\n（1）内部命令。Shell中少数标准命令，如改变工作目录命令cd等，是包含在Shell内 部的，作为内部命令常驻内存。 上，即每个命令是存在于文件系统中某个目录下的单独程序。这样做的好处在于，可以很 大程度地节省内存空间。 简单命令的数量易于扩充。Shell对命令的管理，对用户而言也是透明的，即用户在使 用时，不必关心一个命令是内部命令还是外部命令。当用户输入一个命令时，Shell首先检 查该命令是否是内部命令，若不是，则检查是否是外部命令。判断是否是外部命令则是通 过搜索路径（目录列表）里能否寻找到相应的应用程序进行确定的。如果用户键入的命令不 是一个内部命令，也不是外部命令，则返回显示一条错误信息。否则，如果能够成功找到 命令，则将命令分解为系统调用，并传给Linux内核进行处理。\n\n3.Shell的种类\n\n（1）BourneShell。在UNIX中，最初使用的Shell就是BourneShell，简称为BShell， 可以通用于多种UNIX上，用$作为提示符，在提示符之后，可以输入命令或回车键。BShe11 程序一样，BShell本身也是一个程序，它的名字是Sh。 BShell有多个版本，最著名的是BourneAgainShell（也称为Bash)，与BShell完全向 后兼容。它在BShell的基础上加以扩展，增加、增强了很多特性，可以提供如命令补全、 命令编辑和命令历史表等功能，它还包含了很多CShell和KornShell中的优点，有灵活和 强大的编程接口，同时又有很友好的用户界面，是Linux操作系统中缺省的Shell。 283  计算机操作系统\n\n(2）CShell。CShell是一种比BShell更适于编程的Shell，是标准BSD(BerkeleySystem Distribution）命令解释。它的名字是CSh，其语法与C语言很相似，用%作为提示符。随 着UNIX系统标准化的发展，使用UNIX作为操作系统的工作站，大都同时支持BShell 和 C Shell。 CShell不仅和BShell提示符兼容，而且还提供比BShell更多的提示符参数。例如， CShell可以使用许多特殊的字符，当输入这类字符时，可以执行许多特殊的功能，例如， 惊叹号（！)表示重复执行命令，两个惊叹号（！)表示重复执行最后输入的命令。在Linux系 统中，与CShell对应的是Tcsh。Tcsh也是CShell的一个扩展版本，包括命令行编辑、可 编程单词补全、拼写校正、历史命令替换、作业控制等。\n\n（3）KornShell。KornShell集合了CShell和BShell的优点，并且和BShell完全兼容， 它的名字是KSh。对应地，Linux系统提供了Pdksh，也是对KornShell的扩展，它支持任 务控制，可以在命令行上挂起、后台执行、唤醒或终止程序。"
          },
          {
            "三级标题": "9.2.2 简单命令的类型 根据简单命令功能的不同，可将它们分成如下五大类：",
            "正文": "1.进入与退出系统\n\n（1）进入系统，也称为注册。事先，用户须与系统管理员商定一个唯一的用户名。管 理员用该名字在系统文件树上为用户建立一个子目录树的根结点。当用户打开自己的终端 时，屏幕上会出现Login：提示，这时用户便可键入自己的注册名，并用回车符结束。然后， 系统又询问用户口令，用户可用回车符或事先约定的口令键入。在通过这两步检查后，才能 出现系统提示符，以提示用户可以使用系统。若任一步有错，系统均会提示要用户重新键入。\n\n（2）退出系统。每当用户用完系统后，应向系统报告自己要退出。系统得知后，马上 为用户记账，清除用户的使用环境。如果用户使用的是多终端中的一个终端，为了退出， 新用户使用。用户的进入与退出过程是由系统直接调用Login及Logout程序完成的。\n\n2.文件操作命令\n\n（1）显示文件内容命令cat。如果用户想了解自已在当前目录中的某个或某几个指定文 件的内容时，便可使用下述格式的cat命令：！ $catfilename1 filename2 执行上述命令后，将按参数指定的顺序，依次把所列名字的文件内容送屏幕显示。若键入的 文件名有错，或该文件不在当前目录下，则该命令执行结果将显示指定文件不能打开的信息。\n\n(2）复制文件副本的命令cp。其格式为： m 001678 cp source target 该命令用于对已存在的文件source建立一个名为target的副本。\n\n(3）对已有文件改名的命令mV。其格式为： mv oldnamenewname 用于把原来的老名字改成指定的新名字。\n\n（4）撤消文件的命令rm。它给出一个参数表，是要撤消的文件名清单。 284  第九章操作系统接口\n\n（5）确定文件类型的命令file。该命令带有一个参数表，用于给出想了解其（文件）类型 的文件名清单。命令执行的结果，将在屏幕上显示出各个文件的类型。\n\n3.目录操作命令\n\n（1）建立目录的命令mkdir（简称md)。用户可以自己的注册名作为根结点，建立一棵子 目录树。可用md命令来构建一个目录，参数是新创建目录的名字。但该命令的使用必须 在其父目录中有写许可。 下仍有文件，该命令将被认为是错误操作，这样可以防止因不慎而消除了一个想保留的文 件。命令的参数表给出了要撤消的目录文件清单。 当前目录的子目录名作参数，将把用户移到当前目录指定的下一级目录上。\n\n4.系统询问命令\n\n（1）访问当前日期和时间命令date。例如，使用命令 $date 屏幕上将给出当前的日期和时间，如为： WedAng1409:27:20PDT2006 表示当前日期是2006年9月14日、星期三，还有时间信息。若在命令名后给出参数，则 date程序把参数作为重置系统时钟的时间。\n\n（2）询问系统当前用户的命令who。who命令可列出当前每一个处在系统中的用户的注 册名、终端名和注册进入时间，并按终端标志的字母顺序排序。例如，报告有下列三用户： Veronicabxo66Aug2713:28 Rathomas dz24 Aug2807:42 Jlyates tty5 Aug2807:39 统打印出当前的用户数目而不显示系统用户名等的完整清单，以得知当前用户数目。\n\n（3）显示当前目录路径名的命令pwd。当前目录的路径名是从根结点开始。用户的当 前目录可能经常在树上移动。如果用户忘记了自己在哪里，便可用pwd确定自己的位置。 除了上述的命令外，还有许多较常用的命令。输入输出重定向命令、管道连接、通信 命令和后台命令等，分别在下面三小节中介绍。"
          },
          {
            "三级标题": "9.2.3 重定向与管道命令",
            "正文": "1.重定向命令 在Linux系统中，由系统定义了三个文件。其中，有两个分别称为标准输入和标准输 出的文件，各对应于终端键盘输入和终端屏幕输出。它们是在用户注册时，由Login程序 打开的。这样，在用户程序执行时，隐含的标准输入是键盘输入，标准输出即屏幕（输出） 显示。但用户程序中可能不要求从键盘输入，而是从某个指定文件上读取信息供程序使用； 同样，用户可能希望把程序执行时所产生的结果数据写到某个指定文件中而非屏幕上。为此， 285  计算机操作系统 用户必须不使用标准输入、标准输出，而把另外的某个指定文件或设备作为输入或输出文件。 Shell向用户提供了这种用于改变输入、输出设备的手段，此即标准输入与标准输出 的重新定向。用重定向符“<”和“>”分别表示输入转向与输出转向。例如，对于命令 $ cat filel 表示将文件file1的内容在标准输出上打印出来。若改变其输出，用命令 $ cat file1>file2 表示把文件file1的内容打印输出到文件file2上。同理，对于命令 $wc 表示对标准输入中的行中字和字符进行计数。若改变其输入，用命令 $ wc<file3 则表示把从文件file3中读出的行中的字和字符进行计数。 须指明的是，在做输出转向时，若上述的文件file2并不存在，则先创建它；若已存在， 则认为它是空白的，执行上述输出转向命令时，是用命令的输出数据去重写该文件；如果 文件file2事先已有内容，则用文件file1的内容去更新文件file2的原有内容。现在，如果 又要求把file4的内容附加到现有的文件file2的末尾，则应使用另一个输出转向符“>>”， 即此时应再用命令 $ cat file4 >> file2 便可在文件file2中，除了上次复制的file1内容外，后面又附加上file4的内容。 此外，也可在一个命令行中同时改变输入与输出。例如，命令行 a.out<filel>file0 表示在可执行文件a.out执行时，将从文件file1中提取数据，而把a.out的执行结果数据输 出到文件fileO中。\n\n2.管道命令 人们又进一步把重定向思想加以扩充，用符号“”来连接两条命令，使其前一条命令 的输出作为后一条命令的输入。即 $command1l command 2 例如，对于下述输入 cat fileIwc 将使命令cat把文件file中的数据作为wc命令的计数输入。 系统执行上述输入时，将为管道建立一个作为通信通道的pipe文件。这时，cat命令 道线所连接的命令之间实现单向、同步运行。其单向性表现在：只把管道线前面命令的输 出送入管道，而管道的输出数据仅供管道线后面的命令去读取。管道的同步特性则表现为： 当一条管道满时，其前一条命令停止执行；而当管道空时，则其后一条命令停止运行。除 此两种情况外，用管道所连接的两条命令“同时”运行。可见，利用管道功能，可以流水线 方式实现命令的流水线化，即在单一命令行下同时运行多条命令，以加速复杂任务的完成。"
          },
          {
            "三级标题": "9.2.4 通信命令 在Linux系统中为用户提供了实时和非实时两种通信方式，分别使用write及mail命令。 286  第九章操作系统接口 此外，联机用户还可根据自已的当前情况，决定是否接受其他用户与他进行通信的要求。",
            "正文": "1.信箱通信命令mail 信箱通信是作为在UNIX的各用户之间进行非交互式通信的工具。发信者把要发送的 消息写成信件，“邮寄”到对方的信箱中。通常各用户的私有信箱采用各自的注册名命名， 即它是目录usr/spool/mail中的一个文件，而文件名又是用接收者的注册名来命名的。信箱 中的信件可以一直保留到被信箱所有者消除为止。mail命令在用于发信时，把接收者的注 册名当做参数输入后，便可在新行开始键入信件正文，最后仍在一个新行上，用“”来结 束信件或用“D”退出mail程序（也可带选项，此处从略）。接收者也用mail命令读取信件， 可使用可选项r、q或p等。其命令格式为： mail 分别表示：按先进先出顺序显示各信件的内容；在输入中断字符（DEL或RETURN)后，退 出mail程序而不改变信箱的内容；一次性地显示信箱全部内容而不带询问，把指定文件当 做信件来显示。在不使用-P选项时，表示在显示完一个信件后便出现“？”，以询问用户 是否继续显示下一条消息，或选读完最后一条消息后退出mail。\n\n2.对话通信命令write 用这条命令可以使用户与当前在系统中的其他用户直接进行联机通信。由于UNIX系 统允许一个用户同时在几个终端上注册，故在用此命令前，要用who命令去查看目标用户 当前是否联机，或确定接收者所使用的终端名。命令格式为： writeuser[ttyname] 当接收者只有一个终端时，终端名可缺省。当接收者的终端被充许接收消息时，屏幕提示 会通知接收者源用户名及其所用终端名。\n\n3.允许或拒绝接收消息的mesg命令 其格式为： 选项n表示拒绝对方的写许可(即拒绝接收消息)；选项y指示恢复对方的写许可，仅在此 时双方才可联机通信。当用户正在联机编写一份资料而不愿被别人干扰时，常选用n选项 来拒绝对方的写许可。编辑完毕，再用带有y选项的mesg命令来恢复对方的写许可，不带 自变量的mesg命令只报告当前状态而不改变它。"
          },
          {
            "三级标题": "9.2.5 后台命令 有些命令需要执行很长的时间，这样，当用户键入该命令后，便会发现自已已无事可 做，要一直等到该命令执行完毕，方可再键入下一条命令。这时用户自然会想到应该利用 这段时间去做些别的事。UNIX系统提供了这种机制，用户可以在这种命令后面再加上 “&”号，以告诉Shell将该命令放在后台执行，以便用户能在前台继续键入其它命令，完 成其它工作。 在后台运行的程序仍然把终端作为它的标准输出和标准输入文件，除非对它们进行重 新定向。其标准输入文件是自动地被从终端定向到一个被称为“/dev/null”的空文件中。若shell未重定向标准输入，则shell和后台进程将会同时从终端读入。这时，用户从终端键入 的字符可能被发送到一个进程或另一个进程，并不能预测哪个进程将得到该字符。因此， 对所有在后台运行的命令的标准输入，都必须加以重定向，从而使从终端键入的所有字符 都被送到Shell进程。用户可使用ps、wait及Kil命令去了解和控制后台进程的运行。",
            "正文": ""
          }
        ]
      },
      {
        "二级标题": "9.3_联机命令接口的实现",
        "三级内容": [
          {
            "三级标题": "9.3.1 键盘终端处理程序 -: 在微机或终端上所配置的键盘终端处理程序应具有下述几方面的功能：①接收用户从 终端上打入的字符；②字符缓冲，用于暂存所接收的字符；③回送显示；④屏幕编辑； ③特殊字符处理。",
            "正文": "1.字符接收功能 为了实现人机交互，键盘终端处理程序必须能够接收从终端输入的字符，并将之传送 给用户程序。有两种方式可实现字符接收功能：\n\n（1）面向字符方式。驱动程序只接收从终端打入的字符，并且不加修改地将它传送给 用户程序。这通常是一串未加工的ASCII码。但大多数的用户并不喜欢这种方式。\n\n(2）面向行方式。终端处理程序将所接收的字符暂存在行缓冲中，并可对行内字符进 行编辑。仅在收到行结束符后，才将一行正确的信息送命令解释程序。在有的计算机中， “30”放入IVO寄存器，此时，终端处理程序必须参照某种表格将键码转换成ASCII码。\n\n2.字符缓冲功能 为了能暂存从终端键入的字符，以降低中断处理器的频率，在终端处理程序中，还必 须具有字符缓冲功能。字符缓冲可采用以下两种方式之一：\n\n（1）专用缓冲方式。系统为每个终端设置一个缓冲区，暂存用户键入的一批字符。缓 100个终端时，要求有20KB的缓冲区。但专用缓冲方式可使终端处理程序简化。图9-1(a) 示出了专用缓冲方式。\n\n（2）公用缓冲方式。系统只设置一个由多个缓冲区构成的公用缓冲池，而没有为每个 终端设置专用缓冲区。其中的每个缓冲区大小相同，如为20个字符，再将所有的空缓冲区 链接成一个空缓冲区链。当终端有数据输入时，可先向空缓冲区链申请一空缓冲区，来接 收输入字符；当该缓冲区装满后，再申请一空缓冲区。这样，直至全部输入完毕，并利用 链接指针将这些装有输入数据的缓冲区链接成一条输入链。每当该输入链中一个缓冲区内的 288  第九章：操作系统接口 字符被全部传送给用户程序后，便将该缓冲区从输入链中移出，再重新链入空缓冲区链中。 显然，利用公用缓冲池方式可有效地提高缓冲的利用率。图9-1(b)示出了公用缓冲池方式。 终端 终端 公用缓冲池 主机 主机 (a) (b) 图9-1两种缓冲方式\n\n3.回送显示 回送显示（回显）是指每当用户从键盘输入一个字符后，终端处理程序便将该字符送往 屏幕显示。有些终端的回显由硬件实现，其速度较快，但往往会引起麻烦。如当用户键入 口令时，为防止口令被盗用，显然不该有回显。此外，用硬件实现回显也缺乏灵活性，因 而近年来多改用软件来实现回显，这样可以做到在用户需要时才回显。用软件实现回显， 还可方便地进行字符变换，如将键盘输入的小写英文字母变成大写，或相反。驱动程序在 将输入的字符送往屏幕回显时，应打印在正确的位置上；当光标走到一行的最后一个位置 后，便应返回到下一行的开始位置。例如，当所键入的字符数目超过一行的80个（字符）时， 应自动地将下一个字符打印到下一行的开始位置。\n\n4.屏幕编辑 为此，在终端处理程序中，还应能实现屏幕编辑功能，包括能提供若干个编辑键。常用的 编辑键有：\n\n(1）删除字符键。它允许将用户刚键入的字符删除。在有的系统中是利用退格键即 Bakespace(Ctrl+H)键。当用户敲击该键时，处理程序并不将刚键入的字符送入字符队列， 而是从字符队列中移出其前的一个字符。\n\n(2）删除一行键。该键用于将刚输入的一行删去。\n\n（3）插入键。利用该键在光标处可插入一个字符或一行正文。\n\n（4）移动光标键。在键盘上有用于对光标进行上、下、左、右移动的键。\n\n(5）屏幕上卷或下移键等。\n\n5.特殊字符处理 终端处理程序必须能对若干特殊字符进行及时处理，这些字符是：\n\n（1）中断字符。当程序在运行中出现异常情况时，用户可通过键入中断字符的办法来 中止当前程序的运行。在许多系统中是利用Break或Delete或Cul+C键作为中断字符。对中 断字符的处理比较复杂。当终端处理程序收到用户键入的中断字符后，将向该终端上的所有 进程发送一个要求进程终止的软中断信号，这些进程收到该软中断信号后，便进行自我终止。 289  计算机操作系统\n\n(2）停止上卷字符。用户键入此字符后，终端处理程序应使正在上卷的屏幕暂停上卷， 以便用户仔细观察屏幕内容。在有的系统中，是利用Ctrl+S键来停止屏幕上卷的。\n\n(3）恢复上卷字符。有的系统利用Ctrl+Q键使停止上卷的屏幕恢复上卷。终端处理程 序收到该字符后，便恢复屏幕的上卷功能。 上述的Ctrl+S与Ctrl+Q两字符并不被存储，而是被用去设置终端数据结构中的某个标 志。每当终端试图输出时，都须先检查该标志，若该标志已被设置，便不再把字符送至屏幕。"
          },
          {
            "三级标题": "9.3.2 MS-DOS解释程序 一 为了方便与用户交互，通常把命令解释程序放在用户层，以用户态方式运行。我们通 过两个具体例子来说明命令解释程序的主要功能和实现方法。本小节先介绍MS-DOS中的 命令解释程序COMMAND.COM，下一小节介绍UNIX的命令解释程序Shell。",
            "正文": "1.命令解释程序的作用 在联机操作方式下，终端处理程序把用户键入的信息送键盘缓冲区中保存。一旦用户 键入回车符，便立即把控制权交给命令解释程序。显然，对于不同的命令，应有能完成特 定功能的命令处理程序与之对应。可见，命令解释程序的主要作用是在屏幕上给出提示符， 请用户键入命令，然后读入该命令，识别命令，再转到相应命令处理程序的入口地址，把 控制权交给该处理程序去执行，并将处理结果送屏幕上显示。若用户键入的命令有错，而 命令解释程序未能予以识别，或在执行中间出现问题时，则应显示出某一出错信息。\n\n2.命令解释程序的组成 MS-DOS是1981年由Microsoft公司开发的、-配置在微机上的OS。随着微机的发展， MS-DOS的版本也在不断升级，由开始时的1.0版本升级到1994年的6.X版本。在此期间， 它已是事实上的16位微机OS的标准。我们以MS-DOS操作系统中的COMMAND.COM 处理程序为例来说明命令解释程序的组成。它包括以下三部分：\n\n（1）常驻部分。这部分包括一些中断服务子程序。例如，正常退出中断INT20，它用 于在用户程序执行完毕后退回操作系统：驻留退出中断INT27，用这种方式，退出程序可 驻留在内存中；还有用于处理和显示标准错误信息的INT24等。常驻部分还包括这样的程 序：当用户程序终止后，它检查暂存部分是否已被用户程序覆盖，若已被覆盖，便重新将 暂存部分调入内存。\n\n(2）初始化部分。它跟随在常驻内存部分之后，在启动时获得控制权。这部分还包括 对AUTOEXEC.BAT文件的处理程序，并决定应用程序装入的基地址。每当系统接电或重 新启动后，由处理程序找到并执行AUTOEXEC.BAT文件。由于该文件在用完后不再被需 要，因而它将被第一个由COMMAND.COM装入的文件所覆盖。\n\n(3）暂存部分。这部分主要是命令解释程序，并包含了所有的内部命令处理程序、批 文件处理程序，以及装入和执行外部命令的程序。它们都驻留在内存中，但用户程序可以 使用并覆盖这部分内存，在用户程序结束时，常驻程序又会将它们重新从磁盘调入内存， 恢复暂存部分。\n\n3.命令解释程序的工作流程 系统在接通电源或复位后，初始化部分获得控制权，对整个系统完成初始化工作，并 290  第九章操作系统接口 自动执行AUTOEXEC.BAT文件，之后便把控制权交给暂存部分。暂存部分首先读入键盘 缓冲区中的命令，判别其文件名、扩展名及驱动器名是否正确。若发现有错，在给出出错 信息后返回；若无错，再识别该命令。一种简单的识别命令的方法是基于一张表格，其中 的每一表目都由命令名及其处理程序的入口地址两项组成。如果暂存部分在该表中能找到 键入的命令，且是内部命令，便可以直接从对应表项中获得该命令处理程序的入口地址， 然后把控制权交给该处理程序去执行该命令。如果发现键入的命令不属于内部命令而是外 部命令，则暂存部分还须为之建立命令行；再通过执行系统调用exec来装入该命令的处理程 序，并得到其基地址；最后把控制权交给该程序去执行相应的命令。图9-2示出了MS-DOS 的COMMAND.COM的工作流程。 十 输入命令行 否 命令合法否？ 是 是内部命令？ 从外存调入外部命令执行 是 DIR命令 Type命令 Date命令 处理程序 处理程序 处理程序 处理程序 L 显示提示符 图9-2COMMAND.COM的工作流程"
          },
          {
            "三级标题": "9.3.3 Shell解释程序 一+ 在UNIX或Linux系统中，Shell是作为操作系统的最外层（也称为外壳），是用户及应 用程序与操作系统的接口，它是命令语言、命令解释程序及程序设计语言的统称。Shell作 为一个命令解释程序，用于对从标准输入或文件中读入的命令进行解释执行。例如，当用 户在提示符下输入命令或其它程序向Linux传递命令时，都需经过Shell的解释，或称为识 别，然后再传递给内核中相应的处理程序，由该程序去完成相应的操作。",
            "正文": "1.Shell命令的特点 前面我们介绍了MS-DOS的命令解释程序，它非常简单。而Shell命令解释程序就复 杂得多，这主要是因为Shell命令的类型多而复杂所致。主要表现如下：\n\n（1）一条命令行中含有多个命令。如果在一条命令行中仅有一个命令，那么命令解释 程序便可以利用简单的命令表找到该命令的命令处理程序。然而在Shell的一条命令行中， 可能含有多个不同的命令，由于每一条命令对应了一个处理程序，故在对一个命令行进行 解释后，应产生多个命令处理程序（进程）。\n\n(2）具有不同的分隔符。在一条命令行中的每个命令之间都采取不同的分隔符。如利 用“；”分隔符时，要求命令行中命令应顺序执行；如用“&”分隔符时，要求命令行中前 面的命令放在后台执行；如利用“I”分隔符时，要求把前一条命令的输出作为后一条命令 291  计算机操作系统 的输入。换言之，这些分隔符确定了这些命令的执行顺序和方式。\n\n2.二叉树结构的命令行树 隔符类型的不同，并按照一定的规律构成二叉树结构的命令行树。采用它的好处是，它能 够很好地表示出命令行中所有命令的执行顺序和方式。下面通过简单的例子来说明如何建 立二叉树结构的命令行树。 1）命令表型结点 Shell命令解释程序按命令行语句的结构顺序进行检查，每当遇到“；”及“&”分隔符 右子树。例如下面的命令行所构成的命令树如图9-3所示： Command 1；Command2;&Command3 由于每一条命令对应了一个处理进程，故在执行命 左子树 右子树 令树时，对应于每一条命令都需要为之创建一个进程， 由此为命令树生成一个对应的进程树。在具体执行时， Command1 & 对于“；”型结点，先递归地执行其左子树，待其左子数 执行完后，再执行其右子树。对于“&”型结点，可在 Command2 Command3 启动了左子结点执行后，无须等待它执行完毕，便可转 去执行其右子结点。 图9-3命令表型结点及其左、右子树 2）管道文件型结点 当Shell命令解释程序遇到管道算符“T”时，先为之建立一个管道文件型结点，再将 分隔符左面部分构成该结点的左子树，右面部分构成 右子树。例如对下面的命令行所构成的命令树如图9-4 所示： Command11Command21Command3 3）简单命令型结点 Commandl 对于简单命令，在命令行中仅有一条命令，它是 属于可以立即执行的命令，系统无需为它建立二叉树 结构的命令行树。当命令解释程序读入键盘缓冲区中 Command2 Command3 的命令后，若判定它是简单命令，再进一步确定是否 是内部命令。Shell解释程序本身提供了内部命令的可图9-4管道文件型结点及其左、右子树 执行程序，因此若是内部命令，Shell便立即执行，此时Shell也不需要为该命令创建新进 程。如果不是内部命令也非特殊命令，Shell将认为该命令是一个可执行文件，于是将为它 创建一个新进程，并作为Shell的子进程执行，直到子进程运行完毕，又恢复Shell运行。\n\n3.Linux命令解释程序的工作流程 在Linux系统中，系统初启后，内核为每个终端用户建立一个进程，去执行Shell解释 程序。它的执行过程基本上按如下步骤进行：\n\n(1）读取用户由键盘输入的命令行。用户键入的信息送入键盘缓冲区中保存。一旦用 户键入回车符，表示本次命令已结束，于是系统立即把控制权交给命令解释程序。它首先 292  第九章操作系统接口 从缓冲区中读取用户输入的命令。 看命令行中的命令，对命令和分隔符进行分析，建立相应的二叉树结构命令行树。并以命 令名作为文件名，将其它参数改造为系统调用execve内部处理所要求的形式。\n\n(3）建立相应的子进程。终端进程调用fork，为二叉树结构命令行中的每一条命令建立 相应的子进程。\n\n（4）等待子进程完成。对于“；”型结点，需在其左子树执行完成后，才可继续处理下 一条命令。故终端进程本身需要调用系统调用Wait40来等待子进程完成。当子进程运行时 调用execve（），子进程根据文件名（即命令名)到目录中查找有关文件，将它调入内存，执行 这个程序；当子进程完成处理后终止，向父进程（终端进程）报告，此时终端进程醒来，在 做必要的判别等工作后，继续处理下一条命令重复上述处理过程。\n\n（5）对于“&”型结点，在启动其左子结点执行后，因它是后台命令，不需要等待，因 此终端进程不用系统调用Wait4（），而是再执行其右子树。 Shell基本执行过程及父子进程之间的关系如图9-5所示。 终端进程 子进程 读入命令行 调度到 execve(）更换 进程映像 子进程 分离命令名， 按execveO的 要求放置参数 运行命令对应的 可执行文件 id-forkO ExitO终止 创建子进程 放弃CPU 子进程 id=0? #0 =0 父进程 无 子进程终止 有“&”？ 向父进程报告 有 WaitO等待 子进程终止 发提示符“S” 图9-5Shell基本执行过程及父子进程之间的关系 系统调用的概念和类型 程序接口，是OS专门为用户程序设置的，提供给程序员在编程时使用，也是用户程 序取得OS服务的唯一途径。它是由一组系统调用(systemcall)组成，因而，也可以说，系 293"
          }
        ]
      },
      {
        "二级标题": "9.4_系统调用的概念和类型",
        "三级内容": [
          {
            "三级标题": "9.4.1 系统调用的基本概念 在计算机系统中，通常运行着两类程序：系统程序和应用程序。为了防止应用程序对 OS的破坏，应用程序和OS的内核是运行在不同的状态，即OS的内核是运行在系统态， 而应用程序是运行在用户态。产",
            "正文": "1.系统态和用户态 如在2.3.1小节中所述，在计算机系统中设置了两种状态：系统态（或称为核心态）和用 户态。在实际运行过程中，处理机会在系统态和用户态间切换。相应地，现代多数OS将 CPU的指令集分为特权指令和非特权指令两类。\n\n（1）特权指令。特权指令是指在系统态运行的指令，它对内存空间的访问范围基本不受限 制，不仅能访问用户空间，也能访问系统空间。如启动外部设备、设置系统时钟时间、关中 断、转换执行状态等。特权指令只允许OS使用，不允许应用程序使用，以避免引起系统混乱。\n\n（2）非特权指令。非特权指令是在用户态运行的指令。应用程序所使用的都是非特权 指令，它只能完成一般性的操作和任务，不能对系统中的硬件和软件直接进行访问，对内 存的访问范围也局限于用户空间。这样，可以防止应用程序的运行异常对系统造成破坏。 这种限制是由硬件实现的，如果在应用程序中使用了特权指令，就会发出权限出错信 号，操作系统捕获到这个信号后，将转入相应的错误处理程序，将停止该应用程序的运行， 重新调度。\n\n2.系统调用 在OS中提供系统调用的目的，是使应用程序可以通过它间接调用OS中的相关过程， 取得相应的服务。系统调用在本质上是应用程序请求OS内核完成某功能时的一种过程调 用，但它是一种特殊的过程调用，它与一般的过程调用有下述几方面的明显差别：\n\n（1）运行在不同的系统状态。一般的过程调用其调用程序和被调用程序运行在相同的 状态一一系统态或用户态；而系统调用与一般调用的最大区别就在于：调用程序是运行在 用户态，而被调用程序是运行在系统态。\n\n(2）状态的转换。由于一般的过程调用并不涉及到系统状态的转换，所以可直接由调 用过程转向被调用过程。但在运行系统调用时，由于调用和被调用过程是工作在不同的系 统状态，因而不允许由调用过程直接转向被调用过程，需要通过软中断机制，先由用户态 转换为系统态，经内核分析后，才能转向相应的系统调用处理子程序。\n\n(3）返回问题。在采用了抢占式（剥夺)调度方式的系统中，在被调用过程执行完后，要 对系统中所有要求运行的进程做优先权分析。当调用进程仍具有最高优先级时，才返回到 调用进程继续执行；否则，将引起重新调度，以便让优先权最高的进程优先执行。此时， 将把调用进程放入就绪队列。\n\n（4）嵌套调用。像一般过程一样，系统调用也可以嵌套进行，即在一个被调用过程的 执行期间，还可以利用系统调用命令去调用另一个系统调用。当然，每个系统对嵌套调用 294  第九章操作系统接口 的深度都有一定的限制，例如最大深度为6。但一般的过程对嵌套的深度则没有什么限制。 图9-6示出了没有嵌套及有嵌套的两种系统调用情况。 用户程序 系统调 系统调 用命令 系统功能 用命令 系统功能 调用 调用 系统调 用命令调用系统子功能 返回 返回 返回 (a)系统调用与返回 (b）程序之间的嵌套调用 图9-6系统功能的调用 我们可以通过一个简单的例子来说明在用户程序中是如何使用系统调用的。例如，要 写一个简单的程序，用于从一个文件中读出数据，再将该数据拷贝到另一文件中。为此， 首先须输入该程序的输入文件名和输出文件名。文件名可用多种方式指定，一种方式是由 程序询问用户两个文件的名字。在交互式系统中，该方式要使用一系列的系统调用，先在 屏幕上打印出一系列的提示信息，然后从键盘终端读入定义两个文件名的字符串。 一旦获得两个文件名后，程序又必须利用系统调用open去打开输入文件，并用系统调 用creat去创建指定的输出文件；在执行open系统调用时，又可能发生错误。例如，程序 试图去打开一个不存在的文件；或者，该文件虽然存在，但并不允许被访问等。此时，程 序又须利用多条系统调用去显示出错信息，继而再利用一系统调用，去实现程序的异常终 止。类似地，在执行系统调用creat时，同样可能出现错误。例如，系统中早已有了与输出 文件同名的另一文件，这时又须利用一系统调用来结束程序；或者利用一系统调用来删除 已存在的那个同名文件，然后，再利用creat来创建输出文件。 在打开输入文件和创建输出文件都获得成功后，还须利用申请内存的系统调用alloc， 根据文件的大小，申请一个缓冲区。成功后，再利用read系统调用，从输入文件中把数据 读到缓冲区内。读完后，又用系统调用close去关闭输入文件。然后，再利用write系统调 用把缓冲区内的数据写到输出文件中。在读或写操作中，也都可能需要回送各种出错信息。 比如，在输入时，可能发现已到达文件末尾（指定的字符数尚未读够）：或者，在读过程中， 发现硬件故障（如奇、偶错）；在写操作中，可能遇见各种与输出设备类型有关的错误，比 如，已无磁盘空间，打印机缺纸等。在将整个文件拷贝完后，程序又须调用close去关闭输 出文件，并向控制台写出一消息，以指示拷贝完毕。最后，再利用一系统调用exit使程序 正常结束。由上所述可见，一个用户程序将频繁地利用各种系统调用，以取得OS所提供 的多种服务。\n\n3.中断机制 系统调用是通过中断机制实现的，并且一个操作系统的所有系统调用，都通过同一个 中断入口来实现。如MS-DOS提供了INT21H，应用程序通过该中断获取操作系统的服务。 对于拥有保护机制的OS来说，中断机制本身也是受保护的，在IBMPC上，Intel提 供了多达255个中断号，但只有授权给应用程序保护等级的中断号，才是可以被应用程序 295  计算机操作系统 调用的。对于未被授权的中断号，如果应用程序进行调用，同样会引起保护异常，而导致 自己被操作系统停止。如Linux仅仅给应用程序授权了4个中断号：3，4，5，以及80h。前 三个中断号是提供给应用程序调试所使用的，而80h正是系统调用(systemcall)的中断号。"
          },
          {
            "三级标题": "9.4.2 系统调用的类型 现在所有的通用OS都提供了许多系统调用，但它们所提供的系统调用会有一定的差 异。对于一般通用的OS而言，可将系统调用分为如下三大类。",
            "正文": "1.进程控制类系统调用 主要用于对进程控制的系统调用有：\n\n（1）创建和终止进程的系统调用。利用创建进程的系统调用，为欲参加并发执行的程 序创建一个进程。当进程已经执行结束时，利用终止进程的系统调用来终止该进程的运行。\n\n（2）获得和设置进程属性的系统调用。进程的属性包括有进程标识符、进程优先级、 最大允许执行时间等。利用获得进程属性的系统调用来了解某进程的属性，利用设置进程 属性的系统调用来确定和重新设置进程的属性。\n\n(3）等待某事件出现的系统调用。进程在运行过程中，需要等待某事件（条件）出现后方 可继续执行。此时进程可利用等待（事件）的系统调用，使自己处于等待状态，一旦等待的 事件出现，便可将等待进程唤醒。\n\n2.文件操纵类系统调用 对文件进行操纵的主要系统调用如下：\n\n（1）创建和删除文件。利用创建文件的系统调用请求系统创建一个新文件。利用删除 文件的系统调用将指名文件删除。\n\n（2）打开和关闭文件的系统调用。用户在第一次访问某个文件之前，应先利用打开文 件的系统调用将指名文件打开。利用关闭文件的系统调用将指定文件关闭。\n\n(3）读和写文件的系统调用。用户可利用读系统调用从已打开的文件中读出给定数目 的字符，并送至指定的缓冲区中：也可利用写系统调用从指定的缓冲区中将给定数目的字 符写入文件中。读和写系统调用是文件操纵类中使用最频繁的系统调用。\n\n3.进程通信类系统调用 在单处理机系统中，OS经常采用消息传递方式和共享存储区方式。当采用消息传递方 式时，在通信前需先打开一个连接。为此，应由源进程发出一条打开连接的系统调用，而 目标进程则应利用接受连接的系统调用表示同意进行通信；然后，在源和目标进程之间便 可开始通信。可以利用发送消息的系统调用或者用接收消息的系统调用来交换信息。通信 结束后，还须再利用关闭连接的系统调用结束通信。 用户在利用共享存储区进行通信之前，须先利用建立共享存储区的系统调用来建立一 个共享存储区，再利用建立连接的系统调用将该共享存储区连接到进程自身的虚地址空间 上，然后便可利用读和写共享存储区的系统调用实现相互通信。 除上述三类系统调用外，常用的系统调用还包括设备管理类系统调用和信息维护类系 统调用，前者主要用于实现申请设备、释放设备、设备I/O和重定向、获得和设置设备属 性等功能，后者主要用来获得包括有关系统和文件的时间、日期信息、操作系统版本、当 296  第九章操作系统接口 前用户以及有关空闲内存和磁盘空间大小等多方面的信息。"
          }
        ]
      },
      {
        "二级标题": "9.5_UNIX系统调用",
        "三级内容": [
          {
            "三级标题": "9.4.3 POSIX标准 一一一← 目前许多操作系统都提供了上面所介绍的各种类型的系统调用，实现的功能也相类似， 但在实现的细节和形式方面却相差很大，这种差异给实现应用程序与操作系统平台的无关性 带来了很大的困难。为解决这一问题，国际标准化组织ISO给出的有关系统调用的国际标准 POSIX定义了标准应用程序接口（API)，用于保证编制的应用程序可以在源代码一级上 在多种操作系统上移植运行。只有符合这一标准的应用程序，才有可能完全兼容多种操作 系统，即在多种操作系统下都能够运行。 POSIX标准定义了一组过程，这组过程是构造系统调用所必须的，通过调用这些过程 所提供的服务，确定了一系列系统调用的功能。一般而言，在POSIX标准中，大多数的系 统调用是一个系统调用直接映射一个过程，但也有一个系统调用对应若干个过程的情形，如 当一个系统调用所需要的过程是其它系统调用的组合或变形时，则往往会对应多个过程。 需要明确的是，POSIX标准所定义的一组过程虽然指定了系统调用的功能，但并没有 明确规定系统调用以什么形式实现，是库函数还是其它形式。如早期操作系统的系统调用 使用汇编语言编写，这时的系统调用可看成扩展的机器指令，因而，能在汇编语言编程中 直接使用。而在一些高级语言或C语言中，尤其是最新推出的一些操作系统，如UNIX新 版本、Linux、Windows和OS/2等，其系统调用干脆用C语言编写，并以库函数形式提供， 所以在用C语言编制的应用程序中，可直接通过使用对应的库函数来使用系统调用，库函 数的目的是隐藏访管指令的细节，使系统调用更像过程调用。但一般地说，库函数属于用 户程序而非系统调用程序。如图9-7示出了UNIX/Linux的系统程序、库函数、系统调用的 层次关系。 用户接口 用户 库函数接口 标准系统程序（实用程序） 系统程序：汇编、编译、编辑、Shell 系统调用接口 标准库函数 标准函数：打开、关闭、读、写、创建、撤销 操作系统 系统调用：进程管理、有储管理、文件管理、设备管理 图9-7UNIX/Linux系统程序、库函数、系统调用的分层关系",
            "正文": "9.5 UNIX系统调用 在上一节中，我们对系统调用做了一般性的描述。为使读者能对系统调用有较具体的 297  计算机操作系统 了解，在本节中将对UNIX系统中的系统调用作扼要的阐述。在UNIX系统V最早的版本 中，提供了56条系统调用；后来，随着版本的不断翻新，所提供的系统调用也不断增加， 其数量已增至数百条，其中较常用的系统调用大约有30多条。根据其功能的不同，我们同 样可将它们分为：进程控制、文件操纵、进程间通信和信息维护等几大类。"
          },
          {
            "三级标题": "9.5.1 进程控制 一← 该类系统调用包括创建进程的系统调用fork、终止进程的系统调用exit、等待子进程 结束的系统调用wait等十多条。",
            "正文": "1.进程的创建和终止\n\n（1）创建进程（fork)。一个进程可以利用fork系统调用来创建一个新进程。新进程作为 调用者的子进程，它继承了其父进程的环境、已打开的所有文件、根目录和当前目录等， 即它继承了父进程几乎所有的属性，并具有与其父进程基本上相同的进程映像。\n\n(2）终止进程（exit)。一个进程可以利用exit实现自我终止。通常，在父进程创建子进 程时，便在子进程的末尾安排一条exit系统调用。这样，子进程在完成规定的任务后，便 可进行自我终止。子进程终止后，留下一条记账信息status，其中包含了子进程运行时记录 下来的各种统计信息。\n\n2.改变进程映像和等待 一个可执行的文件覆盖，此即改变调用者进程的进程映像。该系统调用是UNIX系统中最 复杂的系统调用之一。\n\n(2）等待子进程结束（wait)。wait用于将调用者进程自身挂起，直至它的某一子进程终 止为止。这样，父进程可以利用wait使自身的执行与子进程的终止同步。\n\n3.其它进程调用\n\n（1）获得进程ID。UNIX系统提供了一组用于获得进程标识符的系统调用，比如，可 利用getp-id系统调用来获得调用进程的标识符，利用getpgrp系统调用来获得调用进程的 进程组ID，以及利用getppid系统调用来获得调用进程的父进程ID等。 于获得真正的用户ID，geteuid用于获得有效用户ID，getgid用于获得真正用户组ID等。\n\n(3）进程暂停(pause)。可用此系统调用将调用进程挂起，直至它收到一个信号为止。"
          },
          {
            "三级标题": "9.5.2 文件操纵 用于对文件进行操纵的系统调用是数量最多的一类系统调用，其中包括创建文件、打 开文件、关闭文件、读文件及写文件等二十多条。",
            "正文": "1.文件的创建和删除\n\n(1）创建文件(creat)。系统调用creat 的功能是根据用户提供的文件名和许可权方式， 来创建一个新文件或重写一个已存文件。如果系统中不存在指名文件，核心便以给定的文 件名和许可权方式，来创建一个新文件；如果系统中已有同名文件，核心便释放其已有的数 据块。创建后的文件随即被打开，并返回其文件描述符fd。若creat执行失败，便返回“-1”。 298  第九章操作系统接口\n\n(2）删除文件。在UNIX系统中没有专门的删除文件的系统调用，故无人可对文件进 行删除，只有当文件的确已无人需要时才删除它。在建立与文件的连接和去连接系统调用 中作进一步的说明。\n\n2.文件的打开和关闭\n\n(1）打开文件(open)。设置系统调用open 的目的是为了方便用户及简化系统的处理。 open的功能是把有关的文件属性从磁盘拷贝到内存中，以及在用户和指名文件之间建立一 都只须使用fd而非路径名。 即断开用户程序与该文件之间已经建立的快捷通路。在UNIX系统中，由于允许一个文件 被多个进程所共享，故只有在无其他任何进程再需要对它进行访问时，或者说，在对其索 引结点中的访问计数i-count执行减1操作后其值为0，表示已无进程再访问该文件时，才 能真正关闭该文件。\n\n3.文件的读和写 读和写文件的系统调用是read和write。仅当用户利用open打开指定文件后，方可调 用read或write对文件执行读或写操作。两个系统调用都要求用户提供三个输入参数：①文 件描述符fd。②buf缓冲区首址。对读而言，这是用户所要求的信息传送的目标地址；对 写而言，则是信息传送的源地址。③用户要求传送的字节数nbyte。 系统调用read的功能是试图从fd所指示的文件中去读入nbyte个字节的数据，并将它 们送至由指针buf所指示的缓冲区中；系统调用write的功能是试图把nbyte个字节数据从 指针buf所指示的缓冲区中写到由fd所指向的文件中。\n\n4.建立与文件的连接和去连接\n\n(1）连接(link)。为了实现文件共享，必须记住所有共享该文件的用户数目。为此，在 该文件的索引结点中设置了一个连接计数ilink。每当有一用户要共享某文件时，须利用系 统调用link来建立该用户（进程）与此文件之间的连接，并对i.link做加1操作。\n\n（2）去连接（unlink)。当用户不再使用此文件时，应利用系统调用unlink去断开此连接， 亦即做i.link的减1操作。当i.link减1后结果为0时，表示已无用户需要此文件，此时才 能将该文件从文件系统中删除。故在UNIX系统中并无一条删除文件的系统调用。"
          },
          {
            "三级标题": "9.5.3 进程通信和信息保护",
            "正文": "1.进程通信 为了实现进程间的通信，在UNIX系统中提供了一个用于进程间通信的软件包，简称 IPC。它由消息机制、共享存储器机制和信号量机制三部分组成。在每一种通信机制中，都 提供了相应的系统调用供用户程序进行进程间的同步与通信用。\n\n(1）消息机制。用户(进程)在利用消息机制进行通信时，必须先利用msgget系统调用 来建立一个消息队列。若成功，便返回消息队列描述符msgid，以后用户便可利用msgid 去访问该消息队列。用户(进程)可利用发送消息的系统调用msgsend向用户指定的消息队 列发送消息；利用msgrcv系统调用从指定的消息队列中接收指定类型的消息。 299  计算机操作系统\n\n(2）共享存储器机制。当用户(进程)要利用共享存储器机制进行通信时，必须先利用 shmget系统调用来建立一个共享存储区，若成功，便返回该共享存储区描述符shmid。以 后，用户便可利用shmid去访问该共享存储区。进程在建立了共享存储区之后，还必须再 利用shmat将该共享存储区连接到本进程的虚地址空间上。以后，在进程之间便可利用该 共享存储区进行通信。当进程不再需要该共享存储区时，可利用shmdt系统调用来拆除进 程与共享存储区间的连接。\n\n2.信息维护 在UNIX系统中，设置了许多条用于系统维护的系统调用，下面介绍常用的几条。\n\n（1）设置和获得时间。超级用户可利用设置时间的系统调用（stime）来设置系统的日期和 时间：如果调用进程并非超级用户，则stime失败；一般用户可利用获得时间的系统调用 time来获得当前的日期和时间。\n\n(2）获得进程和子进程时间（times)。利用该系统调用可获得进程及其子进程所使用的 CPU时间，其中包括调用进程在用户空间执行指令所花费的时间，系统为调用进程所花费 的CPU时间，子进程在用户空间所用的CPU时间，系统为各子进程所花费的CPU时间等， 并可将这些时间填写到一个指定的缓冲区。\n\n（3）设置文件访问和修改时间（utime)。该系统调用用于设置指名文件被访问和修改的 时间。如果该系统调用的参数times为NULL，则文件主和对该文件具有写权限的用户可 将对该文件的访问和修改时间设置为当前时间；如果times不为NULL，则把times解释 为指向utimbuf结构的指针，此时，文件主和超级用户能将访问时间和修改时间置入utim buf结构中。\n\n（4）获得当前UNIX系统的名称（uname)。利用该系统调用可将有关UNIX系统的信息 存储在utsname结构中。这些信息包括UNIX系统名称的字符串、系统在网络中的名称、硬 件的标准名称等。 /9.6系统调用的实现 系统调用的实现与一般过程调用的实现相比，两者间有很大差异。对于系统调用，控 制是由原来的用户态转换为系统态，这是借助于陷入机制来完成的，在该机制中包括陷入 硬件机构及陷入处理程序两部分。当应用程序使用OS的系统调用时，产生一条相应的指 令，CPU在执行这条指令时发生中断，并将有关信号送给中断和陷入硬件机构，该机构收 到信号后，启动相关的陷入处理程序进行处理，实现该系统调用所需要的功能。"
          },
          {
            "三级标题": "9.6.1 系统调用的实现方法 一一一←",
            "正文": "1.系统调用号和参数的设置 号。在系统调用命令（陷入指令）中把相应的系统调用号传递给中断和陷入机制的方法有很 300"
          }
        ]
      },
      {
        "二级标题": "9.6_系统调用的实现",
        "三级内容": [
          {
            "三级标题": "9.6.1 系统调用的实现方法 一一一←",
            "正文": "1.系统调用号和参数的设置 号。在系统调用命令（陷入指令）中把相应的系统调用号传递给中断和陷入机制的方法有很 300  第九章操作系统接口 多，在有的系统中，直接把系统调用号放在系统调用命令(陷入指令)中，如IBM370和早 期的UNIX系统，是把系统调用命令的低8位用于存放系统调用号；在另一些系统中，则 将系统调用号装入某指定寄存器或内存单元中，如MS-DOS是将系统调用号放在AH寄存 每一条系统调用都含有若干个参数，在执行系统调用时，如何设置系统调用所需的参 数，即如何将这些参数传递给陷入处理机构和系统内部的子程序（过程），常用的实现方式 有以下儿种：\n\n（1）陷入指令自带方式。陷入指令除了携带一个系统调用号外，还要自带几个参数进 入系统内部，由于一条陷入指令的长度是有限的，因此自带的只能是少量的、有限的参数。\n\n(2）直接将参数送入相应的寄存器中。MS-DOS便是采用的这种方式，即用MOV指 令将各个参数送入相应的寄存器中。系统程序和应用程序都可以对这些寄存器进行访问。 这种方式的主要问题是这种寄存器数量有限，限制了所设置参数的数目。\n\n(3）参数表方式。将系统调用所需的参数放入一张参数表中，再将指向该参数表的指 针放在某个指定的寄存器中。当前大多数的OS中，如UNIX系统和Linux系统，便是采 用了这种方式。该方式又可进一步分成直接方式和间接方式，如图9-8所示。在直接参数 方式中，所有的参数值和参数的个数N都放入一张参数表中；而在间接参数方式中，则在 参数表中仅存放参数个数和指向真正参数数据表的指针。 变元表： 变元表： N trap XX N 参数1 指针 参数1 参数2 参数2 ： 参数n 参数n (a)直接方式 (b)间接方式 图9-8系统调用的参数形式\n\n2.系统调用的处理步骤 在设置了系统调用号和参数后，便可执行一条系统调用命令。不同的系统可采用不同 的执行方式。在UNIX系统中，是执行CHMK命令；而在MS-DOS中则是执行INT21软 中断。系统调用的处理过程可分成以下三步： 首先，将处理机状态由用户态转为系统态；之后，由硬件和内核程序进行系统调用的 一般性处理，即首先保护被中断进程的CPU环境，将处理机状态字PSW、程序计数器PC、 系统调用号、用户栈指针以及通用寄存器内容等压入堆栈；然后，将用户定义的参数传送 到指定的地址并保存起来。 其次，分析系统调用类型，转入相应的系统调用处理子程序。为使不同的系统调用能 方便地转向相应的系统调用处理子程序，在系统中配置了一张系统调用入口表。表中的每 个表日都对应一条系统调用，其中包含该系统调用自带参数的数目、系统调用处理子程序 301  计算机操作系统 的入口地址等。因此，核心可利用系统调用号去查找该表，即可找到相应处理子程序的入 口地址而转去执行它。 最后，在系统调用处理子程序执行完后，应恢复被中断的或设置新进程的CPU现场， 然后返回被中断进程或新进程，继续往下执行。\n\n3.系统调用处理子程序的处理过程 系统调用的功能主要是由系统调用子程序来完成的。对于不同的系统调用，其处理程 序将执行不同的功能。我们以一条在文件操纵中常用的Creat命令为例来说明之。 进入Creat的处理子程序后，核心将根据用户给定的文件路径名Path，利用目录检索 过程去查找指定文件的目录项。查找目录的方式可以用顺序查找法，也可用Hash查找法。 如果在文件目录中找到了指定文件的目录项，表示用户要利用一个已有文件来建立一个新 文件。但如果在该已有（存)文件的属性中有不允许写属性，或者创建者不具有对该文件进 行修改的权限，便认为是出错而做出错处理；若不存在访问权限问题，便将已存文件的数 据盘块释放掉，准备写入新的数据文件。如未找到指名文件，则表示要创建一个新文件， 核心便从其目录文件中找出一个空目录项，并初始化该目录项，包括填写文件名、文件属 性、文件建立日期等，然后将新建文件打开。"
          },
          {
            "三级标题": "9.6.2 UNIX系统调用的实现 在UNIX系统V的内核程序中，有一个trap.S文件，它是中断和陷入总控程序。该程 序用于中断和陷入的一般性处理。为提高运行效率，该文件采用汇编语言编写。由于在trap.S 中包含了绝大部分的中断和陷入向量的入口地址，因此，每当系统发生了中断和陷入情况 时，通常都是先进入trap.S程序，由它先处理有关CPU环境保护的问题。 另外还有一个处理各种陷入情况的C语言文件，即trap.C程序，共有12种陷入的处 理要调用trap.C程序（如系统调用、进程调度中断、跟踪自陷非法指令、访问违章、算术自 陷等)用于处理在中断和陷入发生后需要处理的若干公共问题。如果因系统调用进入trap.C， 它所要进行的处理将包括：确定系统调用号、实现参数传送、转入相应的系统调用处理子 程序。在由系统调用处理子程序返回到trap.C后，重新计算进程的优先级，对收到的信号 进行处理等。",
            "正文": "1.CPU环境保护 当用户程序处在用户态，且在执行系统调用命令（即CHMIK命令）之前，应在用户空间 提供系统调用所需的参数表，并将该参数表的地址送入R寄存器。在执行CHMK命令后， 处理机将由用户态转为核心态，并由硬件自动地将处理机状态长字(PSL)、程序计数器(PC） 然后便转入中断和陷入总控程序trap.s中执行。 trap.S程序执行后，继续将陷入类型type和用户栈指针usp压入用户核心栈，接着还 要将被中断进程的CPU环境中的一系列寄存器如Ro～Rn的部分或全部内容压入栈中。 至于哪些寄存器的内容要压入栈中，这取决于特定寄存器中的屏蔽码，该屏蔽码的每一 位都与Ro～R11中的一个寄存器相对应。当某一位置成1时，表示对应寄存器的内容应压 入栈中。 302  第九章操作系统接口\n\n2.AP和FP指针 为了实现系统调用的嵌套使用，在系统中还设置了两个 AP 指针，其一是系统调用参数表指针AP，用于指示正在执行 FP 由中断和 的系统调用所需参数表的地址，通常是把该地址放在某个寄 Ro 陷入总控 存器中，例如放在R12中；再者，还须设置一个调用栈帧指 程序压入 针。所谓调用栈帧(或简称栈帧)，是指每个系统调用需要保 Rn 存而被压入用户核心栈的所有数据项：而栈帧指针FP则是 usp 用于指示本次系统调用所保存的数据项。每当出现新的系统 type 陷入时由 调用时，还须将AP和FP303压入栈中，图9-9示出了在trap.S code 硬件压入 总控程序执行后用户核心栈的情况。 PC 当trap.S完成被中断进程的CPU环境和AP及FP指针 PSL 的保存后，将会调用由C语言书写的公共处理程序trap.C， 用户核心栈 以继续处理本次的系统调用所要完成的公共处理部分。 图9-9用户核心栈\n\n3.确定系统调用号 由上所述得知，在中断和陷入发生后，应先经硬件陷入机构予以处理，再进入中断和 陷入总控程序trap.S，在保护好CPU现场后再调用trap.C继续处理。其调用形式为： trap(usp,type,code,PC，PSL) 其中，参数PSL为陷入时处理机状态字长，PC为程序计数器，code 为代码操作数，type 为陷入类型号，uSp为用户栈指针。对陷入的处理可分为多种情况，如果陷入是由于系统调 用所引起的，则对此陷入的第一步处理便是确定系统调用号。通常，系统调用号包含在代 码操作数中，故可利用code来确定系统调用号i。其方法是：令 i=code&0377 若0<i<64，此i便是系统调用号，可根据系统调用号i和系统调用定义表，转向相应的 处理子程序。若i=0，则表示系统调用号并未包含在代码操作数中，此时应采用间接参数 方式，利用间接参数指针来找到系统调用号。\n\n4.参数传送 参数传送是指由trap.C程序将系统调用参数表中的内容从用户区传送到User结构的 U.U-arg中，供系统调用处理程序使用。由于用户程序在执行系统调用命令之前已将参数表 的首址放入Ro寄存器中，在进入trap.C程序后，该程序便将该首址赋予U.U-arg指针，因 此，trap.C在处理参数传送时，可读取该指针的内容，以获得用户所提供的参数表，并将 之送至U.U-arg中。应当注意，对不同的系统调用所需传送参数的个数并不相同，trap.C程\n\n5.利用系统调用定义表转入相应的处理程序 在UNIX系统中，对于不同(编号)的系统调用，都设置了与之相应的处理子程序。为 使不同的系统调用能方便地转入其相应的处理子程序，也将各处理子程序的入口地址放入 了系统调用定义表即Sysent切中。该表实际上是一个结构数组，在每个结构中包含三个元素， 参数个数；第三个元素是相应系统调用处理子程序的入口地址。在系统中设置了该表之后， 303  计算机操作系统 便可根据系统调用号1从系统调用定义表中找出相应的表目，再按照表目中的入口地址转 入相应的处理子程序，由该程序去完成相应系统调用的特定功能。在该子程序执行完后， 仍返回到中断和陷入总控程序中的trap.C程序中，去完成返回到断点前的公共处理部分。\n\n6.系统调用返回前的公共处理 在UNIX系统中，进程调度的主要依据是进程的动态优先级。随着进程执行时间的加 长，其优先级将逐步降低。每当执行了系统调用命令并由系统调用处理子程序返回到trap.C 后，都将重新计算该进程的优先级；另外，在系统调用执行过程中，若发生了错误使进程 无法继续运行时，系统会设置再调度标志。处理子程序在计算了进程的优先级后，又去检 查该再调度标志是否已又被设置。若已设置，便调用switch调度程序，再去从所有的就绪 进程中选择优先级最高的进程，把处理机让给该进程去运行。 UNIX系统规定，当进程的运行是处于系统态时，即使再有其它进程又发来了信号， 也不予理踩；仅当进程已从系统态返回到用户态时，内核才检查该进程是否已收到了由其 它进程发来的信号。若有信号，便立即按该信号的规定执行相应的动作。在从信号处理程 序返回后，还将执行一条返回指令RET，该指令将把已被压入用户核心栈中的所有数据（如 PSL、PC、FP及AP等）都退还到相应的寄存器中，这样，即可将CPU控制权从系统调用 返回到被中断进程，后者继续执行下去。"
          },
          {
            "三级标题": "9.6.5 Linux系统调用 一 与UNIX相似，Linux采用类似技术实现系统调用。Linux系统在CPU的保护模式下 提供了四个特权级别，目前内核都只用到了其中的两个特权级别，分别为“特权级0”（即 内核态）和“特权级3”（即用户态）。用户对系统调用不能任意拦截和修改，以保证内核的 安全性。Linux最多可以有190个系统调用。应用程序和Shell需要通过系统调用机制访问 Linux内核（功能)。每个系统调用由两部分组成：",
            "正文": "（1）内核函数：是实现系统调用功能的（内核）代码，作为操作系统的核心驻留在内存中， 是一种共享代码，用C语言书写。它运行在内核态，数据也存放在内核空间，通常它不能 再使用系统调用，也不能使用应用程序可用的库函数。\n\n（2）接口函数：是提供给应用程序的API，以库函数形式存在Linux的lib.a中，该库 中存放了所有系统调用的接口函数的目标代码，用汇编语言书写。其主要功能是：把系 统调用号、入口参数地址传送给相应的核心函数，并使用户态下运行的应用程序陷入核 心态。 Linux中有一个用汇编写的系统调用入口程序entry(sys_call_table)，它包含了系统调用 入口地址表，给出了所有系统调用核心函数的名字，而每个系统调用核心函数的编号由 include/asm/unistd.h定义： ENTRY(sys-call-table) longSYMBOL_NAME(sys_xxx)i Linux的系统调用号就是系统调用入口表中位置的序号。所有系统调用通过接口函数 将系统调用号传给内核，内核转入系统调用控制程序，再通过调用号位置来定位核心函数。 Linux内核的陷入由0x80（int80h)中断实现。 304  第九章操作系统接口 系统调用控制程序的工作流程为：①取系统调用号，检验合法性；②执行int80h产 生中断；③进行地址空间的转换，以及堆栈的切换，进入内核态；④进行中断处理，根 据系统调用号定位内核函数地址；③根据通用寄存器内容，从用户栈中取入口参数；④核 心函数执行，把结果返回应用程序。"
          },
          {
            "三级标题": "9.6.6 Win32的应用程序接口 首先需要说明的是应用程序接口（API)与系统调用的区别和联系。API是一个函数的定 义，说明如何获得一个给定的服务，而系统调用是通过中断向内核发出的一个请求。一个 API函数可能不与任何系统调用相对应，也可以调用若干个系统调用，不同的API函数可 能封装了相同的系统调用。 Windows系统在程序设计模式上与UNIX以及Linux系统有着根本的不同。Windows 程序采用的是事件驱动方式，即主程序等待事件的发生，如鼠标的点击、键盘的敲击或一 个USB部件的插入等，然后根据事件内容，调用相应的程序进行处理。因此，在Windows 系统中，定义了一系列的程序，称为Win32API(Application Programming interface)，用来提 供操作系统的服务。 通过对Win32API的调用，可以创建各种核心对象，如文件、进程、线程、管道等。 每次调用，创建一个对象，并将对象句柄返回给调用者。这个句柄是指向对象表的索引， 它是该对象的标识，通过句柄的地址，可以间接地知道对象在内存中的具体位置，因此可 用来对对象进行操作。一般句柄不能直接传递给其它进程使用，但在特定的环境下，可以 通过复制并受保护的方式传递给其它进程，实现对象的共享。每个对象都有一个安全描述 符，详细地描述了所有可以访问该对象的应用程序以及其访问权限。 能起关键作用的操作系统程序才能运行在核心态，如对象与安全管理器、线程与进程管理 器、虚存管理器、高速缓存管理器、文件系统等，这些程序构成了操作系统的执行体 (executive)。 在Intelx86处理机上，当应用程序（用户态的执行线程）调用操作系统服务时，都要执 行int2E指令，由硬件产生一个陷入信号，引发系统服务调度的产生。陷入信号被系统捕 入处理程序的系统服务调度程序。该程序首先关中断，保存中断现场和检查参数，将调用 参数从用户态堆栈复制到核心态堆栈，并通过查找“系统服务调度表”中的系统服务信息 获得给定服务，该表就是在前面介绍的陷入向量表。表中每个入口包含一个指向相应的系 统服务程序的指针。最后，系统服务调度程序把控制权转交给执行体中相应的系统服务程 序进行处理。 在Windows 系统中，通过Kernel、User和GUI三个组件来支持API。Kernel包含了 大多数操作系统函数，如内存管理、进程管理：User集中了窗口管理函数，如窗口创建、 撤销、移动、对话及各种相关函数；GUI提供画图函数、打印函数。所有应用程序都共享 这三个模块的代码，每个Windows的API函数都可通过名字来访问。具体做法是，在应用 程序中使用函数名，并用适当的函数库进行编译和链接，然后，应用程序便可运行。实际 上，Windows将三个组件置于动态链接库DLL(DynamicLinkLibrary)中。 305  计算机操作系统",
            "正文": "1.操作系统用户接口中包括哪几种接口？它们分别适用于哪种情况？\n\n2.什么是WIMP技术？它被应用到何种场合？\n\n3.联机命令通常有哪几种类型？每种类型中包括哪些主要命令？\n\n4.什么是输入输出重定向？举例说明之。\n\n5.何谓管道联接？举例说明之。\n\n6.为了将已存文件改名，应用什么UNIX命令？\n\n7.要想将工作目录移到目录树的某指定结点上，应使用什么命令？\n\n8.如果希望把file1的内容附加到原有的文件file2的末尾，应用什么命令？\n\n9.试比较mail和write命令的作用有何不同。\n\n10.联机命令接口由哪几部分组成？\n\n11.终端设备处理程序的主要作用是什么？它具有哪些功能？\n\n12.命令解释程序的主要功能是什么？\n\n13.试说明MS-DOS的命令处理程序COMMAND.COM的工作流程。\n\n14.Shell命令有何特点？它对命令解释程序有何影响。\n\n15.试举例说明如何建立二叉树结构的命令行树。\n\n16.试比较一般的过程调用与系统调用。\n\n17.系统调用有哪几种类型？\n\n18.如何设置系统调用所需的参数？\n\n19.试说明系统调用的处理步骤。\n\n20.为什么在访问文件之前，要用open系统调用先打开该文件？\n\n21.在UNIX系统中是否设置了专门用来删除文件的系统调用？为什么？\n\n22.在IPC软件包中包含哪几种通信机制？在每种通信机制中设置了哪些系统调用？\n\n23.trap.S是什么程序？它完成哪些主要功能？\n\n24.在UNIX系统内，被保护的CPU环境中包含哪些数据项？\n\n25.trap.C是什么程序？它将完成哪些处理？\n\n26.为方便转入系统调用处理程序，在UNIX系统中配置了什么样的数据结构？ 306"
          }
        ]
      }
    ]
  }
]
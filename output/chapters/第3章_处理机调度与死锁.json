[
  {
    "一级标题": "第3章_处理机调度与死锁",
    "二级内容": [
      {
        "二级标题": "3.1_处理机调度的层次和调度算法的目标",
        "三级内容": [
          {
            "三级标题": "3.1.1 处理机调度的层次 一一←",
            "正文": "1.高级调度(High Level Scheduling) 高级调度又称长程调度或作业调度，它的调度对象是作业。其主要功能是根据某种算 法，决定将外存上处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的 资源，并将它们放入就绪队列。高级调度主要用于多道批处理系统中，而在分时和实时系 统中不设置高级调度。\n\n2.低级调度(Low Level Scheduling) 低级调度又称为进程调度或短程调度，其所调度的对象是进程（或内核级线程）。其主 要功能是，根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处 理机分配给被选中的进程。进程调度是最基本的一种调度，在多道批处理、分时和实时三 种类型的OS中，都必须配置这级调度。\n\n3.中级调度(IntermediateScheduling) 中级调度又称为内存调度。引入中级调度的主要目的是，提高内存利用率和系统吞吐 量。为此，应把那些暂时不能运行的进程，调至外存等待，此时进程的状态称为就绪驻外 存状态（或挂起状态）。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定， 把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态， 85  计算机操作系统 挂在就绪队列上等待。中级调度实际上就是存储器管理中的对换功能，将在第四章中介绍。 在上述三种调度中，进程调度的运行频率最高，在分时系统中通常仅10～100ms便进 行一次进程调度，因此把它称为短程调度。为避免调度本身占用太多的CPU时间，不宜使 进程调度算法太复杂。作业调度往往是发生在一批作业已运行完毕并退出系统，又需要重 新调入一批作业进入内存时，作业调度的周期较长，大约几分钟一次，因此把它称为长程 调度。由于其运行频率较低，故充许作业调度算法花费较多的时间。中级调度的运行频率 基本上介于上述两种调度之间，因此把它称为中程调度。"
          },
          {
            "三级标题": "3.1.2 处理机调度算法的目标 一般而言，在一个操作系统的设计中，应如何选择调度方式和算法，在很大程度上取 决于操作系统的类型及其设计目标，例如，在批处理系统、分时系统和实时系统中，通常 都采用不同的调度方式和算法。",
            "正文": "1.处理机调度算法的共同目标\n\n（1）资源利用率。为提高系统的资源利用率，应使系统中的处理机和其它所有资源都 尽可能地保持忙碌状态，其中最重要的处理机利用率可用以下方法计算： CPU有效工作时间 CPU的利用率= CPU有效工作时间+CPU空闲等待时间\n\n(2）公平性。公平性是指应使诸进程都获得合理的CPU时间，不会发生进程饥饿现象。 公平性是相对的，对相同类型的进程应获得相同的服务；但对于不同类型的进程，由于其 紧急程度或重要性的不同，则应提供不同的服务。\n\n（3）平衡性。由于在系统中可能具有多种类型的进程，有的属于计算型作业，有的属 于IV/O型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能 保持系统资源使用的平衡性。\n\n（4）策略强制执行。对所制订的策略其中包括安全策略，只要需要，就必须予以准确 地执行，即使会造成某些工作的延迟也要执行。\n\n2.批处理系统的目标\n\n(1）平均周转时间短。所谓周转时间，是指从作业被提交给系统开始，到作业完成为 止的这段时间间隔（称为作业周转时间)。它包括四部分时间：作业在外存后备队列上等待 （作业)调度的时间，进程在就绪队列上等待进程调度的时间，进程在CPU上执行的时间， 以及进程等待IO操作完成的时间。其中的后三项在一个作业的整个处理过程中，可能发 生多次。 对每个用户而言，都希望自己作业的周转时间最短。但作为计算机系统的管理者，则总 是希望能使平均周转时间最短，这不仅会有效地提高系统资源的利用率，而且还可使大多数 用户都感到满意。应使作业周转时间和作业的平均周转时间尽可能短。否则，会使许多用户 的等待时间过长，这将会引起用户特别是短作业用户的不满。可把平均周转时间描述为： n 86  第三章处理机调度与死锁 为了进一步反映调度的性能，更清晰地描述各进程在其周转时间中，等待和执行时间 的具体分配状况，往往使用带权周转时间，即作业的周转时间T与系统为它提供服务的时 间T，之比，即W=T/T。而平均带权周转时间则可表示为： W=! nTs\n\n（2）系统吞吐量高。由于吞吐量是指在单位时间内系统所完成的作业数，因而它与批 处理作业的平均长度有关。事实上，如果单纯是为了获得高的系统吞吐量，就应尽量多地 选择短作业运行。\n\n（3）处理机利用率高。对于大、中型计算机，CPU价格十分昂贵，致使处理机的利用 率成为衡量系统性能的十分重要的指标：而调度方式和算法又对处理机的利用率起着十分 重要的作用。如果单纯是为使处理机利用率高，应尽量多地选择计算量大的作业运行。由 上所述可以看出，这些要求之间是存在着一定矛盾的。\n\n3.分时系统的目标\n\n（1）响应时间快。响应时间快是选择分时系统中进程调度算法的重要准则。所谓响应 时间，是从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间 间隔。它包括三部分时间：一是请求信息从键盘输入开始，直至将其传送到处理机的时间； 二是处理机对请求信息进行处理的时间：三是将所形成的响应信息回送到终端显示器的时间。\n\n(2）均衡性。用户对响应时间的要求并非完全相同。通常用户对较复杂任务的响应时 间允许较长，而对较简单任务的响应时间则要短。所谓均衡性，是指系统响应时间的快慢 应与用户所请求服务的复杂性相适应。\n\n4.实时系统的目标\n\n(1）截止时间的保证。所谓截止时间，是指某任务必须开始执行的最迟时间，或必须 完成的最迟时间。对于严格的实时系统，其调度方式和调度算法必须能保证这一点，否则 将可能造成难以预料的后果。对于实时系统而言，调度算法的一个主要目标是保证实时任 务对截止时间的要求。对于HRT任务，其调度方式和调度算法必须确保对截止时间的要求， 否则将可能造成难以预料的后果；而对于SRT任务，其调度方式和调度算法也应基本上能 保证对截止时间的要求。\n\n(2）可预测性。在实时系统中，可预测性显得非常重要。例如，在多媒体系统中，无 论是电影还是电视剧都应是连续播放的，这就提供了请求的可预测性。如果系统中采用了 双缓冲，则因为可实现第i帧的播放和第i+1帧的读取并行处理，进而可提高其实时性。\n\n3.2 2作业与作业调度 在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。操作员把用户 提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。再由 作业调度程序将其从外存调入内存。 87"
          }
        ]
      },
      {
        "二级标题": "3.2_作业与作业调度",
        "三级内容": [
          {
            "三级标题": "3.2.1 批处理系统中的作业",
            "正文": "1.作业和作业步\n\n（1）作业(Job)。作业是一个比程序更为广泛的概念，它不仅包含了通常的程序和数据， 而且还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。在批处理系 统中，是以作业为基本单位从外存调入内存的。\n\n(2）作业步（JobStep)。通常，在作业运行期间，每个作业都必须经过若干个相对独立， 又相互关联的顺序加工步骤才能得到结果。我们把其中的每一个加工步骤称为一个作业步， 各作业步之间存在着相互联系，往往是上一个作业步的输出作为下一个作业步的输入。例\n\n2.作业控制块（JobControlBlock，JCB) 为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB， 它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。 通常在JCB中包含的内容有：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、 I/O繁忙型、批量型、终端型）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预 计运行时间、要求内存大小等）、资源使用情况等。 每当一个作业进入系统时，便由“作业注册”程序为该作业建立一个作业控制块JCB。 再根据作业类型，将它放到相应的作业后备队列中等待调度。调度程序依据一定的调度算 法来调度它们，被调度到的作业将被装入内存。在作业运行期间，系统就按照JICB中的信 息和作业说明书对作业进行控制。当一个作业执行结束进入完成状态时，系统负责回收已 分配给它的资源，撤销该作业控制块。\n\n3.作业运行的三个阶段和三种状态 作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应的作业 也就有“后备状态”、“运行状态”和“完成状态”。\n\n（1）收容阶段。操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬 盘上，再为该作业建立JCB，并把它放入作业后备队列中。相应地，此时作业的状态为“后 备状态”。\n\n(2）运行阶段。当作业被作业调度选中后，便为它分配必要的资源和建立进程，并将 它放入就绪队列。一个作业从第一次进入就绪状态开始，直到它运行结束前，在此期间都 处于“运行状态”。\n\n（3）完成阶段。当作业运行完成、或发生异常情况而提前结束时，作业便进入完成阶 段，相应的作业状态为“完成状态”。此时系统中的“终止作业”程序将会回收已分配给该 作业的作业控制块和所有资源，并将作业运行结果信息形成输出文件后输出。"
          },
          {
            "三级标题": "3.2.2 作业调度的主要任务 作业调度的主要任务是，根据JCB中的信息，检查系统中的资源能否满足作业对资源 的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它 们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此， 88  第三章处理机调度与死锁 也把作业调度称为接纳调度(Admission Scheduling)。在每次执行作业调度时，都需做出以 下两个决定。",
            "正文": "1.接纳多少个作业 在每一次进行作业调度时，应当从后备队列中选取多少作业调入内存，取决于多道程 序度(Degreeof Multiprogramming)，即允许多少个作业同时在内存中运行。对系统来说，希 望装入较多的作业，有利于提高CPU的利用率和系统的吞吐量。但如果内存中同时运行 的作业太多时，进程在运行时因内存不足所发生的中断就会急剧增加。这将会使平均周转 时间显著延长，影响到系统的服务质量。因此，多道程序度的确定是根据计算机的系统规 模、运行速度、作业大小，以及能否获得较好的系统性能等情况作出适当的抉择的。\n\n2.接纳哪些作业 应选择后备队列中的哪些作业调入内存，取决于所采用的调度算法。最简单的是先来 先服务调度算法，它是将最早进入外存的作业优先调入内存。较常用的一种算法是短作业 优先调度算法，是将外存上所需执行时间最短的作业优先调入内存。另一种较常用的是基 于作业优先级的调度算法，该算法是将外存上作业优先级最高的作业优先调入内存。比较 好的一种算法是“响应比高者优先”的调度算法。我们将在后面对上述的几种算法作较详 细的介绍。 在批处理系统中，作业进入系统后，总是先驻留在外存的作业后备队列上，因此需要 有作业调度，以便将它们分批地装入内存。然而在分时系统中，为了做到及时响应，用户 通过键盘输入的命令或数据等都被直接送入内存，因而无需配置上述的作业调度机制，但 也需要有某种接纳控制措施来限制进入系统的用户数目。即如果系统尚有能力处理更多的 任务，将会接纳授权用户的请求，否则，便拒绝接纳。类似地，在实时系统中也不需要作 业调度，而必需具有接纳控制措施。"
          },
          {
            "三级标题": "3.2.3 先来先服务（FCFS）和短作业优先（SJF)调度算法 一 一一一一+",
            "正文": "1.先来先服务（first-comefirst-served，FCFS）调度算法 FCFS是最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调 度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统 中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先 进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。 当在进程调度中采用FCFS算法时，每次调度是从就绪的进程队列中选择一个最先进 入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件 而阻塞后，进程调度程序才将处理机分配给其它进程。 顺便说明，FCFS算法在单处理机系统中已很少作为主调度算法，但经常把它与其它调 度算法相结合使用，形成一种更为有效的调度算法。例如，可以在系统中按进程的优先级\n\n2.短作业优先（shortjobfirst，SJF)的调度算法 由于在实际情况中，短作业（进程）占有很大比例，为了能使它们能比长作业优先执行， 而产生了短作业优先调度算法。 89  计算机操作系统 1）短作业优先算法 SJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以 作业所要求的运行时间来衡量的。SJF算法可以分别用于作业调度和进程调度。在把短作 业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间 最短的作业，优先将它们调入内存运行。 2）短作业优先算法的缺点 SJF调度算法较之FCFS算法有了明显的改进，但仍然存在不容忽视的缺点：\n\n(1）必须预知作业的运行时间。在采用这种算法时，要先知道每个作业的运行时间。 即使是程序员也很难准确估计作业的运行时间，如果估计过低，系统就可能按估计的时间 终止作业的运行，但此时作业并未完成，故一般都会偏长估计。\n\n(2）对长作业非常不利，长作业的周转时间会明显地增长。更严重的是，该算法完全 忽视作业的等待时间，可能使作业等待时间过长，出现饥饿现象。\n\n(3）在采用FCFS算法时，人一机无法实现交互。\n\n（4）该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。"
          },
          {
            "三级标题": "3.2.4 优先级调度算法和高响应比优先调度算法",
            "正文": "1.优先级调度算法（priority-schedulingalgorithm，PSA) 我们可以这样来看作业的优先级，对于先来先服务调度算法，作业的等待时间就是作 业的优先级，等待时间越长，其优先级越高。对于短作业优先调度算法，作业的长短就是 作业的优先级，作业所需运行的时间越短，其优先级越高。但上述两种优先级都不能反映 作业的紧迫程度。而在优先级调度算法中，则是基于作业的紧迫程度，由外部赋予作业相 应的优先级，调度算法是根据该优先级进行调度的。这样就可以保证紧迫性作业优先运行。 优先级调度算法可作为作业调度算法，也可作为进程调度算法。当把该算法用于作业调度 时，系统是从后备队列中选择若干个优先级最高的作业装入内存。\n\n2.高响应比优先调度算法（HighestResponseRatioNext，HRRN） 在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽视了作业的运行时间。 而SJF算法正好与之相反，只考虑作业的运行时间，而忽视了作业的等待时间。高响应比 优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照 顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。 高响应比优先算法是如何实现的呢？如果我们能为每个作业引入一个动态优先级，即 优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不 断地增加，等到足够的时间后，必然有机会获得处理机。该优先级的变化规律可描述为： 等待时间+要求服务时间 优先权= 要求服务时间 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响 应比Rp。据此，优先又可表示为： 等待时间+要求服务时间_响应时间 Rp= 要求服务时间 要求服务时间\n\n90 @  第三章处理机调度与死锁 由上式可以看出：①如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈 高，因而类似于SJF算法，有利于短作业。②当要求服务的时间相同时，作业的优先权又 决定于其等待时间，因而该算法又类似于FCFS算法。③对于长作业的优先级，可以随等 待时间的增加而提高，当其等待时间足够长时，也可获得处理机。因此该算法实现了较好 的折中。当然在利用该算法时，每次要进行调度之前，都需要先做响应比的计算，显然会 增加系统开销。\n\n3.3 进程调度 进程调度是OS中必不可少的一种调度。因此在三种类型的OS中，都无一例外地配置 了进程调度。此外它也是对系统性能影响最大的一种处理机调度，相应的，有关进程调度 的算法也较多。"
          },
          {
            "三级标题": "3.3.1 进程调度的任务、机制和方式",
            "正文": "1.进程调度的任务 进程调度的任务主要有三：\n\n（1）保存处理机的现场信息。在进行调度时首先需要保存当前进程的处理机的现场信 息，如程序计数器、多个通用寄存器中的内容等。\n\n（2）按某种算法选取进程。调度程序按某种算法从就绪队列中选取一个进程，将其状 态改为运行状态，并准备把处理机分配给它。\n\n（3）把处理器分配给进程。由分派程序把处理器分配给该进程，此时需要将选中进程 的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制 权交予该进程，让它从上次的断点处恢复运行。\n\n2.进程调度机制 为了实现进程调度，在进程调度机制中，应具有如下三个基本部分，如图3-1所示。\n\n（1）排队器。为了提高进程调度的效率，应事先将系统中的所有就绪进程按照一定的 策略排成一个或多个队列，以便调度程序能最快地找到它。以后每当有一个进程转变为就 绪状态时，排队器便将它插入到相应的就绪队列。 移出运行进程 来自其它状态 进程控制块 就绪进程 就绪队列 排队器 上下文 [分派器 CPU 切换器 调度程序 图3-1进程调度机制 91"
          }
        ]
      },
      {
        "二级标题": "3.3_进程调度",
        "三级内容": [
          {
            "三级标题": "3.3.1 进程调度的任务、机制和方式",
            "正文": "1.进程调度的任务 进程调度的任务主要有三：\n\n（1）保存处理机的现场信息。在进行调度时首先需要保存当前进程的处理机的现场信 息，如程序计数器、多个通用寄存器中的内容等。\n\n（2）按某种算法选取进程。调度程序按某种算法从就绪队列中选取一个进程，将其状 态改为运行状态，并准备把处理机分配给它。\n\n（3）把处理器分配给进程。由分派程序把处理器分配给该进程，此时需要将选中进程 的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制 权交予该进程，让它从上次的断点处恢复运行。\n\n2.进程调度机制 为了实现进程调度，在进程调度机制中，应具有如下三个基本部分，如图3-1所示。\n\n（1）排队器。为了提高进程调度的效率，应事先将系统中的所有就绪进程按照一定的 策略排成一个或多个队列，以便调度程序能最快地找到它。以后每当有一个进程转变为就 绪状态时，排队器便将它插入到相应的就绪队列。 移出运行进程 来自其它状态 进程控制块 就绪进程 就绪队列 排队器 上下文 [分派器 CPU 切换器 调度程序 图3-1进程调度机制 91  计算机操作系统\n\n(2）分派器。分派器依据进程调度程序所选定的进程，将其从就绪队列中取出，然后 进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。\n\n(3）上下文切换器。在对处理机进行切换时，会发生两对上下文的切换操作：①第一 对上下文切换时，OS将保存当前进程的上下文，即把当前进程的处理机寄存器内容保存到 该进程的进程控制块内的相应单元，再装入分派程序的上下文，以便分派程序运行；②第 二对上下文切换是移出分派程序的上下文，而把新选进程的CPU现场信息装入到处理机的 各个相应寄存器中，以便新选进程运行。 在进行上下文切换时，需要执行大量的load和store等操作指令，以保存寄存器的内 容。即使是现代计算机，每一次上下文切换所花费的时间大约可执行上千条指令。为此， 现在已有靠硬件实现的方法来减少上下文切换时间。一般采用两组(或多组)寄存器，其中 的一组寄存器供处理机在系统态时使用，而另一组寄存器供应用程序使用。在这样条件下 的上下文切换，只需改变指针，使其指向当前寄存器组即可。\n\n3.进程调度方式 早期所采用的非抢占方式存在着很大的局限性，很难满足交互性作业和实时任务的需 求。为此，在进程调度中又引入了抢占方式。我们先了解一下非抢占方式时的情况。 1）非抢占方式(Nonpreemptive Mode) 在采用这种调度方式时，一旦把处理机分配给某进程后，就一直让它运行下去，决不 会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成，或 发生某事件而被阻塞时，才把处理机分配给其它进程。 在采用非抢占调度方式时，可能引起进程调度的因素可归结为：①正在执行的进程运 暂停执行：③在进程通信或同步过程中，执行了某种原语操作，如Block原语。这种调度 方式的优点是实现简单，系统开销小，适用于大多数的批处理系统。但它不能用于分时系 统和大多数实时系统。 2）抢占方式（PreemptiveMode) 这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给 该进程的处理机重新分配给另一进程。在现代OS中广泛采用抢占方式，这是因为：对于 批处理机系统，可以防止一个长进程长时间地占用处理机，以确保处理机能为所有进程提 供更为公平的服务。在分时系统中，只有采用抢占方式才有可能实现人一机交互。在实时系 统中，抢占方式能满足实时任务的需求。但抢占方式比较复杂，所需付出的系统开销也较大。 “抢占”不是一种任意性行为，必须遵循一定的原则。主要原则有： ①优先权原则，指允许优先级高的新到进程抢占当前进程的处理机，即当有新进程到 达时，如果它的优先级比正在执行进程的优先级高，则调度程序将剥夺当前进程的运行， 将处理机分配给新到的优先权高的进程。 ②短进程优先原则，指允许新到的短进程可以抢占当前长进程的处理机，即当新到达 的进程比正在执行的进程（尚须运行的时间)明显短时，将处理机分配给新到的短进程。 ③时间片原则，即各进程按时间片轮转运行时，当正在执行的进程的一个时间片用完 后，便停止该进程的执行而重新进行调度。 92  第三章处理机调度与死锁"
          },
          {
            "三级标题": "3.3.2 轮转调度算法 在分时系统中，最简单也是较常用的是基于时间片的轮转（roundrobin，RR)调度算法。 该算法采取了非常公平的处理机分配方式，即让就绪队列上的每个进程每次仅运行一个时 间片。如果就绪队列上有n个进程，则每个进程每次大约都可获得1/n的处理机时间。",
            "正文": "1.轮转法的基本原理 在轮转(RR)法中，系统将所有的就绪进程按FCFS策略排成一个就绪队列。系统可设 置每隔一定时间（如30ms）便产生一次中断，去激活进程调度程序进行调度，把CPU分配 给队首进程，并令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新 的队首进程，也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程在确定的 时间段内，都能获得一个时间片的处理机时间。\n\n2.进程切换时机 在RR调度算法中，应在何时进行进程的切换，可分为两种情况：①若一个时间片尚 未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再 调度就绪队列中队首的进程运行，并启动一个新的时间片。②在一个时间片用完时，计时 器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。\n\n3.时间片大小的确定 在轮转算法中，时间片的大小对系统性能有很大的影响。若选择很小的时间片，将有 利于短作业，因为它能在该时间片内完成。但时间片小，意味着会频繁地执行进程调度和 进程上下文的切换，这无疑会增加系统的开销。反之，若时间片选择得太长，且为使每个 进程都能在一个时间片内完成，RR算法便退化为FCFS算法，无法满足短作业和交互式用 户的需求。一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，使大多数 交互式进程能在一个时间片内完成，从而可以获得很小的响应时间。图3-2示出了时间片 典型交互的时间。图3-3示出了时间片分别为q=1和g=4时对平均周转时间的影响。 时间 分配给进程 的时间片 交互结束 响应时间 q-s 时间片 b (a)时间片大于交互时间 分配给进程 分配给进程 进程被抢占 的时间片 交互完成 的时间片 b 其它进程运行 (b)时间片小于交互时间 图3-2时间片大小对响应时间的影响 93  计算机操作系统 作业 进程名 A B C D E 平均 情况 到达时间 0 1 3 4 2 服务时间 4 3 4 2 4 时间片 完成时间 15 12 16 9 17 RR 周转时间 15 11 14 6 13\n\n11.8 q=1 带权周转时间\n\n3.75\n\n3.67\n\n3.5 3\n\n3.33\n\n3.46 完成时间 4 7 11 13 17 RR 周转时间 4 6 9 10 13\n\n8.4 t=b 带权周转时间 1 2\n\n2.25 5\n\n3.33\n\n2.5 图3-3q=1和q=4时进程的周转时间"
          },
          {
            "三级标题": "3.3.3 优先级调度算法 一 在时间片轮转调度算法中，做了一个隐含的假设，即系统中所有进程的紧迫性是相同 的。但实际情况并非如此。为了能满足实际情况的需要，在进程调度算法中引入优先级， 而形成优先级调度算法。",
            "正文": "1.优先级调度算法的类型 优先级进程调度算法，是把处理机分配给就绪队列中优先级最高的进程。这时，又可 进一步把该算法分成如下两种。\n\n（1）非抢占式优先级调度算法。该算法规定，一旦把处理机分配给就绪队列中优先级 最高的进程后，该进程便一直执行下去直至完成，或者因该进程发生某事件而放弃处理机 时，系统方可将处理机重新分配给另一优先级最高的进程。\n\n(2）抢占式优先级调度算法。把处理机分配给优先级最高的进程，使之执行。但在其 执行期间，只要出现了另一个其优先级更高的进程，调度程序就将处理机分配给新到的优 先级最高的进程。因此，在采用这种调度算法时，每当系统中出现一个新的就绪进程i时， 就将其优先级P与正在执行的进程j的优先级P进行比较，如果P≤P，原进程P便继续 执行；但如果是P>P，则立即停止P的执行，进行进程切换，使i进程投入执行。抢占式 的优先级调度算法常用于对实时性要求较高的系统中。\n\n2.优先级的类型 优先级调度算法的关键在于：应如何确定进程的优先级，以及确定是使用静态优先级 还是动态优先级。 1）静态优先级 静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用 某一范围内的一个整数来表示的，例如0～255中的某一整数，又把该整数称为优先数。确 定进程优先级大小的依据有如下三个：\n\n(1）进程类型。通常系统进程（如接收进程、对换进程）的优先级高于一般用户进程的优 先级。\n\n(2）进程对资源的需求。对资源要求少的进程应赋予较高的优先级。\n\n（3）用户要求。根据进程的紧迫程度及用户所付费用的多少确定优先级。 94  第三章处理机调度与死锁 静态优先级法简单易行，系统开销小，但不够精确，可能会出现优先级低的进程长期 没有被调度的情况。 2）动态优先级 动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等 待时间的增加而改变，以便获得更好的调度性能。例如，可以规定在就绪队列中的进程随 其等待时间的增长，使其优先级相应提高。若所有的进程都具有相同优先级初值，则最先 若所有的就绪进程具有各不相同的优先级初值，那么对于优先级初值低的进程，在等待了 足够的时间后，也可以获得处理机。当采用抢占式调度方式时，若再规定当前进程的优先 级随运行时间的推移而下降，则可防止一个长作业长期地垄断处理机。"
          },
          {
            "三级标题": "3.3.4 多队列调度算法 如前所述的各种调度算法，尤其在应用于进程调度时，由于系统中仅设置一个进程的 就绪队列，即低级调度算法是固定的、单一的，无法满足系统中不同用户对进程调度策略 的不同要求，在多处理机系统中，这种单一调度策略实现机制的缺点更显突出，由此，多 级队列调度算法能够在一定程度上弥补这一缺点。 该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定 分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可 以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。 算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。 在多处理机系统中，该算法由于安排了多个就绪队列，因此，很方便为每个处理机设 而且对于一个含有多个线程的进程而言，可以根据其要求将其所有线程分配在一个就绪队 列，全部在一个处理机上运行。再者，对于一组需要相互合作的进程或线程而言，也可以 将它们分配到一组处理机所对应的多个就绪队列，使得它们能同时获得处理机并行执行。",
            "正文": ""
          },
          {
            "三级标题": "3.3.5 多级反馈队列（multilevedfeedbackqueue）调度算法 前面介绍的各种用于进程调度的算法都有一定的局限性。如果未指明进程长度，则短 进程优先和基于进程长度的抢占式调度算法都将无法使用。而下述的多级反馈队列调度算 法则不必事先知道各种进程所需的执行时间，还可以较好地满足各种类型进程的需要，因 而它是目前公认的一种较好的进程调度算法。",
            "正文": "1.调度机制 多级反馈队列调度算法的调度机制可描述如下：\n\n（1）设置多个就绪队列。在系统中设置多个就绪队列，并为每个队列赋予不同的优先 级。第一个队列的优先级最高，第二个次之，其余队列的优先级逐个降低。该算法为不同 队列中的进程所赋予的执行时间片的大小也各不相同，在优先级愈高的队列中，其时间片 就愈小。例如第二个队列的时间片要比第一个的时间片长一倍，…·…，第i+1个队列的时 95  计算机操作系统 间片要比第i个的时间片长一倍。图3-4是多级反馈队列算法的示意图。 S 就绪队列1 至CPU 就绪队列2 S3 至CPU 就绪队列3 Sn 至CPU 就绪队列n (时间片：S<S2<S.<Sn) 图3-4多级反馈队列调度算法 按FCFS原则等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。 如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，·，依此 类推。当进程最后被降到第n队列后，在第n队列中便采取按RR方式运行。\n\n（3）按队列优先级调度。调度程序首先调度最高优先级队列中的诸进程运行，仅当第 一队列空闲时才调度第二队列中的进程运行；换言之，仅当第1～(i-1)所有队列均空时， 才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时又有新进程进 入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处 理机分配给新到的高优先级进程。\n\n2.调度算法的性能 在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需 之处理时间时，便能较好地满足各种类型用户的需要。\n\n（1）终端型用户。由于终端型用户提交的作业多属于交互型作业，通常较小，系统只 要能使这些作业在第一队列规定的时间片内完成，便可使终端型用户感到满意。\n\n(2）短批处理作业用户。对于这类作业，如果可在第一队列中执行完成，便获得与终 端型作业一样的响应时间。对于稍长的短作业，也只需在第二和第三队列各执行一时间片 完成，其周转时间仍然较短。\n\n（3）长批处理作业用户。对于长作业，它将依次在第1，2，\"，n个队列中运行，然 后再按轮转方式运行，用户不必担心其作业长期得不到处理。"
          },
          {
            "三级标题": "3.3.6 基于公平原则的调度算法 一← 以上介绍的几种调度算法所保证的只是优先运行，如优先级算法是优先级最高的作业 优先运行，但并不保证作业占用了多少处理机时间。另外也未考虑到调度的公平性。本小 节将介绍两种相对公平的调度算法。",
            "正文": "1.保证调度算法 保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行， 96  理机分配的公平性。如果在系统中有n个相同类型的进程同时运行，为公平起见，须保证每 个进程都获得相同的处理机时间1/n。在实施公平调度算法时系统中必须具有这样一些功能：\n\n（1）跟踪计算每个进程自创建以来已经执行的处理时间。\n\n(2）计算每个进程应获得的处理机时间，即自创建以来的时间除以n。\n\n(3）计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机 时间之比。\n\n（4）比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比 率为0.8，进程C的比率为1.2等。\n\n(5）调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到 超过最接近它的进程比率为止。\n\n2.公平分享调度算法 分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公 平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。假如系统中仅 有两个用户，用户1启动了4个进程，用户2只启动1个进程，采用轮转法让每个进程轮 流运行一个时间片时间，对进程而言很公平，但用户1和用户2得到的处理机时间分别为 80%和20%，显然对用户2而言就有失公平。在该调度算法中，调度的公平性主要是针对 用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。然而调度又是以 进程为基本单位，为此，必须考虑到每一个用户所拥有的进程数目。例如系统中有两个用 同的处理机时间，则必须执行如下所示的强制调度序列： AEBECEDEAEBECEDE. 如果希望用户1所获得的处理机时间是用户2的两倍，则必须执行如下所示的强制调 度序列： ABECDEABECDEABECDE.\n\n3.4实时调度 在实时系统中，可能存在着两类不同性质的实时任务，即HRT 任务和SRT 任务，它 们都联系着一个截止时间。为保证系统能正常工作，实时调度必须能满足实时任务对截止 时间的要求。为此，实现实时调度应具备一定的条件。"
          },
          {
            "三级标题": "3.4.1 ：实现实时调度的基本条件",
            "正文": "1.提供必要的信息 为了实现实时调度，系统应向调度程序提供有关任务的信息：\n\n(1）就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事 先预知的一串时间序列。\n\n(2）开始截止时间和完成截止时间，对于典型的实时应用，只须知道开始截止时间， 或者完成截止时间。 97"
          }
        ]
      },
      {
        "二级标题": "3.4_实时调度",
        "三级内容": [
          {
            "三级标题": "3.4.1 ：实现实时调度的基本条件",
            "正文": "1.提供必要的信息 为了实现实时调度，系统应向调度程序提供有关任务的信息：\n\n(1）就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事 先预知的一串时间序列。\n\n(2）开始截止时间和完成截止时间，对于典型的实时应用，只须知道开始截止时间， 或者完成截止时间。 97  计算机操作系统\n\n(3）处理时间，一个任务从开始执行，直至完成时所需的时间。\n\n（4）资源要求，任务执行时所需的一组资源。\n\n(5）优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝 对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予 “相对”优先级，供调度程序参考。\n\n2.系统处理能力强 在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些 实时任务不能得到及时处理，从而导致发生难以预料的后果。假定系统中有m个周期性的 硬实时任务HRT，它们的处理时间可表示为C，周期时间表示为P，则在单处理机情况下， 必须满足下面的限制条件系统才是可调度的： P 顺便说明一下，上述的限制条件并未考虑到任务切换所花费的时间，因此，当利用上 述限制条件时，还应适当地留有余地。 提高系统处理能力的途径有二：一是采用单处理机系统，但须增强其处理能力，以显 著地减少对每一个任务的处理时间；二是采用多处理机系统。假定系统中的处理机数为N， 则应将上述的限制条件改为： ≤N\n\n3.采用抢占式调度机制 在含有HRT任务的实时系统中，广泛采用抢占机制。这样便可满足HRT任务对截止 时间的要求。但这种调度机制比较复杂。对于一些小的实时系统，如果能预知任务的开始 截止时间，则对实时任务的调度可采用非抢占调度机制，以简化调度程序和在任务调度时 所花费的系统开销。在设计这种调度机制时，应使所有的实时任务都比较小，并在执行完 关键性程序和临界区后，能及时地将自已阻塞起来，以便释放出处理机，供调度程序去调 度那个开始截止时间即将到达的任务。\n\n4.具有快速切换机制 为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的 快速切换。该机制应具有如下两方面的能力：\n\n（1）对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有 快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机(其它紧迫任务）。\n\n（2）快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的 每个运行功能单位适当的小，以减少任务切换的时间开销。"
          },
          {
            "三级标题": "3.4.2 实时调度算法的分类 可以按不同方式对实时调度算法加以分类：①根据实时任务性质，可将实时调度的算 98  第三章处理机调度与死锁 法分为硬实时调度算法和软实时调度算法；②按调度方式，则可分为非抢占调度算法和抢 占调度算法。",
            "正文": "1.非抢占式调度算法\n\n（1）非抢占式轮转调度算法。由一台计算机控制若干个相同的（或类似的）对象，为每一 个被控对象建立一个实时任务，并将它们排成一个轮转队列。调度程序每次选择队列中的 第一个任务投入运行。当该任务完成后，便把它挂在轮转队列的末尾等待，调度程序再选 择下一个队首任务运行。这种调度算法可获得数秒至数十秒的响应时间，可用于要求不太 严格的实时控制系统中。\n\n（2）非抢占式优先调度算法。如果在系统中还含有少数具有一定要求的实时任务，则 可采用非抢占式优先调度算法，系统为这些任务赋予了较高的优先级。当这些实时任务到 达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后，便可去调度 秒至数百毫秒，因而可用于有一定要求的实时控制系统中。\n\n2.抢占式调度算法 可根据抢占发生时间的不同而进一步分成以下两种调度算法：\n\n（1）基于时钟中断的抢占式优先级调度算法。在某实时任务到达后，如果它的优先级 高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时， 调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。该算法能获得较 好的响应效果，其调度延迟可降为几十至几毫秒，可用于大多数的实时系统中。\n\n(2）立即抢占（ImmediatePreemption）的优先级调度算法。在这种调度策略中，要求操作 系统具有快速响应外部事件中断的能力。一旦出现外部中断，只要当前任务未处于临界区， 便能立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。这种算法能获得非 常快的响应，可把调度延迟降低到几毫秒至100微秒，甚至更低。图3-5中的(a)、(b)、(c)、 （d)分别示出了四种情况的调度时间。 实时进程请求调度 调度实时进程运行 实时进程请求调度 时钟中断到来时 进程1 进程2 进程n 实时进程 当前进程 实时进程 调度时间 调度时间 (c)基于时钟中断抢占的优先权抢占调度 (a)非抢占轮转调度 实时进程请求调度 当前进程运行完成 实时进程请求调度 实时进程抢占当前 进程，并立即执行 当前进程 实时进程 当前进程 实时进程 调度时间 调度时间 (b)非抢占优先权调度 (d)立即抢占的优先权调度 图3-5：实时进程调度"
          },
          {
            "三级标题": "3.4.3 最早截止时间优先EDF(EarliestDeadlineFirst)算法 该算法是根据任务的截止时间确定任务的优先级，任务的截止时间愈早，其优先级愈 99  计算机操作系统 高，具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是选择就绪队 列中的第一个任务，为之分配处理机。最早截止时间优先算法既可用于抢占式调度方式中， 也可用于非抢占式调度方式中。",
            "正文": "1.非抢占式调度方式用于非周期实时任务 图3-6示出了将该算法用于非抢占调度方式之例。该例中具有四个非周期任务，它们 先后到达。系统先调度任务1执行，在任务1执行期间，任务2、3又先后到达。由于任务 3的开始截止时间早于任务2的，故系统在任务1后将先调度任务3执行。在此期间又到 达作业4，其开始截止时间仍是早于任务2的，故在任务3执行完后，系统又先调度任务4 执行，最后才调度任务2执行。 开始截止时间 3 任务执行 1 3 4 2 任务到达 2 4 图3-6EDF算法用于非抢占调度方式\n\n2.抢占式调度方式用于周期实时任务 图3-7示出了将该算法用于抢占调度方式之例。在该例中有两个周期任务，任务A和 任务B的周期时间分别为20ms和50ms，每个周期的处理时间分别为10ms和25ms。 BI B 截止时间 截止时间 Ai A2 A3 A4 As 截止时间 截止时间 截止时间 截止时间 截止时间 到达时间、执行时间和 A2 A. AG A A 最后截止时间 B B2 时间/ms 10 20 30 40 50 60 70 80 90 100 固定优先级调度 B B B2 A B2 As B2 A Ai A2 B A3 A4 A5，B2 (错过) A 固定优先级调度 B B2 ★ A A2 B A3 A4 AsB2 (错过) (错过) 使用完成截止时间最早和 B A B AB2A4 A B2 As 最后截止时间调度 T A A2 B A3 A4 As,B2 图3-7最早截止时间优先算法用于抢占调度方式之例 100  第三章处理机调度与死锁 图3-7示出了将最早截止时间（最后期限）优先算法用于抢占调度的示意图。图中的第一行 示出了两个任务的到达时间、截止时间和执行时间图。其中任务A的到达时间为0、20ms、 40ms，任务A的最后期限为20ms、40ms、60ms，任务B的到达时间为0、50ms、 100ms\"，任务B的最后期限为50ms、100ms\"。 为了说明通常的优先级调度不能适用于实时系统，该图特增加了第二和第三行。在第 二行中，假定任务A具有较高的优先级，所以在t=Oms时，先调度A执行，在Ai完成 后（t=10ms)才调度B执行。在t=20ms时，又重新调度A2执行，在t=30ms时，A2完 成，又调度B执行。在t=40ms时，又调度A3执行，在t=50ms时，虽然A3已完成， 但B，已错过了它的最后期限。这说明利用通常的优先级调度已经失败。第三行与第二行类 似，只是假定任务B具有较高的优先级。 第四行是采用最早截止时间优先算法的时间图。在t=0时，Ai和B同时到达，由于 A的截止时间比B早，故调度A执行。在t=10时，A完成又调度B执行。在t=20时， A2到达，由于A2的截止时间比B2早，B被中断而调度A2执行。在t=30时，A2完成， 又重新调度B执行。在t=40时，A3又到达，但B的截止时间要比A3早，仍应让B继 续执行直到完成（t=45)，然后再调度A3执行。在t=55时，A3完成又调度B2执行。在该 例中，利用最早截止时间优先算法可以满足系统的要求。"
          },
          {
            "三级标题": "3.4.5 优先级倒置（priorityinversionproblem）",
            "正文": "1.优先级倒置的形成 当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的 延迟或阻塞。我们通过一个例子来说明该问题。假如有三个完全独立的进程P1、P2和P3， P的优先级最高，P2次之，P3最低。P和P通过共享的一个临界资源进行交互。下面是一 段代码： P:...P(mutex);CS-1; V(mutex);... P2:... program2... P3:...P(mutex); CS-3; V(mutex);... 假如P最先执行，在执行了P(mutex）操作后，进入到临界区CS-3。在时刻a，P2就绪， 因为它比P3的优先级高，P2抢占了P3的处理机而运行，如图3-10所示。在时刻b，P就 绪，因为它又比P2的优先级高，P抢占了P2的处理机而运行。在时刻c，P执行P(mutex) 操作，试图进入临界区CS-1，但因为相应的临界资源已被P3占用，故P将被阻塞。由P2 继续运行，直到时刻d运行结束。然后由P接着运行，到时刻e时P3退出临界区，并唤醒 P1。因为它比P3的优先级高，故它抢占了P3的处理机而运行。 根据优先级原则，高优先级进程应当能优先执行，但在此例中，P和P3共享着“临界 102  第三章处理机调度与死锁 存在而延长了P被阻塞的时间，而且被延长的时间是不可预知和无法限定的。由此所产生 阻塞在 进入 P(mutex) CS-1 P 抢占 抢占 P2 b P结束 抢占 P3 d 进入 离开CS-3 CS-3 V(mutex) P(mutex) 图3-10优先级倒置示意图\n\n2.优先级倒置的解决方法 一种简单的解决方法是规定：假如进程P3在进入临界区后P3所占用的处理机就不允许 被抢占。由图3-10可以看出，P2即使优先级高于P3也不能执行。于是P3就有可能会较快 地退出临界区，不会出现上述情况。如果系统中的临界区都较短且不多，该方法是可行的。 反之，如果P临界区非常长，则高优先级进程P仍会等待很长的时间，其效果是无法令人 满意的。 一个比较实用的方法是建立在动态优先级继承基础上的。该方法规定，当高优先级进 程P要进入临界区，去使用临界资源R，如果已有一个低优先级进程P3正在使用该资源， 此时一方面P被阻塞，另一方面由P继承P的优先级，并一直保持到P退出临界区。这 样做的目的在于不让比P优先级稍高，但比P优先级低的进程如P2进程插进来，导致延 缓P退出临界区。图3-11示出了采用动态优先级继承方法后，P、P2、P三个进程的运行 情况。由图可以看出，在时刻c，P被阻塞，但由于P3已继承了P的优先级，它比P2优 先级高，这样就避免了P2的插入，使P在时刻d进入临界区。该方法已在一些操作系统中 得到应用，而在实时操作系统中是必须的。 阻塞在 进入 P(mutex) CS-1 P结束 P, P2 b P3 c 进入 离开CS-3 CS-3 继承 V(mutex) P(mutex) 图3-11 采用了动态优先级继承方法的运行情况 103  计算机操作系统\n\n3.5死锁概述 在第二章中，我们已经涉及到死锁的概念。例如，系统中只有一台扫描仪R和一台刻 录机R2。有两个进程P和P2，它们都准备将扫描的文挡刻录到CD光盘上，进程Pi先请 求扫描仪R并获得成功，进程P2先请求CD刻录机R2也获得成功。后来P又请求CD刻 录机，因它已被分配给了P2而阻塞。P2又请求扫描仪，也因被分配给了P而阻塞，此时 两个进程都被阻塞，双方都希望对方能释放出自己所需要的资源，但它们谁都因不能获得 自己所需的资源去继续运行，从而无法释放出自己占有的资源，并且一直处于这样的僵持 状态而形成死锁。又如，在第二章的哲学家进餐问题中，如果每一个哲学家因饥饿都拿起 了他们左边的筷子，当每一个哲学家又试图去拿起他们右边的筷子时，将会因无筷子可拿 而无限期地等待，从而产生死锁问题。在本章的后半部分，我们将对死锁发生的原因、如 何预防和避免死锁等问题作较详细的介绍。"
          },
          {
            "三级标题": "3.5.1 资源问题 在系统中有许多不同类型的资源，其中可以引起死锁的主要是，需要采用互斥访问方 法的、不可以被抢占的资源，即在前面介绍的临界资源。系统中这类资源有很多，如打印 机、数据文件、队列、信号量等。",
            "正文": "1.可重用性资源和消耗性资源 1）可重用性资源 可重用性资源是一种可供用户重复使用多次的资源，它具有如下性质：\n\n（1）每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。\n\n（2）进程在使用可重用性资源时，须按照这样的顺序：①请求资源。如果请求资源失 败，请求进程将会被阻塞或循环等待。②使用资源。进程对资源进行操作，如用打印机进 行打印；③释放资源。当进程使用完后自己释放资源。\n\n（3）系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能 创建也不能删除它。 对资源的请求和释放通常都是利用系统调用来实现的，例如对于设备，一般用 request/release；对于文件，可用open/close。对于需要互斥访问的资源，进程可以用信号量 的wait/signal操作来完成。进程在每次提出资源请求后，系统在执行时都需要做一系列的 工作。计算机系统中大多数资源都属于可重用性资源。 2）可消耗性资源 可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的， 它具有如下性质：①每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的， 有时它可以有许多，有时可能为0；②进程在运行过程中，可以不断地创造可消耗性资源 的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目。③进程在运行过 程中，可以请求若干个可消耗性资源单元，用于进程自已的消耗，不再将它们返回给该资 104"
          }
        ]
      },
      {
        "二级标题": "3.5_死锁概述",
        "三级内容": [
          {
            "三级标题": "3.5.1 资源问题 在系统中有许多不同类型的资源，其中可以引起死锁的主要是，需要采用互斥访问方 法的、不可以被抢占的资源，即在前面介绍的临界资源。系统中这类资源有很多，如打印 机、数据文件、队列、信号量等。",
            "正文": "1.可重用性资源和消耗性资源 1）可重用性资源 可重用性资源是一种可供用户重复使用多次的资源，它具有如下性质：\n\n（1）每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。\n\n（2）进程在使用可重用性资源时，须按照这样的顺序：①请求资源。如果请求资源失 败，请求进程将会被阻塞或循环等待。②使用资源。进程对资源进行操作，如用打印机进 行打印；③释放资源。当进程使用完后自己释放资源。\n\n（3）系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能 创建也不能删除它。 对资源的请求和释放通常都是利用系统调用来实现的，例如对于设备，一般用 request/release；对于文件，可用open/close。对于需要互斥访问的资源，进程可以用信号量 的wait/signal操作来完成。进程在每次提出资源请求后，系统在执行时都需要做一系列的 工作。计算机系统中大多数资源都属于可重用性资源。 2）可消耗性资源 可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的， 它具有如下性质：①每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的， 有时它可以有许多，有时可能为0；②进程在运行过程中，可以不断地创造可消耗性资源 的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目。③进程在运行过 程中，可以请求若干个可消耗性资源单元，用于进程自已的消耗，不再将它们返回给该资 104  第三章处理机调度与死锁 源类中。可消耗性资源通常是由生产者进程创建，由消费者进程消耗。最典型的可消耗性 资源就是用于进程间通信的消息等。\n\n2.可抢占性资源和不可抢占性资源 1）可抢占性资源 可把系统中的资源分成两类，一类是可抢占性资源，是指某进程在获得这类资源后， 该资源可以再被其它进程或系统抢占。例如优先级高的进程可以抢占优先级低的进程的处 理机。又如可把一个进程从一个存储区转移到另一个存储区，在内存紧张时，还可将一个 进程从内存调出到外存上，即抢占该进程在内存的空间。可见，CPU和主存均属于可抢占 性资源。对于这类资源是不会引起死锁的。 2）不可抢占性资源 另一类资源是不可抢占性资源，即一旦系统把某资源分配给该进程后，就不能将它强 行收回，只能在进程用完后自行释放。例如，当一个进程已开始刻录光盘时，如果突然将 刻录机分配给另一个进程，其结果必然会损坏正在刻录的光盘，因此只能等刻好光盘后由 进程自己释放刻录机。另外磁带机、打印机等也都属于不可抢占性资源。"
          },
          {
            "三级标题": "3.5.2 计算机系统中的死锁 死锁的起因，通常是源于多个进程对资源的争夺，不仅对不可抢占资源进行争夺时会 引起死锁，而且对可消耗资源进行争夺时，也会引起死锁。",
            "正文": "1.竞争不可抢占性资源引起死锁 通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进 备写两个文件F和F2，而这两者都属于可重用和不可抢占性资源。进程P先打开F，然 后再打开文件F2；进程P2先打开文件F2，后打开F，下面示出了这段代码。 P1 P2 .... ... Open(fi, w); Open(f2,w)； Open(f2, w); Open(fi, w); 由于文件Fi(F2)已被P打开，故P2会被阻塞。当P写完文件Fi(或F2)而关闭F(F2)时，P2 会由阻塞状态转为就绪状态，被调度执行后重新打开文件F（或F2)。在这种情况下，P和 P2都能正常运行下去。若P2先打开F和F2，然后P才去打开F（或F2)，P和P2同样也可 以正常运行下去。 但如果在P打开F的同时，P2去打开F2，每个进程都占有一个打开的文件，此时就 已被打开而阻塞，它们希望对方关闭自己所需要的文件，但谁也无法运行，因此这两个进 程将会无限期地等待下去，而形成死锁。 我们可将上面的问题利用资源分配图进行描述，用方块代表可重用的资源（文件），用 圆圈代表进程，见图3-12所示。当箭头从进程指向文件时，表示进程请求资源(打开文件)； 105  计算机操作系统 当箭头从资源指向进程时，表示该资源已被分配给该进程(已被进程打开)。从中可以看出， 这时在P、P2及R和R2之间，已经形成了一个环路，说明已进入死锁状态。 P 接收 图3-12共享文件时的死锁情况 图3-13进程之间通信时的死锁\n\n2.竞争可消耗资源引起死锁 现在进一步介绍竞争可消耗资源所引起的死锁。图3-13示出了在三个进程之间，在利 用消息通信机制进行通信时所形成的死锁情况。图中，m、m2和m是可消耗资源。进程 P一方面产生消息mi，利用send(p2，m)原语将它发送给P2；另一方面，它又要求从P3接 收消息m3。而进程P2一方面产生消息m2，利用send(p3,m2)原语将它发送给P3；另一方面， 它又需要接收进程P,所产生的消息m。类似地，进程Ps也产生消息m3，利用 send(pi,m3) 原语将它发送给P，而它又要求从进程P2接收其所产生的消息m2。如果三个进程间的消 息通信，则按下述顺序进行： P1:·\"send(p2, m1);receive(p3,m3);*. P2:\"send(p3, m2);receive(p1, m1); .…. P3:·send（p1,m3);-receive(p2,m2); 这三个进程都可以先将消息发送给下一个进程，相应地它们也都能够接收到从上一个 进程发来的消息，因此三个进程可以顺利地运行下去，而不会发生死锁。但若改成三个进 程都先执行receive操作，后执行send操作，即按下述的运行顺序： P1:receive(p3, m3);send(p2, m1); \". P2:receive(p1, m1);:send(p3, m2); -\". P3:.-receive(p2, m2); send(pi, m3); .. 则这三个进程就会永远阻塞在它们的receive操作上，等待一条永远不会发出的消息，于是 发生了死锁。\n\n3.进程推进顺序不当引起死锁 除了系统中多个进程对资源的竞争会引发死锁外，进程在运行过程中，对资源进行申 请和释放的顺序是否合法，也是在系统中是否会产生死锁的一个重要因素。例如，系统中 只有一台打印机R和一台磁带机R2，可供进程P和P2共享，由于进程在运行中具有异步 性特征，这就可能使P和P2两个进程按下述两种顺序向前推进。 1）进程推进顺序合法 在进程P和P2并发执行时，如果按图3-14中的曲线①所示的顺序推进：P1:Request(Rt) →P1:Request(R2)→P:Releast(R)→P:Release(R2)→P2:Request(R2)→P2:Request(R1) →P2：Release(R2)→P2：Release(Ri)，两个进程可顺利完成。类似地，若按图中曲线②和③ 106  第三章处理机调度与死锁 所示的顺序推进，两进程也可以顺利完成。我们称这种不会引起进程死锁的推进顺序是合 法的。 2）进程推进顺序非法 若并发进程P和P2按图3-14中曲线④所示的顺序推进，它们将进入不安全区D内。 此时P保持了资源R，P2保持了资源R2，系统处于不安全状态。此刻，如果两个进程继 续向前推进，就可能发生死锁。例如，当P运行到P：Request(R2)时，将因R2已被P2占 用而阻塞；当P2运行到P2：Request(R,)时，也将因R,已被P占用而阻塞，于是发生了进 程死锁，这样的进程推进顺序就是非法的。 tp2 ② PRel(R) P2Rel(R2) P2Req(R) D P2Req(R2) ③ ④ P P P P tp1 Req(R) Req(Rz) Rel(R) Rel(R2) 图3-14进程推进顺序对死锁的影响"
          },
          {
            "三级标题": "3.5.3 死锁的定义、必要条件和处理方法",
            "正文": "1.死锁的定义 在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁 进程所占有的资源。或者说每个进程所等待的事件是该组中其它进程释放所占有的资源。 可被唤醒。这样这组进程只能无限期地等待下去。由此可以给死锁做出如下的定义： 如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件， 那么该组进程是死锁的(Deadlock)。\n\n2.产生死锁的必要条件 虽然进程在运行过程中可能会发生死锁，但产生进程死锁是必须具备一定条件的。综 上所述不难看出，产生死锁必须同时具备下面四个必要条件，只要其中任一个条件不成立， 死锁就不会发生：\n\n（1）互斥条件。进程对所分配到的资源进行排它性使用，即在一段时间内，某资源只 能被一个进程占用。如果此时还有其它进程请求该资源，则请求进程只能等待，直至占有 该资源的进程用毕释放。 107  计算机操作系统 该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n\n(3）不可抢占条件。进程已获得的资源在未使用完之前不能被抢占，只能在进程使用 完时由自己释放。\n\n(4）循环等待条件。在发生死锁时，必然存在一个进程一资源的循环链，即进程集合 {Po,P1，P2，“，P}中的Po正在等待一个P占用的资源，P正在等待P2占用的资源，··， P正在等待已被Po占用的资源。\n\n3.处理死锁的方法 目前处理死锁的方法可归结为四种：\n\n(1）预防死锁。这是一种较简单和直观的事先预防方法。该方法是通过设置某些限制 条件，去破坏产生死锁四个必要条件中的一个或几个来预防产生死锁。预防死锁是一种较 易实现的方法，已被广泛使用。\n\n（2）避免死锁。同样是属于事先预防策略，但它并不是事先采取各种限制措施，去破 坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法防止系统进入不 安全状态，从而可以避免发生死锁。\n\n（3）检测死锁。这种方法无须事先采取任何限制性措施，允许进程在运行过程中发生 死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁 中解脱出来。\n\n（4）解除死锁。当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态 中解脱出来。常用的方法是撤消一些进程，回收它们的资源，将它们分配给已处于阻塞状 态的进程，使其能继续运行。 上述的四种方法，从(1)到(4)对死锁的防范程度逐渐减弱，但对应的是资源利用率的提 高，以及进程因资源因素而阻塞的频度下降（即并发程度提高)。\n\n3.6预防死锁 锁。由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破 坏产生死锁的后三个条件。"
          },
          {
            "三级标题": "3.6.1 破坏“请求和保持”条件 一一← 为了能破坏“请求和保持”条件，系统必须保证做到：当一个进程在请求资源时，它 不能持有不可抢占资源。该保证可通过如下两个不同的协议实现：",
            "正文": "1.第一种协议 该协议规定，所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需 的全部资源。此时若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给它。 这样，该进程在整个运行期间，便不会再提出资源要求，从而破坏了“请求”条件。系统 在分配资源时，只要有一种资源不能满足进程的要求，即使其它所需的各资源都空闲也不 分配给该进程，而让该进程等待。由于该进程在等待期间未占有任何资源，于是破坏了“保 108"
          }
        ]
      },
      {
        "二级标题": "3.6_预防死锁",
        "三级内容": [
          {
            "三级标题": "3.6.1 破坏“请求和保持”条件 一一← 为了能破坏“请求和保持”条件，系统必须保证做到：当一个进程在请求资源时，它 不能持有不可抢占资源。该保证可通过如下两个不同的协议实现：",
            "正文": "1.第一种协议 该协议规定，所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需 的全部资源。此时若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给它。 这样，该进程在整个运行期间，便不会再提出资源要求，从而破坏了“请求”条件。系统 在分配资源时，只要有一种资源不能满足进程的要求，即使其它所需的各资源都空闲也不 分配给该进程，而让该进程等待。由于该进程在等待期间未占有任何资源，于是破坏了“保 108  第三章处理机调度与死锁 持”条件，从而可以预防死锁的发生。 第一种协议的优点是简单、易行且安全。但缺点也极其明显：\n\n（1）资源被严重浪费，严重地恶化了资源的利用率。进程在开始运行时就一次性地占 用了整个运行过程所需的全部资源，其中有些资源可能仅在运行初期或运行快结束时才使 用，甚至根本不使用。\n\n（2）使进程经常会发生饥饿现象。因为仅当进程在获得了其所需的全部资源后才能开 始运行，这样就可能由于个别资源长期被其它进程占用，而致使等待该资源的进程迟迟不 能开始运行，而个别资源有可能仅在进程运行到最后才需要，如打印机往往就是如此。\n\n2.第二种协议 该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开 始运行。进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求 新的所需资源。我们可以通过一个具体例子来说明，第二种协议比第一种协议要好。例如 有一个进程，它所要完成的任务是，先将数据从磁带上复制到磁盘文件上，然后对磁盘文 件进行排序，最后把结果打印出来。在采用第一种协议时，进程必须在开始时就请求磁带 机、磁盘文件和打印机。然而打印机仅在最后才会用到，既影响到其利用率，还会影响到 其它进程的运行。此外，又如磁带机和磁盘文件虽然空闲，但因打印机已分配给其它进程， 因而进程还需要等待。 在采用第二种协议时，进程在开始时只需请求磁带机、磁盘文件，然后就可运行。等 到全部磁带上的数据已复制到磁盘文件中并已排序好后，便可将磁带机和磁盘文件释放掉， 再去请求磁盘文件和打印机。这不仅能使进程更快地完成任务，提高设备的利用率，还可 减少进程发生饥饿的机率。"
          },
          {
            "三级标题": "3.6.3 破坏“循环等待”条件 并赋予不同的序号。设R=(R，R2,R3，，Rm)为资源类型的集合，为每个资源类型赋予唯一 的序号。如果系统中有磁带驱动器、硬盘驱动器、打印机，则函数F可按如下形式来定义： F(tape drive) = 1; 109  计算机操作系统 F(disk drive) = 5; F(printer) =12; 在对系统所有资源类型进行线性排序后，便可采用这样的预防协议：规定每个进程必 须按序号递增的顺序请求资源。一个进程在开始时，可以请求某类资源R；的单元。以后， 当且仅当F(R)>F(R;)时，进程才可以请求资源R的单元。如果需要多个同类资源单元， 则必须一起请求。例如，当某进程需要同时使用打印机和磁带机时，由于磁带机序号低， 而打印机序号高，故必须先请求磁带机，再请求打印机。假如某进程已请求到一些序号较 高的资源，后来它又想请求一个序号低的资源时，它必须先释放所有具有相同和更高序号 的资源后，才能申请序号低的资源。在采用这种策略后所形成的资源分配图中，不可能再 出现环路，因而破坏了“循环等待”条件。事实上，总有一个进程占据了较高序号的资源， 此后它继续申请的资源必然是空闲的，因而进程可以一直向前推进。 在采用这种策略时，应如何来规定每种资源的序号是十分重要的。通常应根据大多数 进程需要资源的先后顺序来确定。一般情况下，进程总是先输入程序和数据，继而进行运 算，最后将计算结果输出。故可以为输入设备规定较低的序号，如前面是将磁带机定为1； 为输出设备规定较高的序号，如把打印机定为12。 善。但也存在下述问题：首先，为系统中各类资源所规定的序号必须相对稳定，这就限制 了新类型设备的增加：其次，尽管在为资源的类型分配序号时，已经考虑到大多数作业在 定的顺序不同，造成对资源的浪费。第三，为方便用户，系统对用户在编程时所施加的限制 条件应尽量少，然而这种按规定次序申请资源的方法必然会限制用户简单、自主地编程，",
            "正文": "13.7避免死锁 避免死锁同样是属于事先预防的策略，但并不是事先采取某种限制措施，破坏产生死 锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。 这种方法所施加的限制条件较弱，可能获得较好的系统性能，目前常用此方法来避免发生 死锁。"
          },
          {
            "三级标题": "3.7.1 系统安全状态 在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态 时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。",
            "正文": "1.安全状态 在该方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次 否则，令进程等待。所谓安全状态，是指系统能按某种进程推进顺序（P，P2，“，P)为每个 进程P;分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完 成。此时称(P1，P2，“，P)为安全序列。如果系统无法找到这样一个安全序列，则称系统处 110"
          }
        ]
      },
      {
        "二级标题": "3.7_避免死锁",
        "三级内容": [
          {
            "三级标题": "3.7.1 系统安全状态 在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态 时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。",
            "正文": "1.安全状态 在该方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次 否则，令进程等待。所谓安全状态，是指系统能按某种进程推进顺序（P，P2，“，P)为每个 进程P;分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完 成。此时称(P1，P2，“，P)为安全序列。如果系统无法找到这样一个安全序列，则称系统处 110  第三章处理机调度与死锁 于不安全状态。虽然并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状 态后，就有可能进入死锁状态。反之，只要系统处于安全状态，系统便不会进入死锁状态。 因此，避免死锁的实质在于，系统在进行资源分配时，应使系统不进入不安全状态。\n\n2.安全状态之例 假定系统中有三个进程P、P2和P3，共有12台磁带机。进程P总共要求10台磁带 机，P2和P3分别要求4台和9台。假设在T时刻，进程P、P2和P3已分别获得5台、2 台和2台磁带机，尚有3台空闲未分配，如下表所示： 进程- 最大需求 已分配 可用 P 10 5 3 P2 4 2 P3 9 2 经分析发现，在To时刻系统是安全的，因为这时存在一个安全序列（P2，P1，P3)，即 只要系统按此进程序列分配资源，就能使每个进程都顺利完成。例如将剩余的磁带机取2 台分配给P2，使之继续运行，待P2完成便可释放出4台磁带机，于是可用资源增至5台； 以后再将这些全部分配给进程P1，使之运行，待P完成后，将释放出10台磁带机，P3便 能获得足够的资源，从而使P、P2、P3每个进程都能顺利完成。\n\n3.由安全状态向不安全状态的转换 如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如在To 时刻以后P又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入 不安全状态。因为此时也无法再找到一个安全序列。例如把其余的2台分配给P2，这样在 P2完成后，只能释放出4台，既不能满足P尚需5台的要求，也不能满足P3需要6台的 要求，致使它们都无法推进到完成，彼此都在等待对方释放资源，结果导致死锁。类似地， 如果我们将剩余的2台磁带机先分配给P或P3，也同样都无法使它们推进到完成，因此从 给P分配了第3台磁带机开始，系统便又进入了不安全状态。 在建立了系统安全状态的概念后，便可知道避免死锁的基本思想，就是确保系统始终 处于安全状态。一个系统开始是处于安全状态的。当有进程请求一个可用资源时，系统需 对该进程的请求进行计算，若将资源分配给进程后系统仍处于安全状态，才将该资源分配 给进程。在上面的例子中，在P请求1台磁带机时，尽管系统中有可用的磁带机，但却不 能分配给它。必须等待到P和P2完成并释放出资源后再将足够的资源分配给P3。"
          },
          {
            "三级标题": "3.7.2 利用银行家算法避免死锁 最有代表性的避免死锁的算法是Dijkstra的银行家算法。起这样的名字是由于该算法 原本是为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需 要的情况。在OS中也可用它来实现避免死锁。 为实现银行家算法，每一个新进程在进入系统时，它必须申明在运行过程中，可能需 要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一 组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将 这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它， 111  计算机操作系统 否则让进程等待。",
            "正文": "1.银行家算法中的数据结构 为了实现银行家算法，在系统中必须设置这样四个数据结构，分别用来描述系统中可 利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少 资源的情况。 随该类资源的分配和回收而动态地改变。如果Available[j]=K，则表示系统中现有R;类资 源K个。\n\n(2）最大需求矩阵Max。这是一个n×m的矩阵，它定义了系统中n个进程中的每一个 进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rg类资源的最大数目 为K。\n\n（3）分配矩阵Allocation。这也是一个n×m的矩阵，它定义了系统中每一类资源当前 的数目为K。\n\n（4）需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源 数。如果Need[i,j]=K，则表示进程i还需要Rg类资源K个方能完成其任务。 上述三个矩阵间存在下述关系： Need[i, j] = Max[i, j] - Allocation[i, j]\n\n2.银行家算法 设Request是进程P的请求向量，如果Request;[j]=K，表示进程P需要K个R类型 的资源。当P发出资源请求后，系统按下述步骤进行检查：\n\n(1）如果Request;[j]≤Need[i，j]，便转向步骤(2)；否则认为出错，因为它所需要的资 源数已超过它所宣布的最大值。\n\n(2）如果Request;[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，P须 等待。\n\n(3）系统试探着把资源分配给进程P，并修改下面数据结构中的数值： Available[j] =Available[j] -Request;[j]; Allocation[i, j] = Allocation[i, j] + Request;[j]; Need[i, j] = Need[i, j] - Request;[j];\n\n(4）系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才 正式将资源分配给进程P，以完成本次分配；否则，将本次的试探分配作废，恢复原来的 资源分配状态，让进程P等待。\n\n3.安全性算法 系统所执行的安全性算法可描述如下：\n\n（1）设置两个向量：①工作向量Work，它表示系统可提供给进程继续运行所需的各类 资源数目，它含有m个元素，在执行安全算法开始时，Work：=Available；②Finish：它表 示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]：=false；当有 112  第三章处理机调度与死锁 足够资源分配给进程时，再令Finish[i]：=true。\n\n(2）从进程集合中找到一个能满足下述条件的进程： ① Finish[i]=false; ② Need[i, j]≤Work[j]; 若找到，执行步骤(3)，否则，执行步骤(4)。\n\n(3）当进程P获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应 执行： Work[j] =Work[j]+Allocation[i,j]; Finish[i] =true; go to step 2;\n\n(4）如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处 于不安全状态。\n\n4.银行家算法之例 假定系统中有五个进程{Po,P，P2,P3,P4}和三类资源{A，B,C}，各种资源的数量分别为\n\n10、5、7，在T时刻的资源分配情况如图3-15所示。 资源 Max Allocation Need Available 情况 A B C A B C A B C A B C 进程 Po 7 5 3 0 1 0 7 4 3 3 3 2 (2 3 0) P 3 2 2 2 0 0 1 2 2 (3 0 2) (0 2 0) P2 9 0 2 3 0 2 6 0 0 P3 2 2 2 2 1 1 0 1 1 P4 4 3 3 0 0 2 4 3 1 图3-15T时刻的资源分配表\n\n(1）To时刻的安全性：利用安全性算法对To时刻的资源分配情况进行分析(如图3-16 所示)可知，在To时刻存在着一个安全序列{P1,P3,P4,P2,Po}，故系统是安全的。 资源 Max Need Allocation Work+Allocation 情况 Finish A B C A B C A B C A B C 进程 P 3 3 2 1 2 2 2 0 0 5 3 2 true P3 5 3 2 0 1 7 4 1 2 1 1 3 true P4 7 4 3 4 3 1 0 0 2 7 4 5 true P2 7 4 5 6 0 0 3 0 2 10 4 7 true 10 4 0 10 Po 7 4 3 0 1 7 7 true 图3-16To时刻的安全序列 113  计算机操作系统\n\n(2）P请求资源：P发出请求向量Request(1,0,2)，系统按银行家算法进行检查： ① Request;(1, 0, 2)≤Need(1, 2, 2); ② Request;(1, 0, 2)≤Available;(3, 3, 2); ③系统先假定可为P分配资源，并修改Available，Allocation和Need向量，由此形 成的资源变化情况如图3-15中的圆括号所示； ④再利用安全性算法检查此时系统是否安全，如图3-17所示。 资源 Work Need Allocation Work+Allocation 情况 Finish A B C A B C A B C A B C 进程 P 2 3 0 2 0 3 0 2 3 2 true P3 5 3 2 0 1 1 2 1 1 7 4 3 true P4 7 4 3 3 1 0 0 2 7 4 5 true Po 7 4 5 7 4 3 0 1 0 7 5 5 true P2 7 5 5 6 0 0 3 2 10 5 7 true 0 图3-17P申请资源时的安全性检查 由所进行的安全性检查得知，可以找到一个安全序列{P，P3，P4，P2，Po}。因此，系 统是安全的，可以立即将P所申请的资源分配给它。 ① Request4(3, 3, 0)≤Need4(4, 3, 1); ②Request4(3，3，0)>Available(2，3，0)，让P4等待。\n\n(4）Po请求资源：Po发出请求向量Requesto(0，2，O)，系统按银行家算法进行检查： ① Requesto(0, 2,0)≤Needo(7, 4, 3); ② Requesto(0, 2,0)≤Available(2, 3,0); ③系统暂时先假定可为Po分配资源，并修改有关数据，如图3-18所示。 资源 Allocation Need Available 情况 A B C A B C A B C 进 程 Po 0 3 0 7 2 3 2 1 0 P 3 0 2 0 2 0 P2 3 0 2 6 0 0 1 P3 2 0 1 1 0 0 2 4 3 P4 1 图3-18为Po分配资源后的有关资源数据\n\n(5）进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系 统进入不安全状态，此时系统不分配资源。 如果在银行家算法中把Po发出的请求向量改为Requesto(O，1，0)，系统是否能将资源 分配给它，请读者考虑。 114  第三章处理机调度与死锁 /3.8死锁的检测与解除 如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，系统很可能会发生 死锁。在这种情况下，系统应当提供两个算法： ①死锁检测算法。该方法用于检测系统状态，以确定系统中是否发生了死锁。 ②死锁解除算法。当认定系统中已发生了死锁，利用该算法可将系统从死锁状态中解 脱出来。"
          },
          {
            "三级标题": "3.8.1 死锁的检测 1 为了能对系统中是否已发生了死锁进行检测，在系统中必须：①保存有关资源的请求 和分配信息；②提供一种算法，它利用这些信息来检测系统是否已进入死锁状态。",
            "正文": "1.资源分配图（ResourceAllocationGraph) 系统死锁，可利用资源分配图来描述。该图是由一组结点N和一组边E所组成的一个 对偶G=(N,E)，它具有下述形式的定义和限制：\n\n(1）把N分为两个互斥的子集，即一组进程结点P={P，P2，“,Pn}和一组资源结点 R={R,R2，\",Rn}，N=PUR。在图3-19所示的例子中，P={P,P2}，R={R,R2}， N={R,R2}U{P1,P2}。 是资源请求边，由进程P指向资源R，它表示进程P;请求一个单位的R;资源。E={R，P} 是资源分配边，由资源R指向进程P，它表示把一个单位的资源R分配给进程P。图3-19 中示出了两个请求边和两个分配边，即E={(P1,R2),(R2,P2),(P2,R1),(R,P1)}。 (P R2O O O 图3-19每类资源有多个时的情况 我们用圆圈代表一个进程，用方框代表一类资源。由于一种类型的资源可能有多个， 我们用方框中的一个点代表一类资源中的一个资源。此时，请求边是由进程指向方框中的 R，而分配边则应始于方框中的一个点。图3-20示出了一个资源分配图。图中，P进程已 又请求R资源。 115"
          }
        ]
      },
      {
        "二级标题": "3.8_死锁的检测与解除",
        "三级内容": [
          {
            "三级标题": "3.8.1 死锁的检测 1 为了能对系统中是否已发生了死锁进行检测，在系统中必须：①保存有关资源的请求 和分配信息；②提供一种算法，它利用这些信息来检测系统是否已进入死锁状态。",
            "正文": "1.资源分配图（ResourceAllocationGraph) 系统死锁，可利用资源分配图来描述。该图是由一组结点N和一组边E所组成的一个 对偶G=(N,E)，它具有下述形式的定义和限制：\n\n(1）把N分为两个互斥的子集，即一组进程结点P={P，P2，“,Pn}和一组资源结点 R={R,R2，\",Rn}，N=PUR。在图3-19所示的例子中，P={P,P2}，R={R,R2}， N={R,R2}U{P1,P2}。 是资源请求边，由进程P指向资源R，它表示进程P;请求一个单位的R;资源。E={R，P} 是资源分配边，由资源R指向进程P，它表示把一个单位的资源R分配给进程P。图3-19 中示出了两个请求边和两个分配边，即E={(P1,R2),(R2,P2),(P2,R1),(R,P1)}。 (P R2O O O 图3-19每类资源有多个时的情况 我们用圆圈代表一个进程，用方框代表一类资源。由于一种类型的资源可能有多个， 我们用方框中的一个点代表一类资源中的一个资源。此时，请求边是由进程指向方框中的 R，而分配边则应始于方框中的一个点。图3-20示出了一个资源分配图。图中，P进程已 又请求R资源。 115  计算机操作系统\n\n2.死锁定理 我们可以利用把资源分配图加以简化的方法（图3-19)，来检测当系统处于S状态时， 是否为死锁状态。简化方法如下：\n\n(1）在资源分配图中，找出一个既不阻塞又非独立的进程结点P。在顺利的情况下， P;可获得所需资源而继续运行，直至运行完毕，再释放其所占有的全部资源，这相当于消 去P;的请求边和分配边，使之成为孤立的结点。在图3-20(a)中，将P的两个分配边和一 个请求边消去，便形成图（b)所示的情况。 ? P OOR R00 R2OO ROO P2 (P2 (a) (b) (c) 图3-20资源分配图的简化\n\n（2）P释放资源后，便可使P2获得资源而继续运行，直至P2完成后又释放出它所占有 的全部资源，形成图（c)所示的情况，即将P2的两条请求边和一条分配边消去。\n\n(3）在进行一系列的简化后，若能消去图中所有的边，使所有的进程结点都成为孤立 结点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可 完全简化的。 对于较复杂的资源分配图，可能有多个既未阻塞又非孤立的进程结点。不同的简化顺 序，是否会得到不同的简化图？有关文献已经证明，所有的简化顺序都将得到相同的不可 简化图。同样可以证明：S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不 可完全简化的。该充分条件被称为死锁定理。\n\n3.死锁检测中的数据结构 死锁检测中的数据结构类似于银行家算法中的数据结构：\n\n(1）可利用资源向量Available，它表示了m类资源中每一类资源的可用数目。\n\n(2）把不占用资源的进程（向量Allocation=O)记入L表中，即L;UL。 简化，释放出资源，增加工作向量Work=Work+Allocationi。②将它记入L表中。\n\n（4）若不能把所有进程都记入L表中，便表明系统状态S的资源分配图是不可完全简 化的。因此，该系统状态将发生死锁。 Work=Available; L=-{L,lAllocation =OnRequest;=O} for (all Li L) 116  第三章处理机调度与死锁 for(all Request ;≤Work){ Work=Work + Allocation 1; L,UL; } deadlock=(L={P1,P2,\"，Pn});"
          },
          {
            "三级标题": "3.8.2 死锁的解除 如果利用死锁检测算法检测出在系统中已发生了死锁，则应立即采取相应的措施，以 解除死锁。最简单的处理措施就是立即通知操作员，请操作员来以人工方法处理死锁。另 一种措施则是利用死锁解除算法，把系统从死锁状态中解脱出来。常采用解除死锁的两种 方法是： 死锁状态。",
            "正文": "(2）终止(或撤消)进程。终止(或撤消)系统中的一个或多个死锁进程，直至打破循环环 路，使系统从死锁状态解脱出来。\n\n1.终止进程的方法 1）终止所有死锁进程 这是一种最简单的方法，即是终止所有的死锁进程，死锁自然也就解除了，但所付出 的代价可能会很大。因为其中有些进程可能已经运行了很长时间，已接近结束，一旦被终 止真可谓“功亏一”，以后还得从头再来。还可能会有其它方面的代价，在此不再一一 列举。 2）逐个终止进程 稍微温和的方法是，按照某种顺序，逐个地终止进程，直至有足够的资源，以打破循 环等待，把系统从死锁状态解脱出来为止。但该方法所付出的代价也可能很大。因为每终 止一个进程，都需要用死锁检测算法确定系统死锁是否已经被解除，若未解除还需再终止 止的进程。选择策略最主要的依据是，为死锁解除所付出的“代价最小”。但怎么样才算是 “代价最小”，很难有一个精确的度量。我们在此仅提供在选择被终止进程时应考虑的若干 因素：\n\n(1）进程的优先级的大小;\n\n(2）进程已执行了多少时间，还需要多少时间方能完成？\n\n(3）进程在运行中已经使用资源的多少，以后还需要多少资源？\n\n(4）进程的性质是交互式的还是批处理式的？\n\n2.付出代价最小的死锁解除算法 一种付出代价最小的死锁解除算法如图3-21所示。假定在死锁状态时，已有死锁进程 P，P2，“，Pk。首先终止进程P，使系统状态由S→U1，付出的代价为Cu1，然后，仍然从 S状态中终止进程P2，使状态由S→U2，其代价为Cu2，，如此下去可得到状态U1,U2，“， 117  计算机操作系统 Un。若此时系统仍处于死锁状态，需再进一步终止进程，如此下去，直至解除死锁状态为 止。可见，如果在每一层中找到了所有终止代价最小的进程后，此时通过终止进程以解除 死锁的代价最小。但是，这种方法为了找到这些进程可能付出的代价将是k(k-1)(k-2)·/2C。 显然，所花费的代价很大，因此，这是一种很不实际的方法。 Cs P(Cu,) P(Cu) P(Cu) P 图3-21付出代价最小的死锁解除算法 一个比较有效的方法是对死锁状态S做如下处理：从死锁状态S中先终止一个死锁进 程P，使系统状态由S演变成U1，将P记入被终止进程的集合d(T)中，并把所付出的代 价C加入到Rc（T)中；对死锁进程P2、P等重复上述过程，得到状态U，U2，，U，U后， 再按终止进程时所花费代价的大小，把它插入到由S状态所演变的新状态的队列L中。显 止一个进程后，若系统仍处于死锁状态，则再从U状态按照上述处理方式再依次地终止一 个进程，得到U，U，U’，··，U状态，再从U状态中选取一个代价最小的U，如此 下去，直到死锁状态解除为止。这样，为把系统从死锁状态中解脱出来，所花费的代价可 表示为： R(S)min=min{Cui} +min{Cu;} +min{Cuk} +\n\n1.高级调度与低级调度的主要任务是什么？为什么要引入中级调度？\n\n2.处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？\n\n3.何谓作业、作业步和作业流？\n\n4.在什么情况下需要使用作业控制块JCB，其中包含了哪些内容？\n\n5.在作业调度中应如何确定接纳多少个作业和接纳哪些作业？\n\n6.为什么要引入高响应比优先调度算法？它有何优点？\n\n7.试说明低级调度的主要功能。\n\n8.在抢占调度方式中，抢占的原则是什么？ 118"
          }
        ]
      }
    ]
  }
]